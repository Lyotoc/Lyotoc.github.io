<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lyoto&#39;s Blog</title>
  
  
  <link href="https://lyotoc.github.io/atom.xml" rel="self"/>
  
  <link href="https://lyotoc.github.io/"/>
  <updated>2022-09-22T03:18:16.385Z</updated>
  <id>https://lyotoc.github.io/</id>
  
  <author>
    <name>Lyoto</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>腾讯大数据开发工程师笔试题</title>
    <link href="https://lyotoc.github.io/2022/09/21/%E8%85%BE%E8%AE%AF%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://lyotoc.github.io/2022/09/21/%E8%85%BE%E8%AE%AF%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98/</id>
    <published>2022-09-21T03:17:17.000Z</published>
    <updated>2022-09-22T03:18:16.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="腾讯大数据开发工程师笔试题"><a href="#腾讯大数据开发工程师笔试题" class="headerlink" title="腾讯大数据开发工程师笔试题"></a>腾讯大数据开发工程师笔试题</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922104306031.png" alt="image-20220922104306031"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922105827035.png" alt="image-20220922105827035"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922105845913.png" alt="image-20220922105845913"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922105856493.png" alt="image-20220922105856493"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110209816.png" alt="image-20220922110209816"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110159169.png" alt="image-20220922110159169"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110307137.png" alt="image-20220922110307137"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110252044.png" alt="image-20220922110252044"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110321648.png" alt="image-20220922110321648"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110336700.png" alt="image-20220922110336700"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110359456.png" alt="image-20220922110359456"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110416142.png" alt="image-20220922110416142"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110535367.png" alt="image-20220922110535367"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220922110930539.png" alt="image-20220922110930539"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;腾讯大数据开发工程师笔试题&quot;&gt;&lt;a href=&quot;#腾讯大数据开发工程师笔试题&quot; class=&quot;headerlink&quot; title=&quot;腾讯大数据开发工程师笔试题&quot;&gt;&lt;/a&gt;腾讯大数据开发工程师笔试题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsde</summary>
      
    
    
    
    
    <category term="笔试" scheme="https://lyotoc.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis配置文件详解</title>
    <link href="https://lyotoc.github.io/2022/09/18/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lyotoc.github.io/2022/09/18/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-09-18T02:26:16.000Z</published>
    <updated>2022-09-18T02:27:34.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis配置文件详解"><a href="#Redis配置文件详解" class="headerlink" title="Redis配置文件详解"></a>Redis配置文件详解</h1><h2 id="1-Redis文件目录"><a href="#1-Redis文件目录" class="headerlink" title="1.Redis文件目录"></a>1.Redis文件目录</h2><p>（1）全局搜索配置文件 redis.conf 所在目录，和Redis相关的参数配置都在此目录下设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata1 ~]# find / -name redis.conf</span><br></pre></td></tr></table></figure><p>（2）命令所在目录</p><p>在Redis安装目录下的bin目录，例如：&#x2F;opt&#x2F;redis-5.0.7&#x2F;bin</p><h2 id="2-Redis配置字段解析"><a href="#2-Redis配置字段解析" class="headerlink" title="2.Redis配置字段解析"></a>2.Redis配置字段解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata1 config]# cat redis.conf </span><br><span class="line">  #是否在后台执行，yes：后台运行；no：不是后台运行</span><br><span class="line">  daemonize yes</span><br><span class="line">   </span><br><span class="line">  #是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。</span><br><span class="line">  protected-mode yes</span><br><span class="line">   </span><br><span class="line">  #redis的进程文件</span><br><span class="line">  pidfile /var/run/redis/redis-server.pid</span><br><span class="line">   </span><br><span class="line">  #redis监听的端口号。</span><br><span class="line">  port 6379</span><br><span class="line">   </span><br><span class="line">  #此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p。</span><br><span class="line">  tcp-backlog 511</span><br><span class="line">   </span><br><span class="line">  #指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求</span><br><span class="line">  #bind 127.0.0.1</span><br><span class="line">  bind 0.0.0.0</span><br><span class="line">   </span><br><span class="line">  #配置unix socket来让redis支持监听本地连接。</span><br><span class="line">  # unixsocket /var/run/redis/redis.sock</span><br><span class="line">   </span><br><span class="line">  #配置unix socket使用文件的权限</span><br><span class="line">  # unixsocketperm 700</span><br><span class="line">   </span><br><span class="line">  # 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。</span><br><span class="line">  timeout 0</span><br><span class="line">   </span><br><span class="line">  #tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。</span><br><span class="line">  tcp-keepalive 0</span><br><span class="line">   </span><br><span class="line">  #指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）</span><br><span class="line">  loglevel notice</span><br><span class="line">   </span><br><span class="line">  #指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null。</span><br><span class="line">  logfile /var/log/redis/redis-server.log</span><br><span class="line">   </span><br><span class="line">  #是否打开记录syslog功能</span><br><span class="line">  # syslog-enabled no</span><br><span class="line">   </span><br><span class="line">  #syslog的标识符。</span><br><span class="line">  # syslog-ident redis</span><br><span class="line">   </span><br><span class="line">  #日志的来源、设备</span><br><span class="line">  # syslog-facility local0</span><br><span class="line">   </span><br><span class="line">  #数据库的数量，默认使用的数据库是DB 0。可以通过SELECT命令选择一个db</span><br><span class="line">  databases 16</span><br><span class="line">   </span><br><span class="line">  # redis是基于内存的数据库，可以通过设置该值定期写入磁盘。</span><br><span class="line">  # 注释掉“save”这一行配置项就可以让保存数据库功能失效</span><br><span class="line">  # 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span><br><span class="line">  # 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span><br><span class="line">  # 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class="line">  save 900 1</span><br><span class="line">  save 300 10</span><br><span class="line">  save 60 10000</span><br><span class="line">   </span><br><span class="line">  #当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span><br><span class="line">  stop-writes-on-bgsave-error yes</span><br><span class="line">   </span><br><span class="line">  #使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">  rdbcompression yes</span><br><span class="line">   </span><br><span class="line">  #是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span><br><span class="line">  rdbchecksum yes</span><br><span class="line">   </span><br><span class="line">  #rdb文件的名称</span><br><span class="line">  dbfilename dump.rdb</span><br><span class="line">   </span><br><span class="line">  #数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span><br><span class="line">  dir /var/lib/redis</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">  ############### 主从复制 ###############</span><br><span class="line">   </span><br><span class="line">  #复制选项，slave复制对应的master。</span><br><span class="line">  # slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">   </span><br><span class="line">  #如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。</span><br><span class="line">  # masterauth &lt;master-password&gt;</span><br><span class="line">   </span><br><span class="line">  #当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。</span><br><span class="line">  slave-serve-stale-data yes</span><br><span class="line">   </span><br><span class="line">  #作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）。</span><br><span class="line">  slave-read-only yes</span><br><span class="line">   </span><br><span class="line">  #是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。</span><br><span class="line">  repl-diskless-sync no</span><br><span class="line">   </span><br><span class="line">  #diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。</span><br><span class="line">  repl-diskless-sync-delay 5</span><br><span class="line">   </span><br><span class="line">  #slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。</span><br><span class="line">  # repl-ping-slave-period 10</span><br><span class="line">   </span><br><span class="line">  #复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。</span><br><span class="line">  # repl-timeout 60</span><br><span class="line">  </span><br><span class="line"> #是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。</span><br><span class="line"> repl-disable-tcp-nodelay no</span><br><span class="line">  </span><br><span class="line"> #复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。</span><br><span class="line"> # repl-backlog-size 5mb</span><br><span class="line">  </span><br><span class="line"> #master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。</span><br><span class="line"> # repl-backlog-ttl 3600</span><br><span class="line">  </span><br><span class="line"> #当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。</span><br><span class="line"> slave-priority 100</span><br><span class="line">  </span><br><span class="line"> #redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。</span><br><span class="line"> # min-slaves-to-write 3</span><br><span class="line">  </span><br><span class="line"> #延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。</span><br><span class="line"> # min-slaves-max-lag 10</span><br><span class="line">  </span><br><span class="line"> # 设置1或另一个设置为0禁用这个特性。</span><br><span class="line"> # Setting one or the other to 0 disables the feature.</span><br><span class="line"> # By default min-slaves-to-write is set to 0 (feature disabled) and</span><br><span class="line"> # min-slaves-max-lag is set to 10.</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> ############### 安全相关 ###############</span><br><span class="line">  </span><br><span class="line"> #requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。注意只有密码没有用户名。</span><br><span class="line"> # requirepass foobared</span><br><span class="line">  </span><br><span class="line"> #把危险的命令给修改成其他名称。比如CONFIG命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。</span><br><span class="line"> # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">  </span><br><span class="line"> #设置成一个空的值，可以禁止一个命令</span><br><span class="line"> # rename-command CONFIG &quot;&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> ############### 进程限制相关 ###############</span><br><span class="line">  </span><br><span class="line"> # 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。</span><br><span class="line"> # maxclients 10000</span><br><span class="line">  </span><br><span class="line"> #redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。</span><br><span class="line"> # maxmemory &lt;bytes&gt;</span><br><span class="line">  </span><br><span class="line"> #内存容量超过maxmemory后的处理策略。</span><br><span class="line"> #volatile-lru：利用LRU算法移除设置过过期时间的key。</span><br><span class="line"> #volatile-random：随机移除设置过过期时间的key。</span><br><span class="line"> #volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span><br><span class="line"> #allkeys-lru：利用LRU算法移除任何key。</span><br><span class="line"> #allkeys-random：随机移除任何key。</span><br><span class="line"> #noeviction：不移除任何key，只是返回一个写错误。</span><br><span class="line"> #上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。</span><br><span class="line"> # maxmemory-policy noeviction</span><br><span class="line">  </span><br><span class="line"> #lru检测的样本数。使用lru或者ttl淘汰算法，从需要淘汰的列表中随机选择sample个key，选出闲置时间最长的key移除。</span><br><span class="line"> # maxmemory-samples 5</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> ############### APPEND ONLY 持久化方式 ###############</span><br><span class="line">  </span><br><span class="line"> #默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span><br><span class="line"> appendonly no</span><br><span class="line">  </span><br><span class="line"> #aof文件名</span><br><span class="line"> appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">  </span><br><span class="line"> #aof持久化策略的配置</span><br><span class="line"> #no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="line"> #always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class="line"> #everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br><span class="line"> appendfsync everysec</span><br><span class="line">  </span><br><span class="line"> # 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</span><br><span class="line"> no-appendfsync-on-rewrite no</span><br><span class="line">  </span><br><span class="line"> #aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</span><br><span class="line"> auto-aof-rewrite-percentage 100</span><br><span class="line"> #设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span><br><span class="line"> auto-aof-rewrite-min-size 64mb</span><br><span class="line">  </span><br><span class="line"> #aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span><br><span class="line"> aof-load-truncated yes</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> ############### LUA SCRIPTING ###############</span><br><span class="line">  </span><br><span class="line"> # 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。</span><br><span class="line"> lua-time-limit 5000</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> ############### 集群相关 ###############</span><br><span class="line">  </span><br><span class="line"> #集群开关，默认是不开启集群模式。</span><br><span class="line"> # cluster-enabled yes</span><br><span class="line">  </span><br><span class="line"> #集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</span><br><span class="line"> # cluster-config-file nodes-6379.conf</span><br><span class="line">  </span><br><span class="line"> #节点互连超时的阀值。集群节点超时毫秒数</span><br><span class="line"> # cluster-node-timeout 15000</span><br><span class="line">  </span><br><span class="line"> #在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：</span><br><span class="line"> #比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line"> #如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 </span><br><span class="line"> # cluster-slave-validity-factor 10</span><br><span class="line">  </span><br><span class="line"> #master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。</span><br><span class="line"> # cluster-migration-barrier 1</span><br><span class="line">  </span><br><span class="line"> #默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</span><br><span class="line"> # cluster-require-full-coverage yes</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> ############### SLOW LOG 慢查询日志 ###############</span><br><span class="line">  </span><br><span class="line"> ###slog log是用来记录redis运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。</span><br><span class="line"> #执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。</span><br><span class="line"> slowlog-log-slower-than 10000</span><br><span class="line">  </span><br><span class="line"> #慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。</span><br><span class="line"> slowlog-max-len 128</span><br><span class="line">  </span><br><span class="line"> ############### 延迟监控 ###############</span><br><span class="line"> #延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。</span><br><span class="line"> latency-monitor-threshold 0</span><br><span class="line">  </span><br><span class="line"> ############### EVENT NOTIFICATION 订阅通知 ###############</span><br><span class="line"> #键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。</span><br><span class="line"> #notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：</span><br><span class="line"> ##K 键空间通知，所有通知以 __keyspace@__ 为前缀</span><br><span class="line"> ##E 键事件通知，所有通知以 __keyevent@__ 为前缀</span><br><span class="line"> ##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</span><br><span class="line"> ##$ 字符串命令的通知</span><br><span class="line"> ##l 列表命令的通知</span><br><span class="line"> ##s 集合命令的通知</span><br><span class="line"> ##h 哈希命令的通知</span><br><span class="line"> ##z 有序集合命令的通知</span><br><span class="line"> ##x 过期事件：每当有过期键被删除时发送</span><br><span class="line"> ##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</span><br><span class="line"> ##A 参数 g$lshzxe 的别名</span><br><span class="line"> #输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http://redis.io/topics/notifications</span><br><span class="line"> notify-keyspace-events &quot;&quot;</span><br><span class="line">  </span><br><span class="line"> ############### ADVANCED CONFIG 高级配置 ###############</span><br><span class="line"> #数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash</span><br><span class="line"> hash-max-ziplist-entries 512</span><br><span class="line"> #value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash。</span><br><span class="line"> hash-max-ziplist-value 64</span><br><span class="line">  </span><br><span class="line"> #数据量小于等于list-max-ziplist-entries用ziplist，大于list-max-ziplist-entries用list。</span><br><span class="line"> list-max-ziplist-entries 512</span><br><span class="line"> #value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。</span><br><span class="line"> list-max-ziplist-value 64</span><br><span class="line">  </span><br><span class="line"> #数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set。</span><br><span class="line"> set-max-intset-entries 512</span><br><span class="line">  </span><br><span class="line"> #数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。</span><br><span class="line"> zset-max-ziplist-entries 128</span><br><span class="line"> #value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。</span><br><span class="line"> zset-max-ziplist-value 64</span><br><span class="line">  </span><br><span class="line"> #value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max-bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。</span><br><span class="line"> hll-sparse-max-bytes 3000</span><br><span class="line">  </span><br><span class="line"> #Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。</span><br><span class="line"> activerehashing yes</span><br><span class="line">  </span><br><span class="line"> ##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。</span><br><span class="line"> #对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。</span><br><span class="line"> client-output-buffer-limit normal 0 0 0</span><br><span class="line"> #对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。</span><br><span class="line"> client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line"> #对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。</span><br><span class="line"> client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">  </span><br><span class="line"> #redis执行任务的频率为1s除以hz。</span><br><span class="line"> hz 10</span><br><span class="line">  </span><br><span class="line"> #在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。</span><br><span class="line"> aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><h2 id="3-查看内存使用情况"><a href="#3-查看内存使用情况" class="headerlink" title="3.查看内存使用情况"></a>3.查看内存使用情况</h2><p>进入Redis交互界面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata1 bin]# ./redis-cli</span><br><span class="line">127.0.0.1:6379&gt; AUTH [password]</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; INFO</span><br></pre></td></tr></table></figure><p>字段解析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"> # Server</span><br><span class="line"> redis_version:5.0.7</span><br><span class="line"> redis_git_sha1:00000000</span><br><span class="line"> redis_git_dirty:0</span><br><span class="line"> redis_build_id:9ffa6dd96f09423b</span><br><span class="line"> redis_mode:cluster</span><br><span class="line"> os:Linux 3.10.0-1062.el7.x86_64 x86_64</span><br><span class="line"> arch_bits:64</span><br><span class="line"> multiplexing_api:epoll</span><br><span class="line"> atomicvar_api:atomic-builtin</span><br><span class="line"> gcc_version:4.8.5</span><br><span class="line"> process_id:12030　　　　　　　　　　　　　　 #redis服务器的进程id</span><br><span class="line"> run_id:c32be4211a2e89412c185d7b8769938fedc59646</span><br><span class="line"> tcp_port:6379　　　　　　　　　　　　　　　　#redis服务监听端口</span><br><span class="line"> uptime_in_seconds:719019　　　　　　　　　 #redis服务启动时长，单位为秒</span><br><span class="line"> uptime_in_days:8　　　　　　　　　　　　　　 #redis服务启动时长，单位为天</span><br><span class="line"> hz:10　　　　　　　　　　　　　　　　　　　　　#redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率</span><br><span class="line"> configured_hz:10</span><br><span class="line"> lru_clock:11623320</span><br><span class="line"> executable:/opt/redis-5.0.7/bin/redis-server　　　　　　　　 #执行文件位置</span><br><span class="line"> config_file:/data/redis/redis6379/config/redis.conf　　　　 #配置文件位置</span><br><span class="line"> </span><br><span class="line"> # Clients</span><br><span class="line"> connected_clients:5　　　　　　　　　　　　  #已连接的客户端数(不包括通过slave连接的客户端)</span><br><span class="line"> client_recent_max_input_buffer:2</span><br><span class="line"> client_recent_max_output_buffer:0</span><br><span class="line"> blocked_clients:0　　　　　　　　　　　　　　#正在等待阻塞命令(BLPOP、BRPOP、BRPOPLPUSH)的客户端的数量</span><br><span class="line"> </span><br><span class="line"> # Memory</span><br><span class="line"> used_memory:217664160　　　　　　　　　　　　#由redis分配器分配的内存总量，以字节为单位</span><br><span class="line"> used_memory_human:207.58M　　　　　　　　　 #易读方式 </span><br><span class="line"> used_memory_rss:258060288　　　　　　　　　 #从操作系统的角度，返回redis已分配的内存总量(俗称常驻集大小)</span><br><span class="line"> used_memory_rss_human:246.11M　　　　　　　#易读方式</span><br><span class="line"> used_memory_peak:526793304　　　　　　　　  #redis的内存消耗峰值(以字节为单位) </span><br><span class="line"> used_memory_peak_human:502.39M　　　　　　 #易读方式</span><br><span class="line"> used_memory_peak_perc:41.32%　　　　　　　　#峰值内存超出分配内存（used_memory）的百分比</span><br><span class="line"> used_memory_overhead:5144756　　　　　　　　#服务器为管理其内部数据结构而分配的所有开销的字节总和</span><br><span class="line"> used_memory_startup:1404744　　　　　　　　 #Redis在启动时消耗的初始内存量（以字节为单位）</span><br><span class="line"> used_memory_dataset:212519404　　　　　　　 #数据占用内存的大小，即used_memory-sed_memory_overhead</span><br><span class="line"> used_memory_dataset_perc:98.27%　　　　　　#数据占用内存的大小百分比，即(used_memory/ used_memory_peak) *100%</span><br><span class="line"> allocator_allocated:217597568　　　　　　　 </span><br><span class="line"> allocator_active:258022400　　　　　　　　　</span><br><span class="line"> allocator_resident:258022400　　　　　　　　</span><br><span class="line"> total_system_memory:33567330304　　　　　　#系统内存总量</span><br><span class="line"> total_system_memory_human:31.26G　　　　　 #以更直观的格式显示整个系统内存</span><br><span class="line"> used_memory_lua:37888　　　　　　　　　　　　#Lua脚本存储占用的内存</span><br><span class="line"> used_memory_lua_human:37.00K　　　　　　　　#以更直观的格式显示Lua脚本存储占用的内存</span><br><span class="line"> used_memory_scripts:0</span><br><span class="line"> used_memory_scripts_human:0B</span><br><span class="line"> number_of_cached_scripts:0</span><br><span class="line"> maxmemory:0　　　　　　　　　　　　　　　　　　#配置设置的最大可使用内存值，如果将Redis当成数据库使用，则不设置</span><br><span class="line"> maxmemory_human:0B　　　　　　　　　　　　　　#以更直观的格式显示Redis实例的最大内存配置</span><br><span class="line"> maxmemory_policy:noeviction　　　　　　　　 #当达到maxmemory时的淘汰策略</span><br><span class="line"> allocator_frag_ratio:1.19</span><br><span class="line"> allocator_frag_bytes:40424832</span><br><span class="line"> allocator_rss_ratio:1.00</span><br><span class="line"> allocator_rss_bytes:0</span><br><span class="line"> rss_overhead_ratio:1.00</span><br><span class="line"> rss_overhead_bytes:37888</span><br><span class="line"> mem_fragmentation_ratio:1.19　　　　　　　 #碎片率，used_memory_rss和used_memory之间的比率</span><br><span class="line"> mem_fragmentation_bytes:40462720　　　　  #used_memory_rss和used_memory之间的差值，单位字节</span><br><span class="line"> mem_not_counted_for_evict:1248</span><br><span class="line"> mem_replication_backlog:1048584</span><br><span class="line"> mem_clients_slaves:49694</span><br><span class="line"> mem_clients_normal:117382　　　　　　　　 </span><br><span class="line"> mem_aof_buffer:1248</span><br><span class="line"> mem_allocator:libc　　　　　　　　　　　　　 #内存分配器</span><br><span class="line"> active_defrag_running:0　　　　　　　　　　 #表示没有活动的defrag任务正在运行，1表示有活动的defrag任务正在运行（defrag:表示内存碎片整理）</span><br><span class="line"> lazyfree_pending_objects:0　　　　　　　　 #指示活动碎片整理是否处于活动状态的标志，表示不存在延迟释放待的挂起对象</span><br><span class="line"> </span><br><span class="line"> # Persistence</span><br><span class="line"> loading:0　　　　　　　　　　　　　　　　　　  #服务器是否正在载入持久化rdb文件</span><br><span class="line"> rdb_changes_since_last_save:2033　　　　  #自上次rdb持久化以来发生改变的数值</span><br><span class="line"> rdb_bgsave_in_progress:0　　　　　　　　　　#服务器是否正在创建rdb文件</span><br><span class="line">  rdb_last_save_time:1588681336　　　　　　　#最后一次成功rdb持久化的时间戳</span><br><span class="line">  rdb_last_bgsave_status:ok　　　　　　　　　 #最后一次rdb持久化是否成功</span><br><span class="line">  rdb_last_bgsave_time_sec:3　　　　　　　　　#最后一次成功生成rdb文件耗时秒数</span><br><span class="line">  rdb_current_bgsave_time_sec:-1　　　　　　 #当前bgsave已耗费的时间（如果有）</span><br><span class="line">  rdb_last_cow_size:2326528　　　　　　　　　 #上次rbd保存操作期间写时复制分配的字节大小</span><br><span class="line">  aof_enabled:1　　　　　　　　　　　　　　　　 #aof功能是否开启</span><br><span class="line">  aof_rewrite_in_progress:0　　　　　　　　　 #标识aof的rewrite操作是否在进行中</span><br><span class="line">  aof_rewrite_scheduled:0</span><br><span class="line">  aof_last_rewrite_time_sec:4　　　　　　　　#最后一次aof rewrite耗费的时长　　</span><br><span class="line">  aof_current_rewrite_time_sec:-1　　　　　 #当前rewrite已耗费的时间（如果有）</span><br><span class="line">  aof_last_bgrewrite_status:ok　　　　　　　 #最后一次bgrewrite是否成功</span><br><span class="line">  aof_last_write_status:ok　　　　　　　　　　#上次aof写入状态</span><br><span class="line">  aof_last_cow_size:8228864　　　　　　　　　#上次AOF重写操作期间写时复制分配的大小（以字节为单位）</span><br><span class="line"> 如果激活了AOF，则会添加以下附加字段：  88 aof_current_size:139887774　　　　　　　　#aof当前尺寸</span><br><span class="line">  aof_base_size:134945531　　　　　　　　　　#服务器启动时或者aof重写最近一次执行之后aof文件的大小</span><br><span class="line">  aof_pending_rewrite:0　　　　　　　　　　　#是否有aof重写操作在等待rdb文件创建完毕之后执行?</span><br><span class="line">  aof_buffer_length:0　　　　　　　　　　　　 #aof buffer的大小</span><br><span class="line">  aof_rewrite_buffer_length:0　　　　　　　 #aof rewrite buffer的大小</span><br><span class="line">  aof_pending_bio_fsync:0　　　　　　　　　　#后台I/O队列里面，等待执行的fsync调用数量</span><br><span class="line">  aof_delayed_fsync:0　　　　　　　　　　　　 #被延迟的fsync调用数量</span><br><span class="line">  </span><br><span class="line">  # Stats</span><br><span class="line">  total_connections_received:613　　　　　　#服务接受的总连接数</span><br><span class="line">  total_commands_processed:13686559　　　　#服务器处理的总命令数</span><br><span class="line">  instantaneous_ops_per_sec:836　　　　　　 #每秒处理的命令数</span><br><span class="line">1 total_net_input_bytes:6381663743　　　　 #从网络读取的总字节数</span><br><span class="line">1 total_net_output_bytes:33684743304　　  #写入网络的总字节数</span><br><span class="line">1 instantaneous_input_kbps:37.63　　　　　 #网络读取速率KB/sec</span><br><span class="line">1 instantaneous_output_kbps:340.46　　　　 #网络写入速率KB/sec </span><br><span class="line">1 rejected_connections:0　　　　　　　　　　 #因达到最大连接数而拒绝的连接</span><br><span class="line">1 sync_full:1　　　　　　　　　　　　　　　　　#给从节点完全同步的数量</span><br><span class="line">1 sync_partial_ok:0　　　　　　　　　　　　　 #接受的同步请求数量</span><br><span class="line">1 sync_partial_err:1　　　　　　　　　　　　 #拒绝的同步请求数量</span><br><span class="line">1 expired_keys:0　　　　　　　　　　　　　　　#键到期的总数</span><br><span class="line">1 expired_stale_perc:0.00</span><br><span class="line">1 expired_time_cap_reached_count:0</span><br><span class="line">1 evicted_keys:0　　　　　　　　　　　　　　  #因达到maxmemory限制而被驱逐的键的数量</span><br><span class="line">1 keyspace_hits:8303634　　　　　　　　　　　#Number of successful lookup of keys in the main dictionary</span><br><span class="line">1 keyspace_misses:939908　　　　　　　　　　 #Number of failed lookup of keys in the main dictionary</span><br><span class="line">1 pubsub_channels:0</span><br><span class="line">1 pubsub_patterns:0</span><br><span class="line">1 latest_fork_usec:8884　　　　　　　　　　 #最新fork操作的持续时间（以微秒为单位）</span><br><span class="line">1 migrate_cached_sockets:0</span><br><span class="line">1 slave_expires_tracked_keys:0</span><br><span class="line">1 active_defrag_hits:0</span><br><span class="line">1 active_defrag_misses:0</span><br><span class="line">1 active_defrag_key_hits:0</span><br><span class="line">1 active_defrag_key_misses:0</span><br><span class="line">1 </span><br><span class="line">1 # Replication</span><br><span class="line">1 role:master　　　　　　　　　　　　　　　　 #master or slave</span><br><span class="line">1 connected_slaves:1　　　　　　　　　　　　 #已建立连接的从节点数</span><br><span class="line">1 slave0:ip=172.22.90.43,port=6380,state=online,offset=5961433752,lag=0   </span><br><span class="line">1 master_replid:6e6bff1ebbb7d49f469754be694cd13fe7f1ad33　　　　#复制ID</span><br><span class="line">1 master_replid2:76f072b3ed4025665993e53ecc33514af5b012ce　　  #第二个复制ID，用于failover的PSYNC</span><br><span class="line"> master_repl_offset:5961433752　　　　　　#服务当前的复制偏移量</span><br><span class="line"> second_repl_offset:5551399839　　　　　　#The offset up to which replication IDs are accepted</span><br><span class="line"> repl_backlog_active:1</span><br><span class="line"> repl_backlog_size:1048576　　　　　　　　 #复制积压缓冲区的总大小（B）</span><br><span class="line"> repl_backlog_first_byte_offset:5960385177　　　 #复制积压缓冲区的主偏移量</span><br><span class="line"> repl_backlog_histlen:1048576　　　　　　 #复制积压缓冲区中数据的大小</span><br><span class="line"> </span><br><span class="line"> # CPU</span><br><span class="line"> used_cpu_sys:3607.150175　　　　　　　　  #Redis服务消耗的系统cpu</span><br><span class="line"> used_cpu_user:2903.770764　　　　　　　　 #Redis服务消耗的用户cpu</span><br><span class="line"> used_cpu_sys_children:883.656423　　　　 #后台进程占用的系统cpu</span><br><span class="line"> used_cpu_user_children:3843.842870　　　#后台进程占用的用户cpu</span><br><span class="line"> </span><br><span class="line"> # Cluster　　　　　　　　　　　　　　　　　　　#集群信息</span><br><span class="line"> cluster_enabled:1　　　　　　　　　　　　　　</span><br><span class="line"> </span><br><span class="line"> # Keyspace　　　　　　　　　　　　　　　　　　 #数据库的统计信息</span><br><span class="line"> db0:keys=36854,expires=10,avg_ttl=2559355799</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis配置文件详解&quot;&gt;&lt;a href=&quot;#Redis配置文件详解&quot; class=&quot;headerlink&quot; title=&quot;Redis配置文件详解&quot;&gt;&lt;/a&gt;Redis配置文件详解&lt;/h1&gt;&lt;h2 id=&quot;1-Redis文件目录&quot;&gt;&lt;a href=&quot;#1-Redi</summary>
      
    
    
    
    <category term="后端" scheme="https://lyotoc.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Redis" scheme="https://lyotoc.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>史上最全HashMap面试题汇总</title>
    <link href="https://lyotoc.github.io/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://lyotoc.github.io/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-09-01T10:34:17.000Z</published>
    <updated>2022-09-22T03:18:07.602Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录</strong> <a href="about:blank#1.HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%3F">1.HashMap的数据结构?</a> <a href="about:blank#2.HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%3F">2.HashMap的工作原理?</a> <a href="about:blank#3.%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode%E7%9B%B8%E5%90%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%3F">3.当两个对象的hashCode相同会发生什么?</a> <a href="about:blank#4.%E4%BD%A0%E7%9F%A5%E9%81%93hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97%3F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%3F">4.你知道hash的实现吗?为什么要这样实现?</a> <a href="about:blank#5.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%3F">5.为什么要用异或运算符?</a> <a href="about:blank#6.HashMap%E7%9A%84table%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%3FloadFactor%E6%98%AF%E4%BB%80%E4%B9%88%3F%E8%AF%A5%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%3F%E8%BF%99%E7%A7%8D%E5%8F%98%E5%8C%96%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%3F">6.HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题?</a> <a href="about:blank#7.HashMap%E4%B8%ADput%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B%3F">7.HashMap中put方法的过程?</a> <a href="about:blank#8.%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%E7%9A%84%E8%BF%87%E7%A8%8B%3F">8.数组扩容的过程?</a> <a href="about:blank#9.%E6%8B%89%E9%93%BE%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E9%93%BE%E8%A1%A8%E8%BF%87%E6%B7%B1%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%BB%A3%E6%9B%BF%2C%E8%80%8C%E9%80%89%E6%8B%A9%E7%BA%A2%E9%BB%91%E6%A0%91%3F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%B8%80%E7%9B%B4%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%3F">9.拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?为什么不一直使用红黑树?</a> <a href="about:blank#10.%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%A7%81%E8%A7%A3%3F">10.说说你对红黑树的见解?</a> <a href="about:blank#11.jdk8%E4%B8%AD%E5%AF%B9HashMap%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E5%8F%98%3F">11.jdk8中对HashMap做了哪些改变?</a> <a href="about:blank#12.HashMap%2CLinkedHashMap%2CTreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">12.HashMap,LinkedHashMap,TreeMap有什么区别?</a> <a href="about:blank#13.HashMap%26TreeMap%26LinkedHashMap%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%3F">13.HashMap&amp;TreeMap&amp;LinkedHashMap使用场景?</a> <a href="about:blank#14.HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">14.HashMap和HashTable有什么区别?</a> <a href="about:blank#15.Java%E4%B8%AD%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%8EHashMap%E6%9E%81%E5%85%B6%E7%B1%BB%E4%BC%BC%E7%9A%84%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%3F%E5%90%8C%E6%A0%B7%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2C%E5%AE%83%E4%B8%8EHashTable%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%3F">15.Java中的另一个线程安全的与HashMap极其类似的类是什么?同样是线程安全,它与HashTable在线程同步上有什么不同?</a> <a href="about:blank#16.HashMap%26ConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%3F">16.HashMap&amp;ConcurrentHashMap的区别?</a> <a href="about:blank#17.%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E6%AF%94HashTable%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98%3F">17.为什么ConcurrentHashMap比HashTable效率要高?</a> <a href="about:blank#18.%E9%92%88%E5%AF%B9ConcurrentHashMap%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90%28JDK1.7VSJDK1.8%29%3F">18.针对ConcurrentHashMap锁机制具体分析(JDK1.7VSJDK1.8)?</a> <a href="about:blank#19.ConcurrentHashMap%E5%9C%A8JDK1.8%E4%B8%AD%2C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E9%94%81synchronized%E6%9D%A5%E4%BB%A3%E6%9B%BF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%3F">19.ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?</a> <a href="about:blank#20.ConcurrentHashMap%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%3F">20.ConcurrentHashMap简单介绍?</a> <a href="about:blank#21.ConcurrentHashMap%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88%3F">21.ConcurrentHashMap的并发度是什么?</a> </p><h2 id="1-HashMap的数据结构"><a href="#1-HashMap的数据结构" class="headerlink" title="1.HashMap的数据结构?"></a>1.HashMap的数据结构?</h2><p> 哈希表结构(链表散列:数组+链表)实现,结合数组和链表的优点。当链表长度超过<code>8</code>时,链表转换为红黑树。 </p><h2 id="2-HashMap的工作原理"><a href="#2-HashMap的工作原理" class="headerlink" title="2.HashMap的工作原理?"></a>2.HashMap的工作原理?</h2><p> <code>HashMap</code>底层是hash数组和单向链表实现,数组中的每个元素都是链表,由Node内部类(实现<code>Map.Entry&lt;K,V&gt;</code>接口)实现,<code>HashMap</code>通过<code>put&amp;get</code>方法存储和获取。 <strong>存储对象时,将<code>K/V</code>键值传给<code>put()</code>方法:</strong> </p><p>①、调用hash(K)方法计算K的hash值,然后结合数组长度,计算得数组下标;     </p><p>②、调整数组大小(当容器中的元素个数大于capacity*loadfactor时,容器会进行扩容resize为2n);    </p><p> ③   i.如果K的<code>hash</code>值在<code>HashMap</code>中不存在,则执行插入,若存在,则发生碰撞;</p><p>​ii.如果K的<code>hash</code>值在<code>HashMap</code>中存在,且它们两者<code>equals</code>返回<code>true</code>,则更新键值对;</p><p>​iii.如果K的<code>hash</code>值在<code>HashMap</code>中存在,且它们两者<code>equals</code>返回false,则插入链表的尾部(尾插法)或者红黑树中(树的添加方式)。        </p><blockquote><p>(<code>JDK1.7</code>之前使用头插法、<code>JDK1.8</code>使用尾插法)  </p><p> (注意:当碰撞导致链表大于<code>TREEIFY_THRESHOLD=8</code>时,就把链表转换成红黑树)</p></blockquote><p><strong>获取对象时,将<code>K</code>传给<code>get()</code>方法:</strong> </p><p>①、调用hash(K)方法(计算K的hash值)从而获取该键值所在链表的数组下标;</p><p>②、顺序遍历链表,equals()方法查找相同Node链表中K值对应的V值。<code>hashCode</code>是定位的,存储位置;<code>equals</code>是定性的,比较两者是否相等。 </p><h2 id="3-当两个对象的hashCode相同会发生什么"><a href="#3-当两个对象的hashCode相同会发生什么" class="headerlink" title="3.当两个对象的hashCode相同会发生什么?"></a>3.当两个对象的hashCode相同会发生什么?</h2><p> 因为<code>hashCode</code>相同,不一定就是相等的(<code>equals</code>方法比较),所以两个对象所在数组的下标相同,”碰撞”就此发生。又因为<code>HashMap</code>使用链表存储对象,这个<code>Node</code>会存储到链表中。 </p><h2 id="4-你知道hash的实现吗"><a href="#4-你知道hash的实现吗" class="headerlink" title="4.你知道hash的实现吗?"></a>4.你知道hash的实现吗?</h2><p>为什么要这样实现? <code>JDK1.8</code>中,是通过<code>hashCode()</code>的高16位异或低16位实现的:<code>(h=k.hashCode())^(h&gt;&gt;&gt;16)</code>,主要是从速度,功效和质量来考虑的,减少系统的开销,也不会造成因为高位没有参与下标的计算,从而引起的碰撞。 <img src="https://img-blog.csdnimg.cn/20200727193840237.png"> 计算过程如下所示： </p><p>说明：</p><ul><li><p>key.hashCode()；返回散列值也就是hashcode，假设随便生成的一个值。 *   n表示数组初始化的长度是16。</p></li><li><p>&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。 </p></li><li><p>^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。        <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2020072719423689.png"></p></li></ul><p>简单来说就是： <strong>高16bit不变，低16bit和高16bit做了一个异或（得到的hashCode转化为32位二进制，前16位和后16位低16bit和高16bit做了一个异或）</strong> </p><p>问题：为什么要这样操作呢？ 如果当n即数组长度很小，假设是16的话，那么n - 1即为1111 ，这样的值和hashCode直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。 <img src="https://img-blog.csdnimg.cn/20200727194307147.png"></p><h2 id="5-为什么要用异或运算符"><a href="#5-为什么要用异或运算符" class="headerlink" title="5.为什么要用异或运算符?"></a>5.为什么要用异或运算符?</h2><p>保证了对象的<code>hashCode</code>的32位值只要有一位发生改变,整个<code>hash()</code>返回值就会改变。尽可能的减少碰撞。 </p><h2 id="6-HashMap的table的容量如何确定"><a href="#6-HashMap的table的容量如何确定" class="headerlink" title="6.HashMap的table的容量如何确定?"></a>6.HashMap的table的容量如何确定?</h2><p>loadFactor是什么?该容量如何变化?这种变化会带来什么问题? </p><ul><li>①、<code>table</code>数组大小是由<code>capacity</code>这个参数确定的,默认是16,也可以构造时传入,最大限制是1&lt;&lt;30;     </li><li>②、<code>loadFactor</code>是装载因子,主要目的是用来确认<code>table</code>数组是否需要动态扩展,默认值是0.75,比如<code>table</code>数组大小为16,装载因子为0.75时,<code>threshold</code>就是12,当<code>table</code>的实际大小超过12时,<code>table</code>就需要动态扩容;     </li><li>③、扩容时,调用<code>resize()</code>方法,将<code>table</code>长度变为原来的两倍(注意是table长度,而不是<code>threshold</code>)     </li><li>④、如果数据很大的情况下,扩展时将会带来性能的损失,在性能要求很高的地方,这种损失很可能很致命。</li></ul><h2 id="7-HashMap中put方法的过程"><a href="#7-HashMap中put方法的过程" class="headerlink" title="7.HashMap中put方法的过程?"></a>7.HashMap中put方法的过程?</h2><ul><li><p>调用哈希函数获取<code>Key</code>对应的<code>hash</code>值,再计算其数组下标;     </p></li><li><p>如果没有出现哈希冲突,则直接放入数组;如果出现哈希冲突,则以链表的方式放在链表后面;     </p></li><li><p>如果链表长度超过阀值(<code>TREEIFYTHRESHOLD==8</code>),就把链表转成红黑树,链表长度低于6,就把红黑树转回链表;     </p></li><li><p>如果结点的<code>key</code>已经存在,则替换其<code>value</code>即可;     </p></li><li><p>如果集合中的键值对大于12,调用<code>resize</code>方法进行数组扩容。</p></li></ul><pre><code>![](https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200618150149962.png)     </code></pre><h2 id="8-数组扩容的过程"><a href="#8-数组扩容的过程" class="headerlink" title="8.数组扩容的过程?"></a>8.数组扩容的过程?</h2><p>创建一个新的数组,其容量为旧数组的两倍,并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种,原下标位置或原下标+旧数组的大小。 </p><p>什么时候才需要扩容？</p><p>当HashMap中的元素个数超过数组大小(数组长度)</p><ul><li><p>loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75&#x3D;12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。 </p><p>补充： </p><p>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，结点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的结点个数低于6，也会再把树转换为链表。 </p><p>HashMap的扩容是什么？</p></li></ul><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以结点要么就在原来的位置，要么就被分配到”原位置+旧容量”这个位置。    <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727194809948.png"> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727194830581.png"> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727194908184.png"> </p><h2 id="9-拉链法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树"><a href="#9-拉链法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树" class="headerlink" title="9.拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?"></a>9.拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?</h2><p>为什么不一直使用红黑树? </p><p>之所以选择红黑树是为了解决二叉查找树的缺陷,二叉查找树在特殊情况下会变成一条线性结构(这就跟原来使用链表结构一样了,造成很深的问题),遍历查找会非常慢。</p><p>而红黑树在插入新数据后可能需要通过左旋,右旋、变色这些操作来保持平衡,引入红黑树就是为了查找数据快,解决链表查询深度的问题,我们知道红黑树属于平衡二叉树,但是为了保持”平衡”是需要付出代价的,但是该代价所损耗的资源要比遍历线性链表要少,所以当长度大于8的时候,会使用红黑树,如果链表长度很短的话,根本不需要引入红黑树,引入反而会慢。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727195342649.png"> </p><h2 id="10-说说你对红黑树的见解"><a href="#10-说说你对红黑树的见解" class="headerlink" title="10.说说你对红黑树的见解?"></a>10.说说你对红黑树的见解?</h2><ul><li>1、每个节点非红即黑    </li><li>2、根节点总是黑色的     </li><li>3、如果节点是红色的,则它的子节点必须是黑色的(反之不一定)     </li><li>4、每个叶子节点都是黑色的空节点(NIL节点)     </li><li>5、从根节点到叶节点或空子节点的每条路径,必须包含相同数目的黑色节点(即相同的黑色高度)</li></ul><h2 id="11-jdk8中对HashMap做了哪些改变"><a href="#11-jdk8中对HashMap做了哪些改变" class="headerlink" title="11.jdk8中对HashMap做了哪些改变?"></a>11.jdk8中对HashMap做了哪些改变?</h2><ul><li>在<code>java1.8</code>中,如果链表的长度超过了8,那么链表将转换为红黑树。(桶的数量必须大于64,小于64的时候只会扩容) </li><li>发生<code>hash</code>碰撞时,<code>java1.7</code>会在链表的头部插入,而<code>java1.8</code>会在链表的尾部插入     </li><li>在<code>java1.8</code>中,<code>Entry</code>被<code>Node</code>替代(换了一个马甲)。</li></ul><h2 id="12-HashMap-LinkedHashMap-TreeMap有什么区别"><a href="#12-HashMap-LinkedHashMap-TreeMap有什么区别" class="headerlink" title="12.HashMap,LinkedHashMap,TreeMap有什么区别?"></a>12.HashMap,LinkedHashMap,TreeMap有什么区别?</h2><ul><li><code>HashMap</code>参考其他问题;     </li><li><pre><code> `LinkedHashMap`保存了记录的插入顺序,在用`Iterator`遍历时,先取到的记录肯定是先插入的;遍历比`HashMap`慢;     </code></pre></li><li><pre><code> `TreeMap`实现`SortMap`接口,能够把它保存的记录根据键排序(默认按键值升序排序,也可以指定排序的比较器)</code></pre></li></ul><h2 id="13-HashMap-amp-TreeMap-amp-LinkedHashMap使用场景"><a href="#13-HashMap-amp-TreeMap-amp-LinkedHashMap使用场景" class="headerlink" title="13.HashMap&amp;TreeMap&amp;LinkedHashMap使用场景?"></a>13.HashMap&amp;TreeMap&amp;LinkedHashMap使用场景?</h2><p>一般情况下,使用最多的是<code>HashMap</code>。  </p><p> <strong>HashMap:</strong> 在Map中插入、删除和定位元素时;  </p><p> <strong>TreeMap:</strong> 在需要按自然顺序或自定义顺序遍历键的情况下;   </p><p><strong>LinkedHashMap:</strong> 在需要输出的顺序和输入的顺序相同的情况下。</p><h2 id="14-HashMap和HashTable有什么区别"><a href="#14-HashMap和HashTable有什么区别" class="headerlink" title="14.HashMap和HashTable有什么区别?"></a>14.HashMap和HashTable有什么区别?</h2><ul><li>①、<code>HashMap</code>是线程不安全的,<code>HashTable</code>是线程安全的;     </li><li>②、由于线程安全,所以<code>HashTable</code>的效率比不上<code>HashMap</code>;     </li><li>③、<code>HashMap</code>最多只允许一条记录的键为<code>null</code>,允许多条记录的值为<code>null</code>,而<code>HashTable</code>不允许;     </li><li>④、<code>HashMap</code>默认初始化数组的大小为16,<code>HashTable</code>为11,前者扩容时,扩大两倍,后者扩大两倍+1;     </li><li>⑤、<code>HashMap</code>需要重新计算hash值,而<code>HashTable</code>直接使用对象的<code>hashCode</code>;</li></ul><h2 id="15-HashMap-的底层数组长度为何总是2的n次方-？"><a href="#15-HashMap-的底层数组长度为何总是2的n次方-？" class="headerlink" title="15.HashMap 的底层数组长度为何总是2的n次方 ？"></a>15.HashMap 的底层数组长度为何总是2的n次方 ？</h2><p><strong>HashMap</strong>根据用户传入的初始化容量，利用无符号右移和按位或运算等方式计算出第一个大于该数的2的幂。 </p><blockquote><ul><li>使数据分布均匀，减少碰撞</li><li>当length为2的n次方时，h&amp;(length - 1) 就相当于对length取模，而且在速度、效率上比直接取模要快得多</li></ul></blockquote><h3 id="jdk1-8中做了哪些优化优化？"><a href="#jdk1-8中做了哪些优化优化？" class="headerlink" title="jdk1.8中做了哪些优化优化？"></a>jdk1.8中做了哪些优化优化？</h3><ol><li>数组+链表改成了数组+链表或红黑树 </li><li>链表的插入方式从头插法改成了尾插法 </li><li>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小； </li><li>在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；</li></ol><h3 id="HashMap线程安全方面会出现什么问题"><a href="#HashMap线程安全方面会出现什么问题" class="headerlink" title="HashMap线程安全方面会出现什么问题 *"></a><strong><code>HashMap线程安全方面会出现什么问题</code></strong> *</h3><p>在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。</p><ul><li>在jdk1.8中，在多线程环境下，会发生数据覆盖的情况</li></ul><h3 id="为什么HashMap的底层数组长度为何总是2的n次方"><a href="#为什么HashMap的底层数组长度为何总是2的n次方" class="headerlink" title="为什么HashMap的底层数组长度为何总是2的n次方"></a>为什么HashMap的底层数组长度为何总是2的n次方</h3><p>   这里我觉得可以用逆向思维来解释这个问题，我们计算桶的位置完全可以使用<code>h % length</code>，如果这个length是随便设定值的话当然也可以，但是如果你对它进行研究，设计一个合理的值得话，那么将对HashMap的性能发生翻天覆地的变化。 </p><p>没错，JDK源码作者就发现了，那就是当length为2的N次方的时候，那么，为什么这么说呢？ </p><p><strong>第一：当length为2的N次方的时候，h &amp; (length-1) &#x3D; h % length</strong>   </p><p>为什么&amp;效率更高呢？因为位运算直接对内存数据进行操作，不需要转成十进制，所以位运算要比取模运算的效率更高 </p><p><strong>第二：当length为2的N次方的时候，数据分布均匀，减少冲突</strong>    </p><h3 id="那么为什么默认是16呢？怎么不是4？不是8？"><a href="#那么为什么默认是16呢？怎么不是4？不是8？" class="headerlink" title="那么为什么默认是16呢？怎么不是4？不是8？"></a>那么为什么默认是16呢？怎么不是4？不是8？</h3><p> 关于这个默认容量的选择，JDK并没有给出官方解释，那么这应该就是个经验值，既然一定要设置一个默认的2^n 作为初始值，那么就需要在效率和内存使用上做一个权衡。这个值既不能太小，也不能太大。 太小了就有可能频繁发生扩容，影响效率。太大了又浪费空间，不划算。 所以，16就作为一个经验值被采用了。 <strong>在JDK1.8的 236 行有1&lt;&lt;4就是16</strong>，为啥用位运算呢？直接写16不好么？ <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBscWZlZzFwajMxNzQwNTRqc2IuanBn"> 我们在创建HashMap的时候，阿里巴巴规范插件会提醒我们最好赋初值，而且最好是2的幂。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBsdW96MTBuajMwcHkwNTJnbWEuanBn"> 这样是为了位运算的方便，<strong>位与运算比算数计算的效率高了很多</strong>，之所以选择16，是为了服务将Key映射到index的算法。 我前面说了所有的key我们都会拿到他的hash，但是我们怎么尽可能的得到一个均匀分布的hash呢？ 是的我们通过Key的HashCode值去做位运算。 我们再看下index的计算公式：index &#x3D; HashCode（Key） &amp; （Length- 1）   15的的二进制是1111，那10111011000010110100 &amp;1111 十进制就是4 之所以用位与运算效果与取模一样，性能也提高了不少！ 那为啥用16不用别的呢？ 因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。 只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了实现均匀分布。 当length为奇数时，length-1为偶数，而偶数二进制的最后一位永远为0，那么与其进行 &amp; 运算，得到的二进制数最后一位永远为0，那么结果一定是偶数，那么就会导致下标为奇数的桶永远不会放置数据，这就不符合我们均匀放置，减少冲突的要求了。 那么可能钻牛角尖的同学还会问，那length是偶数不就行了么，为什么一定要是2的N次方，这不就又回到第一点原因了么？（<strong>当length为2的N次方的时候，h &amp; (length-1) &#x3D; h % length</strong>）</p><p>JDK 的工程师把各种位运算运用到了极致，想尽各种办法优化效率。</p><h3 id="HashMap的不安全体现在哪里？"><a href="#HashMap的不安全体现在哪里？" class="headerlink" title="HashMap的不安全体现在哪里？"></a>HashMap的不安全体现在哪里？</h3><p>hashMap是<strong>线程不安全</strong>的，其主要体现：</p><blockquote><p>1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。 </p><p> 2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。 现在我们要在容量为2的容器里面<strong>用不同线程</strong>插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。 我们可以看到链表的指向A-&gt;B-&gt;C <strong>Tip：A的下一个指针是指向B的</strong> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBrYXhnZzVpajMwNTAwN29kZnIuanBn"> </p><p>因为resize的赋值方式，也就是使用了<strong>单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</strong>，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 就可能出现下面的情况，大家发现问题没有？ B的下一个指针指向了A 一旦几个线程都调整完成，就可能出现环形链表 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBraDhvbWp5ajMwYWwwNnBteDQuanBn"> </p><p>如果这个时候去取值，悲剧就出现了——Infinite Loop。 jdk1.8中HashMap中put操作的主函数，如果没有hash碰撞则会直接插入元素。如果线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入第6行代码中。假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给<strong>覆盖</strong>，发生线程不安全。 </p><p>更多请参考：<a href="https://www.cnblogs.com/developer_chan/p/10450908.html">https://www.cnblogs.com/developer_chan&#x2F;p&#x2F;10450908.html</a> </p></blockquote><h3 id="为什么JDK1-8使用红黑树？"><a href="#为什么JDK1-8使用红黑树？" class="headerlink" title="为什么JDK1.8使用红黑树？"></a><strong>为什么JDK1.8使用红黑树？</strong></h3><p>   比如某些人通过找到你的hash碰撞值，来让你的HashMap不断地产生碰撞，那么相同key位置的链表就会不断增长，当你需要对这个HashMap的相应位置进行查询的时候，就会去循环遍历这个超级大的链表，性能及其低下。</p><p>java8使用红黑树来替代超过8个节点数的链表后，查询方式性能得到了很好的提升，从原来的是O(n)到O(logn)。    </p><h3 id="1-8中的扩容为什么逻辑判断更简单"><a href="#1-8中的扩容为什么逻辑判断更简单" class="headerlink" title="1.8中的扩容为什么逻辑判断更简单"></a>1.8中的扩容为什么逻辑判断更简单</h3><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200618150837955.png"> 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200618150847782.png"> 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。 </p><h3 id="HashMap中容量的初始化"><a href="#HashMap中容量的初始化" class="headerlink" title="HashMap中容量的初始化"></a><strong>HashMap中容量的初始化</strong></h3><p> 当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？ 关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议： <img src="https://img-blog.csdnimg.cn/20200628232950242.png#pic_center" alt="建议"> 也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 &#x3D; 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727200145905.png"> <img src="https://img-blog.csdnimg.cn/20200727200218332.png"> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727200354118.png"> 如果我们通过<code>initialCapacity/ 0.75F + 1.0F</code>计算，<code>7/0.75 + 1 = 10</code> ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。 当<code>HashMap</code>内部维护的哈希表的容量达到75%时（默认情况下），会触发<code>rehash</code>，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<code>initialCapacity/0.75 + 1</code>的话，可以有效的减少冲突也可以减小误差。</p><p> 所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成initialCapacity&#x2F; 0.75F + 1.0F是一个在性能上相对好的选择，但是，同时也会牺牲些内存。 我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。 但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。 但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成initialCapacity&#x2F; 0.75F + 1.0F。 </p><h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p> 当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。 </p><h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p> 答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p><p> <a href="https://blog.csdn.net/QGhurt/article/details/107323702?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&utm_relevant_index=1">什么是哈希</a>什么是哈希？</p><p> <strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）</strong>；</p><p>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。</p><p><strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。 所有散列函数都有如下一个基本特性**：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同**。</p><p> <a href="https://blog.csdn.net/QGhurt/article/details/107323702?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&utm_relevant_index=1">什么是哈希冲突？</a> </p><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p><p><strong>HashMap的数据结构</strong> </p><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。</p><p>**数组的特点是：寻址容易，插入和删除困难；</p><p><strong>链表的特点是：寻址困难，但插入和删除容易</strong>；</p><p>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n" alt="img"> 这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化 </p><p><strong>hash()函数</strong> </p><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下： <code>static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或） &#125;</code> 这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p><p> 通过上面的<strong>链地址法（使用散列表）</strong>和<strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)； </p><p>总结 简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的： </p><blockquote><p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong></p><p><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong>   </p><p> <strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong> </p></blockquote><h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置； </p><p><strong>那怎么解决呢？</strong> </p><ol><li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均； </li><li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol><h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><p> 为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。 </p><p><strong>这个算法应该如何设计呢？</strong></p><p> 我们首先可能会想到采用%取余的操作来实现。</p><p>但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” </p><p>并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p> <strong>那为什么是两次扰动呢？</strong></p><p> 答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><p> ConcurrentHashMap篇 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h3 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。） </li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h3 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； </p></li><li><p><strong>实现线程安全的方式（重要）</strong>：</p><p> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 <strong>两者的对比图</strong>： </p><p>HashTable: <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY" alt="img"> </p><p>JDK1.7的ConcurrentHashMap： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ" alt="img"> JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk" alt="img"> 答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p></li></ul><h3 id="ConcurrentHashMap-底层具体实现知道吗？"><a href="#ConcurrentHashMap-底层具体实现知道吗？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？"></a>ConcurrentHashMap 底层具体实现知道吗？</h3><p>实现原理是什么？</p><p> <strong>JDK1.7</strong> 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。 </p><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，</p><p>结构如下： </p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTY0NTgzNmU3MjJjMmE5ZjkucG5n" alt="img"> 1.  该类包含两个静态内部类 HashEntry 和 Segment ；</p><p>前者用来封装映射表的键值对，后者用来充当锁的角色； </p><ol start="2"><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol><p> <strong>JDK1.8</strong> 在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。 结构如下： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWVjODU2MDM5NWUyNTU0N2EucG5n" alt="img"> <strong>附加源码，有需要的可以看看</strong> 插入元素过程（建议去看看源码）： 如果相应位置的Node还没有初始化，则调用CAS插入相应的数据； </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))        <span class="keyword">break</span>; <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点； </span></span><br><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    </span><br><span class="line">    binCount = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek; </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||(ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123; </span><br><span class="line">            oldVal = e.val; </span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;       </span><br><span class="line">        &#125;        </span><br><span class="line">        Node&lt;K,V&gt; pred = e;        </span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123; </span><br><span class="line">            pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值； </li><li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li></ol><h2 id="15-Java中的另一个线程安全的与HashMap极其类似的类是什么"><a href="#15-Java中的另一个线程安全的与HashMap极其类似的类是什么" class="headerlink" title="15.Java中的另一个线程安全的与HashMap极其类似的类是什么?"></a>15.Java中的另一个线程安全的与HashMap极其类似的类是什么?</h2><h3 id="同样是线程安全-它与HashTable在线程同步上有什么不同"><a href="#同样是线程安全-它与HashTable在线程同步上有什么不同" class="headerlink" title="同样是线程安全,它与HashTable在线程同步上有什么不同?"></a>同样是线程安全,它与HashTable在线程同步上有什么不同?</h3><p> <code>ConcurrentHashMap</code>类(是<code>Java</code>并发包<code>java.util.concurrent</code>中提供的一个线程安全且高效的<code>HashMap</code>实现)。</p><p>   <code>HashTable</code>是使用<code>synchronize</code>关键字加锁的原理(就是对对象加锁);  </p><p> 而针对<code>ConcurrentHashMap</code>,在<code>JDK1.7</code>中采用分段锁的方式;</p><p><code>JDK1.8</code>中直接采用了**<code>CAS</code>(无锁算法)+<code>synchronized</code>**。 </p><h2 id="16-HashMap-amp-ConcurrentHashMap的区别"><a href="#16-HashMap-amp-ConcurrentHashMap的区别" class="headerlink" title="16.HashMap&amp;ConcurrentHashMap的区别?"></a>16.HashMap&amp;ConcurrentHashMap的区别?</h2><p>除了加锁,原理上无太大区别。</p><p>另外,<code>HashMap</code>的键值对允许有<code>null</code>,但是<code>ConCurrentHashMap</code>都不允许。</p><h2 id="17-为什么ConcurrentHashMap比HashTable效率要高"><a href="#17-为什么ConcurrentHashMap比HashTable效率要高" class="headerlink" title="17.为什么ConcurrentHashMap比HashTable效率要高?"></a>17.为什么ConcurrentHashMap比HashTable效率要高?</h2><p> <code>HashTable</code>使用一把锁(锁住整个链表结构)处理并发问题,多个线程竞争一把锁,容易阻塞;   <code>ConcurrentHashMap</code> </p><ul><li><code>JDK1.7</code>中使用分段锁(<code>ReentrantLock</code>+<code>Segment</code>+<code>HashEntry</code>),相当于把一个<code>HashMap</code>分成多个段,每段分配一把锁,这样支持多线程访问。锁粒度:基于<code>Segment</code>,包含多个<code>HashEntry</code>。    </li><li><code>JDK1.8</code>中使用<code>CAS</code>+<code>synchronized</code>+<code>Node</code>+红黑树。锁粒度:<code>Node</code>(首结点)(实现<code>Map.Entry&lt;K,V&gt;</code>)。锁粒度降低了。</li></ul><h2 id="18-针对ConcurrentHashMap锁机制具体分析-JDK1-7VSJDK1-8"><a href="#18-针对ConcurrentHashMap锁机制具体分析-JDK1-7VSJDK1-8" class="headerlink" title="18.针对ConcurrentHashMap锁机制具体分析(JDK1.7VSJDK1.8)?"></a>18.针对ConcurrentHashMap锁机制具体分析(JDK1.7VSJDK1.8)?</h2><p> <code>JDK1.7</code>中,采用分段锁的机制,实现并发的更新操作,底层采用数组+链表的存储结构,包括两个核心静态内部类<code>Segment</code>和<code>HashEntry</code>。 *   ①、<code>Segment</code>继承<code>ReentrantLock</code>(重入锁)用来充当锁的角色,每个<code>Segment</code>对象守护每个散列映射表的若干个桶;     *   ②、<code>HashEntry</code>用来封装映射表的键-值对;     *   ③、每个桶是由若干个<code>HashEntry</code>对象链接起来的链表;     <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9GYjYwTklvVFl6YTF4UTdpYk5lSnVWR01nR0g5eEJWVkh0UWdNenZzamR1akdXdFo0Y25pYXFyenhxRWoxR1RHbWRnb05VWjhGbDFnQ2x6S2VSM0lGT2ljZy82NDA"> <code>JDK1.8</code>中,采用<code>Node</code>+<code>CAS</code>+<code>Synchronized</code>来保证并发安全。取消类<code>Segment</code>,直接用<code>table</code>数组存储键值对;当<code>HashEntry</code>对象组成的链表长度超过<code>TREEIFY_THRESHOLD</code>时,链表转换为红黑树,提升性能。底层变更为数组+链表+红黑树。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9GYjYwTklvVFl6YTF4UTdpYk5lSnVWR01nR0g5eEJWVkhnY2pWaWNoN2FvQ3FVRGdvb1lLSzVNZG03V3JLOURMZEdPVllNeWo4Zm5GNktiNXI4TVlWR3lRLzY0MA"> </p><h3 id="19-ConcurrentHashMap在JDK1-8中-为什么要使用内置锁synchronized来代替重入锁ReentrantLock"><a href="#19-ConcurrentHashMap在JDK1-8中-为什么要使用内置锁synchronized来代替重入锁ReentrantLock" class="headerlink" title="19.ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?"></a>19.ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?</h3><ul><li>①、粒度降低了;     </li><li><pre><code>②、`JVM`开发团队没有放弃`synchronized`,而且基于`JVM`的`synchronized`优化空间更大,更加自然。     </code></pre></li><li>③、在大量的数据操作下,对于<code>JVM</code>的内存压力,基于<code>API</code>的<code>ReentrantLock</code>会开销更多的内存。</li></ul><h3 id="20-ConcurrentHashMap简单介绍"><a href="#20-ConcurrentHashMap简单介绍" class="headerlink" title="20.ConcurrentHashMap简单介绍?"></a>20.ConcurrentHashMap简单介绍?</h3><ul><li><p>①、重要的常量:<br><code>private transient volatile intsizeCtl</code>;<br>当为负数时,-1表示正在初始化,-N表示N-1个线程正在进行扩容;  </p><p>当为0时,表示<code>table</code>还没有初始化;            </p><p>当为其他正数时,表示初始化或者下一次进行扩容的大小。        </p></li><li><p>②、数据结构:<br>  <code>Node</code>是存储结构的基本单元,继承<code>HashMap</code>中的<code>Entry</code>,用于存储数据;            <code>TreeNode</code>继承<code>Node</code>,但是数据结构换成了二叉树结构,是红黑树的存储结构,用于红黑树中存储数据;<br><code>TreeBin</code>是封装<code>TreeNode</code>的容器,提供转换红黑树的一些条件和锁的控制。         </p></li><li><p>③、存储对象时(<code>put()</code>方法):        </p><ul><li>1.如果没有初始化,就调用<code>initTable()</code>方法来进行初始化;           </li><li>2.如果没有<code>hash</code>冲突就直接<code>CAS</code>无锁插入;            </li><li>3.如果需要扩容,就先进行扩容;         </li><li>4.如果存在<code>hash</code>冲突,就加锁来保证线程安全,两种情况:一种是链表形式就直接遍历到尾端插入,一种是红黑树就按照红黑树结构插入;            </li><li>5.如果该链表的数量大于阀值8,就要先转换成红黑树的结构,<code>break</code>再一次进入循环            </li><li>6.如果添加成功就调用<code>addCount()</code>方法统计<code>size</code>,并且检查是否需要扩容。</li></ul></li><li><p>④、<strong>扩容方法<code>transfer()</code>:</strong> 默认容量为16,扩容时,容量变为原来的两倍。      <strong><code>helpTransfer()</code>:</strong> 调用多个工作线程一起帮助进行扩容,这样的效率就会更高。     </p></li><li><p>⑤、获取对象时(<code>get()</code>方法):        </p></li><li><p>1.计算hash值,定位到该<code>table</code>索引位置,如果是首结点符合就返回;            </p></li><li><p>2.如果遇到扩容时,会调用标记正在扩容结点<code>ForwardingNode.find()</code>方法,查找该结点,匹配就返回;           </p></li><li><p>3.以上都不符合的话,就往下遍历结点,匹配就返回,否则最后就返回<code>null</code></p></li></ul><h3 id="21-ConcurrentHashMap的并发度是什么"><a href="#21-ConcurrentHashMap的并发度是什么" class="headerlink" title="21.ConcurrentHashMap的并发度是什么?"></a>21.ConcurrentHashMap的并发度是什么?</h3><p> 程序运行时能够同时更新<code>ConccurentHashMap</code>且不产生锁竞争的最大线程数。</p><p>默认为16,且可以在构造函数中设置。当用户设置并发度时,<code>ConcurrentHashMap</code>会使用大于等于该值的最小2幂指数作为实际并发度(假如用户设置并发度为17,实际并发度则为32) </p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt; &lt;a href=&quot;about:blank#1.HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%3F&quot;&gt;1.HashMap的数据结构?&lt;/a&gt; &lt;a href=&quot;about:bl</summary>
      
    
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="HashMap" scheme="https://lyotoc.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>位运算之——按位与（&amp;）操作——（快速取模算法）</title>
    <link href="https://lyotoc.github.io/2022/09/01/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%88&amp;%EF%BC%89%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%EF%BC%88%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>https://lyotoc.github.io/2022/09/01/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%88&amp;%EF%BC%89%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%EF%BC%88%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1%E7%AE%97%E6%B3%95%EF%BC%89/</id>
    <published>2022-09-01T08:09:06.000Z</published>
    <updated>2022-09-01T10:35:07.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算之——按位与（-amp-）操作——（快速取模算法）"><a href="#位运算之——按位与（-amp-）操作——（快速取模算法）" class="headerlink" title="位运算之——按位与（&amp;）操作——（快速取模算法）"></a>位运算之——按位与（&amp;）操作——（快速取模算法）</h1><p>由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</p><p>按位与（Bitwise AND），运算符号为&amp;</p><p>a&amp;b 的操作的结果：a、b中对应位同时为1，则对应结果位也为1、</p><p>例如：</p><p><strong>10010001101000101011001111000</strong></p><p><strong>&amp; 111111100000000</strong></p><p><strong>———————————————</strong></p><p><strong>10101100000000</strong></p><p><strong>对10101100000000<strong><strong>进行右移8</strong></strong>位得到的是101011<strong><strong>，这就得到了a</strong></strong>的8~15****位的掩码了。</strong>那么根据这个启示，判断一个整数是否是处于 0-65535 之间（常用的越界判断）：</p><p>用一般的 (a &gt;&#x3D; 0) &amp;&amp; (a &lt;&#x3D; 65535) 可能要两次判断。</p><p>改用位运算只要一次：</p><p>a &amp; ~((1&lt;&lt; 16)-1)</p><p>后面的常数是编译时就算好了的。其实只要算一次逻辑与就行了。</p><p><strong>常用技巧：</strong></p><p>1、 用于整数的奇偶性判断</p><p>一个整数a, a &amp; 1 这个表达式可以用来判断a的奇偶性。二进制的末位为0表示偶数，最末位为1表示奇数。使用a%2来判断奇偶性和a &amp; 1是一样的作用，但是a &amp; 1要快好多。</p><p>2、 判断n是否是2的正整数冪</p><p><strong>(!(n&amp;(n-1)) )&amp;&amp; n</strong></p><p>举个例子：</p><p>如果n &#x3D; 16 &#x3D; 10000， n-1 &#x3D; 1111</p><p>那么：</p><p><strong>10000</strong></p><p><strong>&amp; 1111</strong></p><p><strong>———-</strong></p><p>​      <strong>0</strong></p><p>再举一个例子：如果n &#x3D; 256 &#x3D; 100000000， n-1 &#x3D; 11111111</p><p>那么：</p><p><strong>100000000</strong></p><p><strong>&amp;11111111</strong></p><p><strong>————–</strong></p><p><strong>0</strong></p><p>好！看完上面的两个小例子，相信大家都有一个感性的认识。从理论上讲，如果一个数a他是2的正整数幂，那么a 的二进制形式必定为1000…..（后面有0个或者多个0），那么结论就很显然了。</p><p>3、 统计n中1的个数</p><p>朴素的统计办法是：先判断n的奇偶性，为奇数时计数器增加1，然后将n右移一位，重复上面步骤，直到移位完毕。</p><p>朴素的统计办法是比较简单的，那么我们来看看比较高级的办法。</p><p>举例说明，考虑2位整数 n&#x3D;11，里边有2个1，先提取里边的偶数位10，奇数位01，把偶数位右移1位，然后与奇数位相加，因为每对奇偶位相加的和不会超过“两位”，所以结果中每两位保存着数n中1的个数；相应的如果n是四位整数 n&#x3D;0111，先以“一位”为单位做奇偶位提取，然后偶数位移位（右移1位），相加；再以“两位”为单位做奇偶提取，偶数位移位（这时就需要移2位），相加，因为此时没对奇偶位的和不会超过“四位”，所以结果中保存着n中1的个数，依次类推可以得出更多位n的算法。整个思想类似分治法。<br>在这里就顺便说一下常用的二进制数：</p><p>0xAAAAAAAA&#x3D;10101010101010101010101010101010</p><p>0x55555555 &#x3D; 1010101010101010101010101010101（奇数位为1，以1位为单位提取奇偶位）</p><p>0xCCCCCCCC &#x3D; 11001100110011001100110011001100</p><p>0x33333333 &#x3D; 110011001100110011001100110011（以“2位”为单位提取奇偶位）</p><p>0xF0F0F0F0 &#x3D; 11110000111100001111000011110000</p><p>0x0F0F0F0F &#x3D; 1111000011110000111100001111（以“8位”为单位提取奇偶位）</p><p>0xFFFF0000 &#x3D;11111111111111110000000000000000</p><p>0x0000FFFF &#x3D; 1111111111111111（以“16位”为单位提取奇偶位）</p><p>例如：32位无符号数的1的个数可以这样数：</p><p>int count_one(unsigned long n)<br>{<br>&#x2F;&#x2F;0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位<br>n &#x3D; ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555);</p><p>&#x2F;&#x2F;0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位<br>n &#x3D; ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333);</p><p>&#x2F;&#x2F;0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位<br>n &#x3D; ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F);</p><p>&#x2F;&#x2F;0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位<br>n &#x3D; ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF);</p><p>&#x2F;&#x2F;0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位<br>n &#x3D; ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF);</p><p>return n;<br>}</p><p>举个例子吧，比如说我的生日是农历2月11，就用211吧，转成二进制：</p><p>n &#x3D; 11010011</p><p>计算n &#x3D; ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555);</p><p>得到 n &#x3D; 10010010</p><p>计算n &#x3D; ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333);</p><p>得到 n &#x3D; 00110010</p><p>计算n &#x3D; ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F);</p><p>得到 n &#x3D; 00000101 —————–à无法再分了，那么5就是答案了。</p><p>4、对于正整数的模运算（注意，负数不能这么算）</p><p>先说下比较简单的：</p><p>乘除法是很消耗时间的，只要对数左移一位就是乘以2，右移一位就是除以2，传说用位运算效率提高了60%。</p><p>乘2^k众所周知： n&lt;&lt;k。所以你以后还会傻傻地去敲2566*4的结果10264吗？直接2566&lt;&lt;4就搞定了，又快又准确。</p><p>除2^k众所周知： n&gt;&gt;k。</p><p>那么 mod 2^k 呢？（对2的倍数取模）</p><p><strong>n&amp;((1&lt;&lt;k)-1)</strong></p><p>用通俗的言语来描述就是,对2的倍数取模，只要将数与2的倍数-1做按位与运算即可。</p><p>好！方便理解就举个例子吧。</p><p>思考：如果结果是要求模2^k时，我们真的需要每次都取模吗？</p><p>在此很容易让人想到快速幂取模法。</p><p><strong>快速幂取模算法</strong></p><p>经常做题目的时候会遇到要计算 a^b mod c 的情况，这时候，一个不小心就TLE了。那么如何解决这个问题呢？位运算来帮你吧。</p><p>首先介绍一下秦九韶算法：(数值分析讲得很清楚)</p><p>把一个n次多项式f(x) &#x3D; a[n]x^n+a[n-1]x^(n-1)+……+a[1]x+a[0]改写成如下形式：</p><p>　　f(x) &#x3D; a[n]x^n+a[n-1]x^(n-1))+……+a[1]x+a[0]</p><p>　　&#x3D; (a[n]x^(n-1)+a[n-1]x^(n-2)+……+a[1])x+a[0]</p><p>　　&#x3D; ((a[n]x^(n-2)+a[n-1]x^(n-3)+……+a[2])x+a[1])x+a[0]</p><p>　　&#x3D;. …..</p><p>　　&#x3D; (……((a[n]x+a[n-1])x+a[n-2])x+……+a[1])x+a[0].</p><p>　　求多项式的值时，首先计算最内层括号内一次多项式的值，即</p><p>　　v[1]&#x3D;a[n]x+a[n-1]</p><p>　　然后由内向外逐层计算一次多项式的值，即</p><p>　　v[2]&#x3D;v[1]x+a[n-2]</p><p>　　v[3]&#x3D;v[2]x+a[n-3]</p><p>　　……</p><p>　　v[n]&#x3D;v[n-1]x+a[0]</p><p>这样，求n次多项式f(x)的值就转化为求n个一次多项式的值。</p><p>好！有了前面的基础知识，我们开始解决问题吧</p><p>由(a ×b) mod c&#x3D;( (a mod c) × b) mod c.</p><p>我们可以将 b先表示成就：</p><p>b &#x3D; a[t] × 2^t + a[t-1]× 2^(t-1) + …… + a[0] × 2^0. (a[i]&#x3D;[0,1]).</p><p>这样我们由 a^b mod c &#x3D; (a^(a[t] × 2^t + a[t-1]× 2^（t-1） + …a[0] × 2^0) mod c.</p><p>然而我们求 a^( 2^(i+1) ) mod c&#x3D;( (a^(2^i)) mod c)^2 mod c .求得。</p><p>具体实现如下：</p><p>使用秦九韶算法思想进行快速幂模算法，简洁漂亮</p><p>&#x2F;&#x2F; 快速计算 (a ^ p) % m 的值<br>__int64 FastM(__int64 a, __int64 p, __int64 m)<br>{<br>if (p &#x3D;&#x3D; 0) return 1;<br>__int64 r &#x3D; a % m;<br>__int64 k &#x3D; 1;<br>while (p &gt; 1)<br>{<br>if ((p &amp; 1)!&#x3D;0)<br>{<br>k &#x3D; (k * r) % m;<br>}<br>r &#x3D; (r * r) % m;<br>p &gt;&gt;&#x3D; 1;<br>}<br>return (r * k) % m;<br>}</p><p><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3070">http://acm.pku.edu.cn/JudgeOnline/problem?id=3070</a></p><p>5、计算掩码</p><p>比如一个截取低6位的掩码：0×3F<br>用位运算这么表示：(1&lt;&lt; 6) - 1<br>这样也非常好读取掩码，因为掩码的位数直接体现在表达式里。</p><p>按位或运算很简单，只要a和b中相应位出现1，那么a|b的结果相应位也为1。就不多说了。</p><p>6、子集</p><p>　　枚举出一个集合的子集。设原集合为mask，则下面的代码就可以列出它的所有子集：</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算之——按位与（-amp-）操作——（快速取模算法）&quot;&gt;&lt;a href=&quot;#位运算之——按位与（-amp-）操作——（快速取模算法）&quot; class=&quot;headerlink&quot; title=&quot;位运算之——按位与（&amp;amp;）操作——（快速取模算法）&quot;&gt;&lt;/a&gt;位运</summary>
      
    
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://lyotoc.github.io/2022/08/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://lyotoc.github.io/2022/08/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-08-26T10:53:45.000Z</published>
    <updated>2022-08-26T10:56:00.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Q：为什么要使用线程池？<br>使用线程池能便于管理线程，通过线程池可实现线程的复用，降低创建与销毁线程所带来的资源消耗，并且因为无需任务到达才创建线程，线程能立即执行任务，提高了响应速度。</p><h4 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h4><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程大小。线程池一直运行，核心线程就不会停止。</td></tr><tr><td>maximumPoolSize</td><td>线程池最大线程数量。非核心线程数量&#x3D;maximumPoolSize - corePoolSize</td></tr><tr><td>keepAliveTime</td><td>非核心线程的心跳时间。如果非核心线程在keepAliveTime内没有运行任务，非核心线程会消亡。</td></tr><tr><td>workQueue</td><td>阻塞队列。ArrayBlokingQueue，LinkedBolckingQueue等，用来存放线程任务。</td></tr><tr><td>defaultHandler</td><td>饱和策略。ThreadPoolExecutor类中有4种饱和策略。通过实现RejectedExecutionHandler接口。</td></tr><tr><td>ThreadFactory</td><td>线程工厂</td></tr></tbody></table><h4 id="线程池执行任务流程"><a href="#线程池执行任务流程" class="headerlink" title="线程池执行任务流程"></a>线程池执行任务流程</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1661045000569-c58850e4-dfa9-4203-bf5f-d54dd3f92ffe.png"></p><h2 id="Java线程池的类型"><a href="#Java线程池的类型" class="headerlink" title="Java线程池的类型"></a>Java线程池的类型</h2><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若需执行任务时无可回收线程，则新建线程；<br>特点：</p><ol><li>灵活性强，工作线程创建数量几乎没有限制（最大为最大整型数）;</li><li>动态调整线程数，在长时间没有往线程池中提交任务时（工作线程的空闲时间超出指定时间，默认为一分钟），则将该工作线程自动终止。终止后，若后续有新的任务，则线程池重新创建一个工作线程。</li><li>需要注意的是，因为在创建线程数量上没做限制，在使用CachedThreadPool时需要注意控制任务的数量，否则大量线程运行容易导致OOM。</li></ol><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>FixedhreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建时间所消耗的开销的优点。但是在线程池空闲时，即线程池中没有可运行的任务时，它不会释放工作线程，还会占用一定的系统资源。</p><h3 id="newSingleThreadExector"><a href="#newSingleThreadExector" class="headerlink" title="newSingleThreadExector"></a>newSingleThreadExector</h3><p>创建一个单线程的Executor，即只创建唯一的工作者来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序来执行(FIFO,LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单线程最大的特点就是可保证顺序执行各个任务，并且在任意给定时间不会有多个线程活动。</p><h3 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h3><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行。</p><h2 id="线程池常用的阻塞队列"><a href="#线程池常用的阻塞队列" class="headerlink" title="线程池常用的阻塞队列"></a>线程池常用的阻塞队列</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1661047097008-7e43d577-306a-4d05-b4ca-5465d8e4724a.png" alt="image.png"></p><ol><li>LinkedBlockingQueue对于FixedThreadPool和SingleThreadExector而言，他们使用的阻塞队列是容量为Integer.MAX_VALUE的LinkedBlockingQueue,可以认为是无界队列。由于FixedThreadPool线程池的线程数量是固定的，所以没有办法增加特别多的线程来处理任务，这就需要LinkedBlockingQueue这样一个没有容量限制的阻塞队列来存放任务。<br>这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</li><li>第二种阻塞队列是SynchronousQueue，对应的线程池是CacheThreadPool。线程池CacheThreadPool的最大线程数是Integer.MAX_VALUE,即线程数是可以无限扩展的。CacheThreadPool和FixedThreadPool相比恰恰相反，FixedThreadPool的情况是阻塞队列的容量是无限的，而这里CacheThreadPool是线程数是无限扩展的，所以CacheThreadPool线程池并不需要一个任务队列来存储任务，因为一旦有任务提交就直接转发给线程或者创建一个新的线程执行任务，而不需要另外保存它们。我们自己创建使用的SynchronousQueue的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能要大一点，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行。</li><li>DelayedWorkQueue ，它对应的线程池分别是ScheduledThreadPool和SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定时间执行一次任务。<br>DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</li></ol><h2 id="ThreadPoolExecutor创建线程池"><a href="#ThreadPoolExecutor创建线程池" class="headerlink" title="ThreadPoolExecutor创建线程池"></a>ThreadPoolExecutor创建线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadPoolExecutor构造函数重要参数分析</span></span><br><span class="line"><span class="comment">// ThreadPoolExecutor 3 个最重要的参数：</span></span><br><span class="line"><span class="comment">// ● corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</span></span><br><span class="line"><span class="comment">// ● maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</span></span><br><span class="line"><span class="comment">// ● workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</span></span><br><span class="line"><span class="comment">// ThreadPoolExecutor其他4个参数:</span></span><br><span class="line"><span class="comment">// ● keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</span></span><br><span class="line"><span class="comment">// ● unit : keepAliveTime 参数的时间单位。</span></span><br><span class="line"><span class="comment">// ● threadFactory :executor 创建新线程的时候会用到。</span></span><br><span class="line"><span class="comment">// ● handler :饱和策略。关于饱和策略下面单独介绍一下。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h2&gt;&lt;p&gt;Q：为什么要使用线程池？&lt;br&gt;使用线程池能便于管理线程，通过线程池可实现线程的复用，降低创建与销毁线程所带来的资源消耗，并且因为无</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="线程并发" scheme="https://lyotoc.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="https://lyotoc.github.io/2022/08/26/AQS/"/>
    <id>https://lyotoc.github.io/2022/08/26/AQS/</id>
    <published>2022-08-26T10:51:02.000Z</published>
    <updated>2022-08-26T10:53:15.174Z</updated>
    
    <content type="html"><![CDATA[<p>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655214807962-b2ed2591-604b-43ce-b79d-02240d84b4f1.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=fBbv5&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655214807962-b2ed2591-604b-43ce-b79d-02240d84b4f1.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=fBbv5&amp;margin=[object</a> Object]&amp;originHeight&#x3D;993&amp;originWidth&#x3D;537&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><h1 id="AQS是JUC内容中最重要的基石"><a href="#AQS是JUC内容中最重要的基石" class="headerlink" title="AQS是JUC内容中最重要的基石"></a>AQS是JUC内容中最重要的基石</h1><blockquote><p>AQS是JUC内容中最重要的基石，主要用于解决锁分配给谁的问题</p></blockquote><p>熟知的<strong>ReentrantLock|CountDownLatch|ReentrantReadWriteLock|Semaphore</strong>都是基于AQS实现的<br>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655216213245-10d6b92a-8068-419a-bd4f-1ec29d30152b.png?x-oss-process=image/resize,w_750,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=tZAL7&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655216213245-10d6b92a-8068-419a-bd4f-1ec29d30152b.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=tZAL7&amp;margin=[object</a> Object]&amp;originHeight&#x3D;265&amp;originWidth&#x3D;750&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><ol><li><strong>ReentrantLock</strong>：一次只允许一个线程访问某项资源</li><li><strong>CountDownLatch</strong>：用来协调多个线程直接的同步。这个工具通常用来控制线程等待，它可以让每一个线程countDown()，直到所有的线程全部执行结束await(),再开始执行。</li><li><strong>CyclicBarrier</strong>：可循环使用的屏障，它可以让一组线程到达一个屏障时被阻塞，知道最后一个线程到达屏障时，屏障阻塞才会放行，所有被阻塞的线程才会向下执行。</li><li><strong>Semaphore</strong>：信号量，一次只允许指定量的线程同时访问某项资源</li></ol><p>以上工具类均基于AQS实现！</p><h1 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h1><p>AbstractQueuedSynchronizer抽象队列同步器的数据结构灵感来源于CLH队列。</p><blockquote><p>CLH:Craig、Landin and Hagersten队列，是一个单向链表</p></blockquote><p>AQS中的队列是CLH变体的虚拟双向队列FIFO</p><h2 id="双向队列节点"><a href="#双向队列节点" class="headerlink" title="双向队列节点"></a>双向队列节点</h2><p>抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程去继续等待（类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候），但等候线程仍然保留获取锁的可能且获取锁的流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）<br>既然说到了排队等候机制，那么就一定有某种队列形成，这样的队列是什么数据结构呢？如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的结点对象（Node)，通过CAS、自旋以及LockSupport.park()的方式，维护state变量的转态，使并发达到同步的效果。<br>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655215960516-7f444737-0028-4b1e-b8db-0e896b470f91.png?x-oss-process=image/resize,w_750,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=kYzkf&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655215960516-7f444737-0028-4b1e-b8db-0e896b470f91.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=kYzkf&amp;margin=[object</a> Object]&amp;originHeight&#x3D;329&amp;originWidth&#x3D;750&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><h2 id="节点属性说明"><a href="#节点属性说明" class="headerlink" title="节点属性说明"></a>节点属性说明</h2><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655273222657-8cacdb50-4059-42ed-a7f0-4175cb27da38.png?x-oss-process=image/resize,w_1071,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=bhidx&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655273222657-8cacdb50-4059-42ed-a7f0-4175cb27da38.png?x-oss-process=image%2Fresize%2Cw_1071%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=bhidx&amp;margin=[object</a> Object]&amp;originHeight&#x3D;618&amp;originWidth&#x3D;1071&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">/** 线程被取消了 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">    <span class="comment">/** 后续线程需要唤醒 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">/** 等待condition唤醒 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate the next acquireShared should unconditionally propagate */</span></span><br><span class="line">    <span class="comment">/** 共享式同步状态获取将会无条件的传播下去 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始为0，状态就是以上几种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The thread that enqueued this node.  Initialized on construction and nulled out after use. */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">     * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">     * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">     * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">     * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">     * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">     * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">     * mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">     * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">     * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS-state变量"><a href="#AQS-state变量" class="headerlink" title="AQS#state变量"></a>AQS#state变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655263456941-3b8dbd6c-608a-434e-9e37-d1a79f093201.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=aBrTc&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655263456941-3b8dbd6c-608a-434e-9e37-d1a79f093201.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=aBrTc&amp;margin=[object</a> Object]&amp;originHeight&#x3D;350&amp;originWidth&#x3D;955&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><h1 id="从ReentrantLock开始解读AQS"><a href="#从ReentrantLock开始解读AQS" class="headerlink" title="从ReentrantLock开始解读AQS"></a>从ReentrantLock开始解读AQS</h1><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/jpeg/750797/1655273767340-a069723f-9c2f-4914-bee4-55bc8e881083.jpeg?x-oss-process=image/resize,w_1174,limit_0#crop=0.1516&amp;crop=0.1436&amp;crop=0.8763&amp;crop=0.8913&amp;from=url&amp;height=382&amp;id=OkNSq&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/jpeg/750797/1655273767340-a069723f-9c2f-4914-bee4-55bc8e881083.jpeg?x-oss-process=image%2Fresize%2Cw_1174%2Climit_0#crop=0.1516&amp;crop=0.1436&amp;crop=0.8763&amp;crop=0.8913&amp;from=url&amp;height=382&amp;id=OkNSq&amp;margin=[object</a> Object]&amp;originHeight&#x3D;527&amp;originWidth&#x3D;1174&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;&amp;width&#x3D;851)<br>基于AQS源码，在AQS中有个变量State，它的值有3个状态，0-未占用、1-占用、&gt;1 - 可重入锁；<br>如果ABC三个线程进来了以后，请问总共有多少个Node节点？答案是4个。永远的N+1，其中队列的第一个是傀儡节点，业务图如下：<br>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655280706383-c21d111a-4e10-4cf5-8573-4f78d463343f.png?x-oss-process=image/resize,w_1174,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=XME3P&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655280706383-c21d111a-4e10-4cf5-8573-4f78d463343f.png?x-oss-process=image%2Fresize%2Cw_1174%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=XME3P&amp;margin=[object</a> Object]&amp;originHeight&#x3D;529&amp;originWidth&#x3D;1174&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-31 19:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AQSDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//非公平锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// A B C三个顾客，去银行办理业务，A先到，此时窗口空无一人，他优先获得办理窗口的机会，办理业务。</span></span><br><span class="line">        <span class="comment">// A 耗时严重，估计长期占有窗口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----come in A&quot;</span>);</span><br><span class="line">                <span class="comment">//暂停20分钟线程,超长业务</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.MINUTES.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B是第2个顾客，B一看到受理窗口被A占用，只能去候客区等待，进入AQS队列，等待着A办理完成，尝试去抢占受理窗口。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----come in B&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//C是第3个顾客，C一看到受理窗口被A占用，只能去候客区等待，进入AQS队列，等待着A办理完成，尝试去抢占受理窗口,前面是B顾客，FIFO</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----come in C&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后续顾客DEFG。。。。。。。以此类推</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//。。。。。。</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="公平锁加锁原理-hasQueuedPredecessors"><a href="#公平锁加锁原理-hasQueuedPredecessors" class="headerlink" title="公平锁加锁原理 hasQueuedPredecessors"></a>公平锁加锁原理 hasQueuedPredecessors</h2><h3 id="sync-lock"><a href="#sync-lock" class="headerlink" title="sync.lock"></a>sync.lock</h3><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/jpeg/750797/1655275474330-2fc59c6e-0f82-4544-8df9-3542b92132aa.jpeg?x-oss-process=image/resize,w_1174,limit_0#crop=0.1533&amp;crop=0.132&amp;crop=0.8763&amp;crop=0.9069&amp;from=url&amp;height=381&amp;id=qjgDY&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/jpeg/750797/1655275474330-2fc59c6e-0f82-4544-8df9-3542b92132aa.jpeg?x-oss-process=image%2Fresize%2Cw_1174%2Climit_0#crop=0.1533&amp;crop=0.132&amp;crop=0.8763&amp;crop=0.9069&amp;from=url&amp;height=381&amp;id=qjgDY&amp;margin=[object</a> Object]&amp;originHeight&#x3D;527&amp;originWidth&#x3D;1174&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;&amp;width&#x3D;849)</p><h3 id="AbstractQueuedSynchronizer-acquire"><a href="#AbstractQueuedSynchronizer-acquire" class="headerlink" title="AbstractQueuedSynchronizer#acquire"></a>AbstractQueuedSynchronizer#acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655275616465-3f82137b-66eb-4033-9c07-9728c8b83ed2.png?x-oss-process=image/resize,w_948,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=V2MsJ&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655275616465-3f82137b-66eb-4033-9c07-9728c8b83ed2.png?x-oss-process=image%2Fresize%2Cw_948%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=V2MsJ&amp;margin=[object</a> Object]&amp;originHeight&#x3D;419&amp;originWidth&#x3D;948&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)<br>可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()<br>hasQueuedPredecessors 是公平锁加锁时的判断等待队列中是否存在前驱节点的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁为例-解读AQS-尝试获取锁"><a href="#非公平锁为例-解读AQS-尝试获取锁" class="headerlink" title="非公平锁为例 解读AQS|尝试获取锁"></a>非公平锁为例 解读AQS|尝试获取锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NofairSync 若state &#x3D; 0,则表示锁未占用，直接CAS修改状态位state，然后当前线程占锁 setExclusiveOwnerThread(Thread.currentThread());</li><li>否则，NofairSync的方法acquire去尝试获取锁，分三步 tryAcquire|addWaiter|acquireQueued</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655277186992-693a2483-e831-4b86-81b9-3856f64a6df6.png?x-oss-process=image/resize,w_1174,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=wG5jY&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655277186992-693a2483-e831-4b86-81b9-3856f64a6df6.png?x-oss-process=image%2Fresize%2Cw_1174%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=wG5jY&amp;margin=[object</a> Object]&amp;originHeight&#x3D;476&amp;originWidth&#x3D;1174&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取到state的状态，此时为state1，A线程正在办理业务</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nonfairTryAcqure(acquires) return false<br>if (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.<em>EXCLUSIVE</em>), arg))，所以继续推进条件，走下一步方法addWaiter</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到线程B<br>但这个时候，tail的指针式null的，所以会进入enq(node)方法内<br>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655279298505-9fe17352-d66b-47ab-b25a-a5d024f92570.png?x-oss-process=image/resize,w_1108,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=I9EgY&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655279298505-9fe17352-d66b-47ab-b25a-a5d024f92570.png?x-oss-process=image%2Fresize%2Cw_1108%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=I9EgY&amp;margin=[object</a> Object]&amp;originHeight&#x3D;718&amp;originWidth&#x3D;1108&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><blockquote><p>双向链表中，第一个节点为虚节点（也叫哨兵节点），其实并不存储任何信息，只是占位。new Node()<br>真正的第一个有数据的节点，是从第二个节点开始的</p></blockquote><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655278520543-7a8bd1f0-bc61-42a9-a8a9-a44390dd02ac.png?x-oss-process=image/resize,w_1174,limit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=fqw9F&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655278520543-7a8bd1f0-bc61-42a9-a8a9-a44390dd02ac.png?x-oss-process=image%2Fresize%2Cw_1174%2Climit_0#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=fqw9F&amp;margin=[object</a> Object]&amp;originHeight&#x3D;743&amp;originWidth&#x3D;1174&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><h2 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h2><p><strong>acquireQueued当中的 for(;;){…}这是一个大的自旋</strong><br>自旋当中会调用如下方法：shouldParkAterFailedAcquire 和 parkAndCheckInterrupt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><h3 id="https-cdn-nlark-com-yuque-0-2022-png-750797-1655280869739-d9c2e055-b62c-4186-9468-530eb8a43e4a-png-crop-0-amp-crop-0-amp-crop-1-amp-crop-1-amp-from-url-amp-id-YSwOU-amp-margin-object-Object-amp-originHeight-x3D-576-amp-originWidth-x3D-1067-amp-originalType-x3D-binary-amp-ratio-x3D-1-amp-rotation-x3D-0-amp-showTitle-x3D-false-amp-status-x3D-done-amp-style-x3D-shadow-amp-title-x3D"><a href="#https-cdn-nlark-com-yuque-0-2022-png-750797-1655280869739-d9c2e055-b62c-4186-9468-530eb8a43e4a-png-crop-0-amp-crop-0-amp-crop-1-amp-crop-1-amp-from-url-amp-id-YSwOU-amp-margin-object-Object-amp-originHeight-x3D-576-amp-originWidth-x3D-1067-amp-originalType-x3D-binary-amp-ratio-x3D-1-amp-rotation-x3D-0-amp-showTitle-x3D-false-amp-status-x3D-done-amp-style-x3D-shadow-amp-title-x3D" class="headerlink" title="![](https://cdn.nlark.com/yuque/0/2022/png/750797/1655280869739-d9c2e055-b62c-4186-9468-530eb8a43e4a.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=YSwOU&amp;margin=[object Object]&amp;originHeight&#x3D;576&amp;originWidth&#x3D;1067&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)"></a>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655280869739-d9c2e055-b62c-4186-9468-530eb8a43e4a.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=YSwOU&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655280869739-d9c2e055-b62c-4186-9468-530eb8a43e4a.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=YSwOU&amp;margin=[object</a> Object]&amp;originHeight&#x3D;576&amp;originWidth&#x3D;1067&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</h3><h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655280887824-12021475-ca25-430b-abf3-5ee79e47998f.png"><br>线程B、C均在阻塞队列，均等待被唤醒unpark</p><h2 id="尝试获取锁的异常情况cancelAcquire"><a href="#尝试获取锁的异常情况cancelAcquire" class="headerlink" title="尝试获取锁的异常情况cancelAcquire"></a>尝试获取锁的异常情况cancelAcquire</h2><p>线程在阻塞队列等呀等，不想等了就直接走了，相当于删除节点<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655292577615-e66fc5cf-8a2d-497a-9f15-6b0b520891ac.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁为例-解读AQS-唤醒阻塞线程"><a href="#非公平锁为例-解读AQS-唤醒阻塞线程" class="headerlink" title="非公平锁为例 解读AQS|唤醒阻塞线程"></a>非公平锁为例 解读AQS|唤醒阻塞线程</h2><h3 id="unlock获取LockSupport的permit"><a href="#unlock获取LockSupport的permit" class="headerlink" title="unlock获取LockSupport的permit"></a>unlock获取LockSupport的permit</h3><p>release| tryRelease| unparkSuccessor(h)<br>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655281264176-4c1dae5f-a149-42af-99b4-450e474ddf7f.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=lJIoC&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655281264176-4c1dae5f-a149-42af-99b4-450e474ddf7f.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=lJIoC&amp;margin=[object</a> Object]&amp;originHeight&#x3D;306&amp;originWidth&#x3D;666&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655281264239-ec51e2f4-62eb-4db9-a3b6-da2cc334cb2e.png"></p><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a>unparkSuccessor()</h3><p>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655281264231-4a366da3-b3c3-47e0-bf47-d1064d95fa53.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=EwfHc&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655281264231-4a366da3-b3c3-47e0-bf47-d1064d95fa53.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=EwfHc&amp;margin=[object</a> Object]&amp;originHeight&#x3D;438&amp;originWidth&#x3D;985&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><h2 id="acquireQueued-1"><a href="#acquireQueued-1" class="headerlink" title="acquireQueued"></a>acquireQueued</h2><h3 id="setHead"><a href="#setHead" class="headerlink" title="setHead"></a>setHead</h3><p>当我们执行下图中的③表示线程B或者C已经获取了permit了<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655281487543-618a4d5a-8a9a-41f3-8f1b-afb1761a7abb.png"><br>③代码执行完毕后，会出现如下图所示<br>![](<a href="https://cdn.nlark.com/yuque/0/2022/png/750797/1655281487373-6b575b8f-d2b5-4148-b1f5-718ad295b8f5.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=fbpfy&amp;margin=[object">https://cdn.nlark.com/yuque/0/2022/png/750797/1655281487373-6b575b8f-d2b5-4148-b1f5-718ad295b8f5.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=fbpfy&amp;margin=[object</a> Object]&amp;originHeight&#x3D;736&amp;originWidth&#x3D;1043&amp;originalType&#x3D;binary&amp;ratio&#x3D;1&amp;rotation&#x3D;0&amp;showTitle&#x3D;false&amp;status&#x3D;done&amp;style&#x3D;shadow&amp;title&#x3D;)</p><blockquote><p>原有的傀儡节点离开，有助于GC<br>线程B真正的执行业务去了，留下了线程B的空壳节点成位为新的傀儡节点</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655281487559-1d3bdd19-e026-4fc3-b422-da0bc4610b91.png"></p><h1 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h1><p><strong>面试官</strong>：其实我在问CountDownLatch和CyclicBarrier有什么什么区别的时候，你就可以围绕源码可以给我讲讲<br><strong>面试官</strong>：而不是随便说CountDownLatch是一次性的，而CyclicBarrier可在完成时重置进而重复使用就来敷衍我<br><strong>CountDownLatch原理介绍</strong><br>CountDownLatch两个方法：</p><ul><li>countDown()</li><li>await()</li></ul><p><strong>面试官</strong>：比如说CountDownLatch你就可以回答：前面提到了CountDownLatch也是基于AQS实现的，它的实现机制很简单，</p><ul><li><strong>面试官</strong>：当我们在构建CountDownLatch对象时，传入的值其实就会赋值给 AQS 的关键变量state</li><li><strong>面试官</strong>：执行CountDownLatch的countDown方法时，其实就是利用CAS 将state 减一</li><li><strong>面试官</strong>：执行await方法时，其实就是判断state是否为0，不为0则加入到阻塞队列中，将该线程阻塞掉（除了头结点），因为头节点会一直自旋等待state为0，当state为0时，头节点把剩余的在队列中阻塞的节点也一并唤醒。</li><li><strong>面试官</strong>：<strong>是不是经过解释后，就会让人觉得清晰很多？</strong></li><li><strong>候选者</strong>：你说得对</li></ul><blockquote><p>再简单总结下：CountDownlatch基于AQS实现，会将构造CountDownLatch的入参传递至state，countDown()就是在利用CAS将state减-1，<br>await()实际就是让头节点一直在等待state为0时，释放所有等待的线程</p></blockquote><h1 id="CyclicBarrier原理介绍"><a href="#CyclicBarrier原理介绍" class="headerlink" title="CyclicBarrier原理介绍"></a>CyclicBarrier原理介绍</h1><ul><li><strong>面试官</strong>：回到CyclicBarrier上，代码也不难，只有await方法。从源码不难发现的是：</li></ul><ol><li><strong>它没有像CountDownLatch和ReentrantLock使用AQS的state变量，而是使用CyclicBarrier内部维护的内部维护count变量</strong></li><li>同时CyclicBarrier借助ReentrantLock加上Condition实现等待唤醒的功能</li></ol><p><strong>面试官</strong>：在构建CyclicBarrier时，传入的值是parties变量，同时也会赋值给CyclicBarrier内部维护count变量（这是可以复用的关键）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parties表示屏障拦截的线程数量，当屏障撤销时，先执行barrierAction，然后在释放所有线程</span></span><br><span class="line">publicCyclicBarrier(intparties,RunnablebarrierAction)</span><br><span class="line"><span class="comment">//barrierAction默认为null</span></span><br><span class="line">publicCyclicBarrier(intparties)</span><br></pre></td></tr></table></figure><p><strong>面试官</strong>：每次调用await时，会将count -1 ，操作count值是直接使用ReentrantLock来保证线程安全性<br><strong>面试官</strong>：如果count不为0，则添加则condition队列中<br><strong>面试官</strong>：如果count等于0时，则把节点从condition队列添加至AQS的队列中进行全部唤醒，并且将parties的值重新赋值为count的值（实现复用）<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655356490832-5c832d07-8026-4076-80c1-1f6fbbcec3b6.png"></p><blockquote><p>再简单总结下：CyclicBarrier则利用ReentrantLock和Condition，自身维护了count和parties变量。<br>每次调用await将count-1，并将线程加入到condition队列上。等到count为0时，则将condition队列的节点移交至AQS队列，并全部释放。</p></blockquote><h2 id="CyclicBarrier的特点"><a href="#CyclicBarrier的特点" class="headerlink" title="CyclicBarrier的特点"></a><strong>CyclicBarrier的特点</strong></h2><h3 id="阻塞任务线程而非主线程"><a href="#阻塞任务线程而非主线程" class="headerlink" title="阻塞任务线程而非主线程"></a><strong>阻塞任务线程而非主线程</strong></h3><p>CountDownLatch和CyclicBarrier都是线程同步的工具类。可以发现这两者的等待主体是不一样的。</p><ul><li>CountDownLatch调用await()通常是<a href="https://www.zhihu.com/search?q=%E4%B8%BB%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2529350186%7D">主线程</a>&#x2F;调用线程，</li><li>CyclicBarrier调用await()是在任务线程调用的，所以，CyclicBarrier中的阻塞的是任务的线程，而主线程是不受影响的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1661505678476-bc9ecff7-13e1-4356-a04a-5924cafff975.jpeg" alt="微信图片_20220616131232.jpg"><br>比如集齐7颗龙珠就能召唤神龙。<br>代码验证：CyclicBarrierDemo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//集齐7颗龙珠就能召唤神龙</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// public CyclicBarrier(int parties, Runnable barrierAction) &#123;&#125;</span></span><br><span class="line">        CyclicBarrier cyclicBarrier=<span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤龙珠&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> temp=i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t收集到了第&quot;</span>+temp+<span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共同抵达时的执行操作"><a href="#共同抵达时的执行操作" class="headerlink" title="共同抵达时的执行操作"></a>共同抵达时的执行操作</h3><p>屏障的抵达操作：每个线程执行时，都会碰到一个屏障，直到所有线程执行结束，然后屏障便会打开，使所有线程继续往下执行。</p><ul><li>CyclicBarrier支持一个可选的Runnable barrierAction命令，在一组线程中的最后一个线程到达之后，但在释放所有线程之前运行一次。</li><li>若在继续所有参与线程之前更新共享状态，此屏障操作很有用。</li></ul><p>这里介绍CyclicBarrier的两个构造函数：</p><ul><li>CyclicBarrier(int parties) 前者只需要声明需要拦截的线程数即可</li><li>CyclicBarrier(int parties, Runnable barrierAction) 后者还需要定义一个等待所有线程到达屏障优先执行的Runnable对象。</li></ul><p>如果一个寝室四个人约好了去球场打球，由于四个人准备工作不同，所以约好在楼下集合，并且四个人集合好之后一起出发去球场。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">4</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    <span class="comment">//当拦截线程数达到4时，便优先执行barrierAction，然后再执行被拦截的线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">4</span>, () -&gt; System.out.println(<span class="string">&quot;寝室四兄弟一起出发去球场&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;开始从宿舍出发&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">                <span class="comment">//线程的具体业务操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;从楼底下出发&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;到达操场&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;李明&quot;</span>, <span class="string">&quot;王强&quot;</span>, <span class="string">&quot;刘凯&quot;</span>, <span class="string">&quot;赵杰&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>(str[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;四个人一起到达球场，现在开始打球&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">王强开始从宿舍出发</span><br><span class="line">刘凯开始从宿舍出发</span><br><span class="line">李明开始从宿舍出发</span><br><span class="line">赵杰开始从宿舍出发</span><br><span class="line">寝室四兄弟一起出发去球场</span><br><span class="line">李明从楼底下出发</span><br><span class="line">刘凯从楼底下出发</span><br><span class="line">王强从楼底下出发</span><br><span class="line">赵杰从楼底下出发</span><br><span class="line">赵杰到达操场</span><br><span class="line">刘凯到达操场</span><br><span class="line">王强到达操场</span><br><span class="line">李明到达操场</span><br><span class="line">四个人一起到达球场，现在开始打球</span><br></pre></td></tr></table></figure><h3 id="屏障复用"><a href="#屏障复用" class="headerlink" title="屏障复用"></a><strong>屏障复用</strong></h3><p>CyclicBarrier是可循环利用的屏障，顾名思义，这个名字也将这个类的特点给明确地表示出来了。可重复利用，说明该类创建的对象可以复用；CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与CountDownLatch不同的是该barrier在释放等待线程后可以重用，所以称它为循环（Cyclic）的屏障（Barrier）。<br>现在对CyclicBarrier进行复用…又来了一拨人，看看愿不愿意一起打：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">4</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    <span class="comment">//当拦截线程数达到4时，便优先执行barrierAction，然后再执行被拦截的线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">4</span>, () -&gt; System.out.println(<span class="string">&quot;寝室四兄弟一起出发去球场&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;开始从宿舍出发&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;从楼底下出发&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;到达操场&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;李明&quot;</span>, <span class="string">&quot;王强&quot;</span>, <span class="string">&quot;刘凯&quot;</span>, <span class="string">&quot;赵杰&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>(str[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;四个人一起到达球场，现在开始打球&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;现在对CyclicBarrier进行复用.....&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;又来了一拨人，看看愿不愿意一起打：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] str1= &#123;<span class="string">&quot;王二&quot;</span>,<span class="string">&quot;洪光&quot;</span>,<span class="string">&quot;雷兵&quot;</span>,<span class="string">&quot;赵三&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>(str1[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;四个人一起到达球场，表示愿意一起打球，现在八个人开始打球&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">李明开始从宿舍出发</span><br><span class="line">刘凯开始从宿舍出发</span><br><span class="line">王强开始从宿舍出发</span><br><span class="line">赵杰开始从宿舍出发</span><br><span class="line">寝室四兄弟一起出发去球场</span><br><span class="line">李明从楼底下出发</span><br><span class="line">赵杰从楼底下出发</span><br><span class="line">刘凯从楼底下出发</span><br><span class="line">王强从楼底下出发</span><br><span class="line">李明到达操场</span><br><span class="line">赵杰到达操场</span><br><span class="line">刘凯到达操场</span><br><span class="line">王强到达操场</span><br><span class="line">四个人一起到达球场，现在开始打球</span><br><span class="line"></span><br><span class="line">现在对CyclicBarrier进行复用…</span><br><span class="line">又来了一拨人，看看愿不愿意一起打：</span><br><span class="line">王二开始从宿舍出发</span><br><span class="line">洪光开始从宿舍出发</span><br><span class="line">赵三开始从宿舍出发</span><br><span class="line">雷兵开始从宿舍出发</span><br><span class="line">寝室四兄弟一起出发去球场</span><br><span class="line">雷兵从楼底下出发</span><br><span class="line">赵三从楼底下出发</span><br><span class="line">王二从楼底下出发</span><br><span class="line">洪光从楼底下出发</span><br><span class="line">洪光到达操场</span><br><span class="line">赵三到达操场</span><br><span class="line">王二到达操场</span><br><span class="line">雷兵到达操场</span><br><span class="line">四个人一起到达球场，表示愿意一起打球，现在八个人开始打球</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;![](&lt;a href=&quot;https://cdn.nlark.com/yuque/0/2022/png/750797/1655214807962-b2ed2591-604b-43ce-b79d-02240d84b4f1.png#crop=0&amp;amp;crop=0&amp;amp;c</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="线程并发" scheme="https://lyotoc.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>shiro权限认证</title>
    <link href="https://lyotoc.github.io/2022/08/11/shiro%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
    <id>https://lyotoc.github.io/2022/08/11/shiro%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/</id>
    <published>2022-08-11T07:31:37.000Z</published>
    <updated>2022-08-11T09:46:33.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro框架"><a href="#Shiro框架" class="headerlink" title="Shiro框架"></a>Shiro框架</h1><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/e7be250af6164c5d80ac8ae008c1b0dc.png" alt="在这里插入图片描述"></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ol><li><p><strong>subject</strong><br>主体，可以看到主体可以是任何可以与应用交互的 “用户”</p></li><li><p><strong>SecurityManager</strong></p><p>相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理</p></li><li><p><strong>Authenticator</strong><br>认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了</p></li><li><p><strong>Authorizer</strong></p><p>授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能</p></li><li><p><strong>Realm</strong><br>可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 &#x2F; 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm</p></li><li><p><strong>SessionManager</strong><br>如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所以呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器)</p></li><li><p><strong>SessionDAO</strong><br>DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能</p></li><li><p><strong>CacheManager</strong><br>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p></li><li><p><strong>Cryptography</strong></p><p>密码模块，Shiro 提供了一些常见的加密组件用于如密码加密 &#x2F; 解密的</p></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>SpringBoot整合Shiron</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shiro框架&quot;&gt;&lt;a href=&quot;#Shiro框架&quot; class=&quot;headerlink&quot; title=&quot;Shiro框架&quot;&gt;&lt;/a&gt;Shiro框架&lt;/h1&gt;&lt;h2 id=&quot;权限管理&quot;&gt;&lt;a href=&quot;#权限管理&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="权限认证" scheme="https://lyotoc.github.io/tags/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>docker配置rabbitmq</title>
    <link href="https://lyotoc.github.io/2022/08/01/docker%E9%85%8D%E7%BD%AErabbitmq/"/>
    <id>https://lyotoc.github.io/2022/08/01/docker%E9%85%8D%E7%BD%AErabbitmq/</id>
    <published>2022-08-01T10:03:38.000Z</published>
    <updated>2022-08-01T10:04:13.856Z</updated>
    
    <content type="html"><![CDATA[<p>一、docker上部署启动RabbitMQ</p><p>1、查询rabbitmq镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search rabbitmq:management</span><br></pre></td></tr></table></figure><p>2、拉取rabbitmq镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p>3、创建并启动容器</p><h5 id="3-1创建和启动"><a href="#3-1创建和启动" class="headerlink" title="3.1创建和启动"></a>3.1创建和启动</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --hostname my-rabbit --name rabbit -p 8080:15672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--hostname：指定容器主机名称</span><br><span class="line">--name:指定容器名称</span><br><span class="line">-p:将mq端口号映射到本地</span><br></pre></td></tr></table></figure><h2 id="3-2备选启动同时设置用户和密码"><a href="#3-2备选启动同时设置用户和密码" class="headerlink" title="3.2备选启动同时设置用户和密码"></a>3.2备选启动同时设置用户和密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15672：控制台端口号</span><br><span class="line"></span><br><span class="line">5672：应用访问端口号</span><br></pre></td></tr></table></figure><p>此处的端口访问是有区别的，控制台端口用于管理rabbitmq，应用访问端口号为rabbitclient等应用访问。</p><h2 id="3-3查看rabbitmq运行状况："><a href="#3-3查看rabbitmq运行状况：" class="headerlink" title="3.3查看rabbitmq运行状况："></a>3.3查看rabbitmq运行状况：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs rabbit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20180328193245738">  </p><p>4、访问</p><pre><code>[http://localhost:15672](http://localhost:15672/)  </code></pre><p>5、登录</p><pre><code>默认账户名：guest密码：guest</code></pre><p>提醒，如果关闭计算机时未停止这个启动的容器，再次启动docker时会出现无法访问15672的情况，此时只需停止并移除这个容器，然后重启一次docker，重新执行启动rabbitmq容器的命令即可。</p><p>二、使用RabbitMQ</p><p>1、创建sender</p><p>a、构建消息提供者类sender</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package org.vertx.vertx.rabbitmq.example;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class Send &#123;</span><br><span class="line"></span><br><span class="line">private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv)throws java.io.IOException, TimeoutException &#123;</span><br><span class="line">  ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">  factory.setUsername(&quot;guest&quot;);</span><br><span class="line">  factory.setPassword(&quot;guest&quot;);</span><br><span class="line">  factory.setHost(&quot;localhost&quot;);</span><br><span class="line">  factory.setPort(5672);</span><br><span class="line">  factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">  Connection connection = factory.newConnection();</span><br><span class="line">  Channel channel = connection.createChannel();</span><br><span class="line">  channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">  String message = &quot;Hello World!&quot;;</span><br><span class="line">  channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">  System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">  channel.close();</span><br><span class="line">  connection.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>b、启动后可查看消息队列。c、访问链接[http://127.0.0.1:15672/#/queues](http://127.0.0.1:15672/#/queues)   可见，RabbitMQ management中name为hello的消息产生一条。</code></pre><p><img src="https://img-blog.csdn.net/2018032819424869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTYxNzA1Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">  </p><p>2、创建receiver</p><p>a、创建消息接收方的类receiver。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package org.vertx.vertx.rabbitmq.example;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class MyConsumer &#123;</span><br><span class="line"></span><br><span class="line">  private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setUsername(&quot;guest&quot;);</span><br><span class="line">factory.setPassword(&quot;guest&quot;);</span><br><span class="line">factory.setHost(&quot;localhost&quot;);</span><br><span class="line">factory.setPort(5672);</span><br><span class="line">factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">factory.setConnectionTimeout(600000); // in milliseconds</span><br><span class="line">factory.setRequestedHeartbeat(60); // in seconds</span><br><span class="line">factory.setHandshakeTimeout(6000); // in milliseconds</span><br><span class="line">factory.setRequestedChannelMax(5);</span><br><span class="line">factory.setNetworkRecoveryInterval(500); </span><br><span class="line">    </span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">    System.out.println(&quot;Waiting for messages. &quot;);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)</span><br><span class="line">          throws IOException &#123;</span><br><span class="line">        String message = new String(body, &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>b、启动receiver并访问链接</p><p>c、运行后可接收到消息</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20180328194547170">  </p><p>d、访问管理器查看消息队列</p><p><a href="http://127.0.0.1:15672/#/queues">http://127.0.0.1:15672/#/queues</a>  </p><p><img src="https://img-blog.csdn.net/20180328194030553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTYxNzA1Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">  </p><p>消息队列中hello的消息条数为0，已发送至接收方。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、docker上部署启动RabbitMQ&lt;/p&gt;
&lt;p&gt;1、查询rabbitmq镜像&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://lyotoc.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker配置elasticsearch</title>
    <link href="https://lyotoc.github.io/2022/08/01/docker%E9%85%8D%E7%BD%AEelasticsearch/"/>
    <id>https://lyotoc.github.io/2022/08/01/docker%E9%85%8D%E7%BD%AEelasticsearch/</id>
    <published>2022-08-01T09:34:00.000Z</published>
    <updated>2022-08-08T08:52:50.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ElasticSearch（简称ES）天然支持分布式，具备存储海量数据的能力，其搜索和数据分析的功能都建立在ElasticSearch存储的海量的数据之上。目前主要用于大量数据的挖掘和搜索。使用的优势是在数据量较大的时候可以进行快速搜索，并且本身还带有分词器，可以对elasticSearch内的数据进行分词搜索。有利于数据管理。</p><h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1.存储优化：紧凑的结构，通过对词典中单词前缀和后缀的重复利用，压缩了存储空间。它有着字典树的查询时间复杂度，但是由于做了后缀合并会更节约内存。<br>2.联合查询优化：若要对多个term做联合查询，比如做AND来查询，实际上便是联合各个term产生的跳表Skip-list做查询<br>3.算法：ES数据库中集成了数据分析器Analyzer，例如Charater Filter(特殊字符替换) -&gt; Tokenizer(分词) -&gt; Token Filter(每个词处理)在数据分析，自然语言处理中非常常见<br>4.es支持集群模式：ES数据库集群化，分片，主从备份机制，容灾能力，可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><hr><p>1.浪费空间：由于ES数据库采用文档Id分布，当文档很稀疏时，将会很浪费空间<br>2.在需要添加新数据与新字段的时候，如果elasticSearch进行搜索是可能需要重新修改格式。之前的数据需要重新同步，对数据的管理有很多困难。</p><h2 id="1-安装ElasticSearch"><a href="#1-安装ElasticSearch" class="headerlink" title="1.安装ElasticSearch"></a>1.安装ElasticSearch</h2><p><strong>拉取镜像：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.7.0</span><br></pre></td></tr></table></figure><p><strong>启动容器：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -d -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; -e &quot;discovery.type=single-node&quot; -p 9002:9200 -p 9300:9300 elasticsearch:7.7.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>安装分词器：</strong></p><p>下载安装包：<br>宿主机里面下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget  https://link.csdn.net/?target=https%3A%2F%2Fgithub.com%2Fmedcl%2Felasticsearch-analysis-ik%2Freleases%2Fdownload%2Fv7.7.0%2Felasticsearch-analysis-ik-7.7.0.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将分词器拷贝到容器内部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 进入容器内</span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"># 在plugins目录下创建ik目录</span><br><span class="line">mkdir ./ik</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp /home/elasticsearch-analysis-ik-7.7.0.zip elasticsearch:/usr/share/elasticsearch/plugins/ik/</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 再次进入镜像进行 解压</span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line">cd /usr/share/elasticsearch/plugins/ik/</span><br><span class="line">unzip elasticsearch-analysis-ik-7.7.0.zip </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>退出容器，重启容器。</p><p><strong>访问：</strong></p><p>120.48.54.67（安装es的ip）:9002（启动docker容器时的端口号）<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/eecb8577a1794e2db292619a7f4ee985.png" alt="在这里插入图片描述"></p><h2 id="2-安装ElasticSearch-Head"><a href="#2-安装ElasticSearch-Head" class="headerlink" title="2.安装ElasticSearch-Head"></a>2.安装ElasticSearch-Head</h2><p>（elasticsearch-head 是用于监控 Elasticsearch 状态的客户端插件，包括数据可视化、执行增删改查操作等。）</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mobz/elasticsearch-head:5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动容器："><a href="#启动容器：" class="headerlink" title="启动容器："></a>启动容器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create --name elasticsearch-head -p 9100:9100 mobz/elasticsearch-head:5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="访问："><a href="#访问：" class="headerlink" title="访问："></a>访问：</h3><p>120.48.54.67:9100<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/40db9cba693444d2936d5c198a2e1767.png" alt="在这里插入图片描述"></p><h3 id="3-配置ElasticSearch跨域问题"><a href="#3-配置ElasticSearch跨域问题" class="headerlink" title="3.配置ElasticSearch跨域问题"></a>3.配置ElasticSearch跨域问题</h3><p>ElasticSearch-Head中创建索引，这里可看到索引、类型、字段、数据信息。<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2fb4bb3e3a5c4e4c9602dd9325ed4c4d.png" alt="在这里插入图片描述"></p><p>访问请求：<a href="http://localhost:9100/">http://localhost:9100/</a> ：发现集群健康值是灰色，访问不到ElasticSearch 服务，是因为存在跨域问题。</p><h4 id="进入容器："><a href="#进入容器：" class="headerlink" title="进入容器："></a>进入容器：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改配置文件vi-config-x2F-elasticsearch-yml即可。"><a href="#修改配置文件vi-config-x2F-elasticsearch-yml即可。" class="headerlink" title="修改配置文件vi config&#x2F;elasticsearch.yml即可。"></a>修改配置文件vi config&#x2F;elasticsearch.yml即可。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将上边俩行写进配置文件中，注意这里是用yml的配置文件，简单普及一下此类配置文件的几点语法。</p><p>冒号后边必须有一个空格<br>使用空格的缩进标识层级关系，空格数据不重要，只要是左边对其的一列键即可。<br>对大小写十分敏感<br>缩进时不允许使用tab，只允许使用空格。<br>配置修改完后需执行命令exit退出容器，接着执行docker restart 容器ID重启容器即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2757ac2469544b0f92d054a62f9b92f4.png" alt="在这里插入图片描述"></p><p>如果跨域问题解决了，但是新建索引还是没有反应，点击页面f12 发现请求406了。</p><h4 id="处理报406错误"><a href="#处理报406错误" class="headerlink" title="处理报406错误"></a>处理报406错误</h4><p>将容器中的配置文件拷贝到宿主机上面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp elasticsearch-head:/usr/src/app/_site/vendor.js /usr/local/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入到&#x2F;usr&#x2F;local即可看到从容器中复制出来的文件vendor.js。<br>修改文件第6886、7574行，将”application&#x2F;x-www-from-urlencodes”修改为”application&#x2F;json;charset&#x3D;UTF-8”即可</p><p>将修改好的配置文件复制到容器内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp /usr/local/vendor.js elasticsearch-head:/usr/src/app/_site</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启容器，再次刷新访问。</p><p>我们就把head当做数据展示工具，至于查询的实现，用 Kibana 实现效果更好。</p><h2 id="4-安装Kibana-用于查询"><a href="#4-安装Kibana-用于查询" class="headerlink" title="4.安装Kibana 用于查询"></a>4.安装Kibana 用于查询</h2><h3 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h3><p>找到与elasticsearch 对应的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.7.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动容器：-1"><a href="#启动容器：-1" class="headerlink" title="启动容器："></a>启动容器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -e ELASTICSEARCH_URL=http://120.48.54.67:9002 --name kibana --restart=always -p 5601:5601 kibana:7.7.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ELASTICSEARCH_URL选择你的elasticsearch 地址。</p><h3 id="进入容器：-1"><a href="#进入容器：-1" class="headerlink" title="进入容器："></a>进入容器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#使用vi 修改文件内容</span><br><span class="line">vi /usr/share/kibana/config/kibana.yml </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有vim命令先更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按i 进入修改，将如下内容写到kibana.yml中，然后保存退出：:wq<br>elasticsearch.hosts 改成你的es 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># ** THIS IS AN AUTO-GENERATED FILE **</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Default Kibana configuration for docker target</span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.hosts: [ &quot;http://120.48.54.67:9002&quot; ]</span><br><span class="line">monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line">i18n.locale: zh-CN</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>退出容器，重启容器。</p><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>120.48.54.67:5601<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/69377debe605483f9dc976d06f2fe1f7.png" alt="在这里插入图片描述"><br>如果长时间都是下图那样服务器没准备好，可以看下日志排查问题：<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/d9ef63ae71194a11a47481e144c31ff5.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查看kibana容器日志</span><br><span class="line">docker logs -f 容器ID</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最终效果："><a href="#最终效果：" class="headerlink" title="最终效果："></a>最终效果：</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/480aad518aa34fe5985d3dc1bddb8343.png" alt="在这里插入图片描述"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;ElasticSearch（简称ES）天然支持分布式，具备存储海量数据的能力，其搜索和数据分析的功能都建立在ElasticSearch存储的</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://lyotoc.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器相关</title>
    <link href="https://lyotoc.github.io/2022/08/01/Docker%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>https://lyotoc.github.io/2022/08/01/Docker%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2022-08-01T03:41:00.000Z</published>
    <updated>2022-09-18T02:24:20.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载docker"><a href="#下载docker" class="headerlink" title="下载docker"></a><strong>下载docker</strong></h3><blockquote><p>如有旧版本，下载前需remove</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure><ul><li><p>设置docker 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">   --add-repo \</span><br><span class="line">   https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装docker 的engine和container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">--启动docker</span><br><span class="line"> sudo systemctl start docker</span><br><span class="line"> </span><br><span class="line">--设置自启动</span><br><span class="line"> sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></li><li><p>设置dockerHub的国内源（使用阿里云）</p></li></ul><p>在阿里云官网的镜像加速器依照给出的教程进行设置</p><h3 id="docker下配置MySQL"><a href="#docker下配置MySQL" class="headerlink" title="docker下配置MySQL"></a>docker下配置MySQL</h3><p>–mysql镜像pull</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql [:tags(版本号)]</span><br></pre></td></tr></table></figure><p>–mysql启动及映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>–mysql my.cnf文件配置修改（my.cnf文件被映射到&#x2F;etc&#x2F;mysql）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /mydata/mysql/conf/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=<span class="string">&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span></span><br><span class="line">init_connect=<span class="string">&#x27;SET NAMES utf8&#x27;</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><h3 id="docker下配置redis"><a href="#docker下配置redis" class="headerlink" title="docker下配置redis"></a>docker下配置redis</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li><li><p>创建实例并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/redis/conf</span><br><span class="line"><span class="built_in">touch</span> /mydata/redis/conf/redis.conf</span><br><span class="line"></span><br><span class="line">--先创建redis的配置文件的目的是为了防止doker启动redis的时候将redis.conf误识别为文件夹</span><br><span class="line"></span><br><span class="line">--启动redis容器并挂载文件夹</span><br><span class="line">docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \</span><br><span class="line">-v/mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>配置文件（redis.conf）中添加<code>appendonly yes</code>使redis能够持久化存储</p></li></ol><h3 id="配置docker容器自启动"><a href="#配置docker容器自启动" class="headerlink" title="配置docker容器自启动"></a>配置docker容器自启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--设置redis为自启动</span><br><span class="line">docker update redis --restart=always</span><br></pre></td></tr></table></figure><h3 id="docker配置Nacos"><a href="#docker配置Nacos" class="headerlink" title="docker配置Nacos"></a>docker配置Nacos</h3><ol><li><p>pull镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos/nacos-server : [版本号]</span><br></pre></td></tr></table></figure></li><li><p>创建挂载目录及文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /novel-cloud/nacos/logs:/etc/nacos/logs</span><br><span class="line"><span class="built_in">mkdir</span> /novel-cloud/nacos/init.d/custom.properties:/etc/nacos/init.d</span><br><span class="line"><span class="built_in">touch</span> /novel-cloud/nacos/init.d/custom.properties:/etc/nacos/init.d/custom.properties</span><br></pre></td></tr></table></figure></li><li><p>在custom.properties中加上初始化sql地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql</span><br></pre></td></tr></table></figure></li><li><p>启动nacos并配置相关配置 映射挂载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker  run \</span><br><span class="line">--name nacos-kiki -d \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">--restart=always \</span><br><span class="line">-e JVM_XMS=256m \</span><br><span class="line">-e JVM_XMX=256m \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e PREFER_HOST_MODE=hostname \</span><br><span class="line">-v /novel-cloud/nacos/logs:/etc/nacos/logs \</span><br><span class="line">-v /novel-cloud/nacos/init.d/custom.properties:/etc/nacos/init.d/custom.properties \</span><br><span class="line">nacos/nacos-server</span><br></pre></td></tr></table></figure></li></ol><h3 id="docker配置ElasticSearch"><a href="#docker配置ElasticSearch" class="headerlink" title="docker配置ElasticSearch"></a>docker配置ElasticSearch</h3><ol><li><p>pull镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.7.0</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -d -e ES_JAVA_OPTS=<span class="string">&quot;-Xms512m -Xmx512m&quot;</span> -e <span class="string">&quot;discovery.type=single-node&quot;</span> -p 9002:9200 -p 9300:9300 elasticsearch:7.7.0</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>后续详细步骤见<code>docker配置elasticsearch</code></p></blockquote><h3 id="docker配置rabbitMQ"><a href="#docker配置rabbitMQ" class="headerlink" title="docker配置rabbitMQ"></a>docker配置rabbitMQ</h3><h2 id="Docker排查问题"><a href="#Docker排查问题" class="headerlink" title="Docker排查问题"></a>Docker排查问题</h2><h3 id="Docker容器启动失败"><a href="#Docker容器启动失败" class="headerlink" title="Docker容器启动失败"></a>Docker容器启动失败</h3><ol><li><strong>使用<code>inspect</code>查看他的.LogPath日志文件</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="comment"># /var/lib/docker/containers/bf9b112623acd995a5f03c7765d8358c268690648adb58119ca9bc3553da4e6f/bf9b112623acd995a5f03c7765d8358c268690648adb58119ca9bc3553da4e6f-json.log</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>通过 cat指令打开日志文件，分析错误原因</p><p>Aspire to inspire until I expire</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/lib/docker/containers/bf9b112623acd995a5f03c7765d8358c268690648adb58119ca9bc3553da4e6f/bf9b112623acd995a5f03c7765d8358c268690648adb58119ca9bc3553da4e6f-json.log <span class="comment">#为查询出的日志文件位置</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h2><table><thead><tr><th>指令</th><th>option …</th><th>描述</th></tr></thead><tbody><tr><td>docker update –restart&#x3D;always</td><td>always即为自启动</td><td>容器自启动</td></tr><tr><td>systemctl enable docker.service</td><td></td><td>docker自启动开启</td></tr><tr><td>systemctl disable docker.service</td><td></td><td>docker自启动关闭</td></tr><tr><td>docker exec -it [容器名] 命令板块</td><td></td><td>进入容器</td></tr></tbody></table><h2 id="设定时区"><a href="#设定时区" class="headerlink" title="设定时区"></a>设定时区</h2><p>1、在Dockerfile中设置镜像时区</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br></pre></td></tr></table></figure><p>2、创建容器时设置时区<br>将宿主机与容器的时间进行挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /etc/localtime:/etc/localtime</span><br></pre></td></tr></table></figure><p>3、进入容器进行设置<br>1）进入容器内：docker exec -it 容器名 &#x2F;bin&#x2F;bash<br>2）设定时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /etc/localtime</span><br><span class="line"><span class="built_in">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d -p 3306:3306 --name mysql \</span><br><span class="line">-v /filedata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /filedata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /filedata/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-e TZ=Asia/Shanghai mysql:8.0 \</span><br><span class="line">--lower_case_table_names=1</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /root/nginx/www /root/nginx/logs /root/nginx/conf</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;下载docker&quot;&gt;&lt;a href=&quot;#下载docker&quot; class=&quot;headerlink&quot; title=&quot;下载docker&quot;&gt;&lt;/a&gt;&lt;strong&gt;下载docker&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如有旧版本，下载前需remove</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://lyotoc.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring杂烩</title>
    <link href="https://lyotoc.github.io/2022/07/29/Spring%E6%9D%82%E7%83%A9/"/>
    <id>https://lyotoc.github.io/2022/07/29/Spring%E6%9D%82%E7%83%A9/</id>
    <published>2022-07-29T07:29:09.000Z</published>
    <updated>2022-09-19T01:53:25.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="执行流程及生命周期"><a href="#执行流程及生命周期" class="headerlink" title="执行流程及生命周期"></a>执行流程及生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/Spring%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E6%B0%B4%E5%8D%B0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20210730082258905.png" alt="img"></p><p><strong>Spring七大模块组件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220729155336584.png" alt="image-20220729155336584"></p><h3 id="Spring的Order接口，-Order、-Primary、-Priority"><a href="#Spring的Order接口，-Order、-Primary、-Priority" class="headerlink" title="Spring的Order接口，@Order、@Primary、@Priority"></a>Spring的Order接口，@Order、@Primary、@Priority</h3><ul><li><code>orderd接口</code>，实现<code>Oderd接口</code>的话要实现<code>int getOrder()</code>;这个方法，返回一个整数值，值越小优先级越高。</li><li><code>@Order</code>里面存储了一个值，默认为Integer的最大值，同样值越小优先级越高。要注意<code>@Order</code>只能控制组件的加载顺序，不能控制注入的优先级。但是能控制List 里面存放的XXX的顺序，原因是当通过构造函数或者方法参数注入进某个List时，Spring的<code>DefaultListableBeanFactory</code>类会在注入时调用<code>AnnotationAwareOrderComparator.sort(listA)</code>帮我们去完成根据<code>@Order</code>或者<code>Ordered接口</code>序值排序。<code>@Order</code>更加适用于集合注入的排序。</li><li><code>@Priority</code>与<code>@Order</code>类似，<code>@Order</code>是Spring提供的注解，<code>@Priority</code>是JSR 250标准，同样是值越小优先级越高。但是两者还是有一定却别，<code>@Priority</code>能够控制组件的加载顺序，因此<code>@Priority</code>侧重于单个注入的优先级排序。此外<code>@Priority</code>优先级比<code>@Order</code>更高，两者共存时优先加载<code>@Priority</code>。</li><li><code>@Primary</code>是优先级最高的，如果同时有<code>@Primary</code>以及其他几个的话，<code>@Primary</code>注解的<code>Bean</code>会优先加载。</li></ul><p>这个优先级可以在Spring源码中的DefaultListableBeanFactory类看出，从下面的代码可以看到优先确定Primary的，然后在根据权重来确定，Order与Priority只是不同规范定义的两种注解，两者效果是类似的。这里再额外说一下@Qualifier注解，如果beanName和@Qualifier一致，那么这个优先级更高，有兴趣的可以自己去源码探索一下，后面文章也会详细介绍@Qualifier这个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the autowire candidate in the given set of beans.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Looks for &#123;<span class="doctag">@code</span> <span class="doctag">@Primary</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@Priority</span>&#125; (in that order).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment"> * that match the required type, as returned by &#123;<span class="doctag">@link</span> #findAutowireCandidates&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> descriptor the target dependency to match against</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the name of the autowire candidate, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">determineAutowireCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, DependencyDescriptor descriptor)</span> &#123;</span><br><span class="line">Class&lt;?&gt; requiredType = descriptor.getDependencyType();</span><br><span class="line"><span class="type">String</span> <span class="variable">primaryCandidate</span> <span class="operator">=</span> determinePrimaryCandidate(candidates, requiredType);</span><br><span class="line"><span class="keyword">if</span> (primaryCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> primaryCandidate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">priorityCandidate</span> <span class="operator">=</span> determineHighestPriorityCandidate(candidates, requiredType);</span><br><span class="line"><span class="keyword">if</span> (priorityCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> priorityCandidate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fallback</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">candidateName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"><span class="keyword">if</span> ((beanInstance != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.resolvableDependencies.containsValue(beanInstance)) ||</span><br><span class="line">matchesBeanName(candidateName, descriptor.getDependencyName())) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p><img src="https://raw.githubusercontent.com/Lyotoc/Picphoto/main/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.drawio.png"></p><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>SpringMVC整个执行流程围绕<code>DispatcherServlet</code>展开。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;执行流程及生命周期&quot;&gt;&lt;a href=&quot;#执行流程及生命周期&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="后端" scheme="https://lyotoc.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Spring" scheme="https://lyotoc.github.io/tags/Spring/"/>
    
    <category term="技术" scheme="https://lyotoc.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="https://lyotoc.github.io/2022/07/21/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lyotoc.github.io/2022/07/21/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-07-21T08:32:14.000Z</published>
    <updated>2022-08-08T08:52:37.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><h2 id="结构全览"><a href="#结构全览" class="headerlink" title="结构全览"></a>结构全览</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/HashMap.png" alt="HashMap"></p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><table><thead><tr><th>字段名</th><th>说明</th><th>作用</th></tr></thead><tbody><tr><td>DEFAULT_INITIAL_CAPACITY</td><td>默认初始容量</td><td>初始化Map数组时的荣容量大小，该值必须为2的幂，默认为16</td></tr><tr><td>MAXIMUM_CAPACITY</td><td>最大容量</td><td>如果一个较大的值由带参数的构造函数中的任何一个隐式指定，则使用该值。必须是2的幂&lt;&#x3D; 1&lt;&lt;30。</td></tr><tr><td>DEFAULT_LOAD_FACTOR</td><td>默认负载因子</td><td>在构造函数没有指定时使用的额负载因子，默认为0.75</td></tr><tr><td>TREEIFT_THRESHOLD</td><td>桶计数阈值</td><td>使用树而不是列表的桶计数阈值。当将元素添加到至少有这么多节点的bin中时，bin将被转换为树。该值必须大于2且至少为8，以便与树移除中关于收缩后转换回普通箱的假设相匹配。默认为8</td></tr><tr><td>UNTREEIFY_THRESHOLD</td><td>取消桶计数阈值</td><td>在调整大小操作期间取消(拆分)bin树化的bin计数阈值。应该小于TREEIFY_THRESHOLD，并且在去除收缩检测时最多6个网格，默认为6</td></tr><tr><td>MIN_TREEIFY_CAPACITY</td><td>容器树形化最小容量</td><td>可将容器树形化的最小表容量。(否则，如果一个bin中有太多的节点，表将被调整大小。)应至少为4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突。</td></tr><tr><td>table</td><td></td><td>在第一次使用时初始化，并根据需要调整大小。在分配时，长度总是2的幂。(我们也允许在某些操作中长度为零，以允许当前不需要的引导机制。)</td></tr><tr><td>entrySet</td><td></td><td>保存缓存entrySet()</td></tr><tr><td>size</td><td></td><td>此映射中包含的键值映射的数量</td></tr><tr><td>modCount</td><td></td><td>结构化修改指的是改变HashMap中映射的数量或修改其内部结构(如rehash)。该字段用于使HashMap的集合视图上的迭代器快速失败。</td></tr><tr><td>threshold</td><td>下次扩容大小</td><td>下次扩容值的大小，该值由<strong>当前容量</strong> * <strong>负载因子</strong>得出</td></tr><tr><td>loadFactor</td><td>负载因子</td><td>table的负载因子</td></tr></tbody></table><h2 id="包含方法及构造器"><a href="#包含方法及构造器" class="headerlink" title="包含方法及构造器"></a>包含方法及构造器</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a><strong>构造器</strong></h3><ul><li><p><code>HashMap(int initialCapacity,float loadFactor)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参为初始化容量大小，及负载因子。对参数检查后赋值给成员变量，如下是调用的<code>tableSizeFor(int cap)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>以上方法中的<code>cap - 1</code>无符号位移再与自身位或运算的目的是为了获取比入参cap大的最小2的幂值，之所以减一是防止得出的结果扩大一倍。</p></li><li><p><code>HashMap(int initialCapacity)</code></p><p>构造一个带有指定初始容量和默认负载因子(0.75)的空HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><code>HashMap()</code></p><p>构造一个空的HashMap，使用默认的初始容量(16)和默认的负载因子(0.75)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>HashMap(Map&lt;? extends K,? extends V&gt; m)</code></p><p>构造一个新的HashMap，具有与指定Map相同的映射。HashMap使用默认负载因子(0.75)和足够容纳指定Map中的映射的初始容量创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>putMapEntries</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;<span class="comment">//前提是传入map的大小不为0，</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123;  <span class="comment">// 说明是拷贝构造函数来调用的putMapEntries，或者构造后还没放过任何元素</span></span><br><span class="line">            <span class="comment">//先不考虑容量必须为2的幂，那么下面括号里会算出来一个容量，使得size刚好不大于阈值。</span></span><br><span class="line">        <span class="comment">//但这样会算出小数来，但作为容量就必须向上取整，所以这里要加1</span></span><br><span class="line">            <span class="comment">// pre-size</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//如果小于最大容量，就进行截断；否则就赋值为最大容量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//虽然上面一顿操作猛如虎，但只有在算出来的容量t &gt; 当前暂存的容量(容量可能会暂放到阈值上的)时，才会用t计算出新容量，再暂时放到阈值上</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明table已经初始化过了；判断传入map的size是否大于当前map的threshold，如果是，必须要resize</span></span><br><span class="line">    <span class="comment">//这种情况属于预先扩大容量，再put元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">         <span class="comment">//循环里的putVal可能也会触发resize</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if (table &#x3D;&#x3D; null)分支，说明是HashMap的拷贝构造函数来调用的putMapEntries，或者是构造以后还没有放过任何元素，然后再调用putAll。</li><li>float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F这里的加1是因为，size &#x2F; loadFactor &#x3D; capacity，但如果算出来的capacity是小数，却又向下取整，会造成容量不够大，所以，如果是小数的capacity，那么必须向上取整。</li><li>算出来的容量必须小于最大容量MAXIMUM_CAPACITY，否则直接让capacity等于MAXIMUM_CAPACITY。</li><li>if (t &gt; threshold)这里的threshold成员实际存放的值是capacity的值。因为在table还没有初始化时（table还是null），用户给定的capacity会暂存到threshold成员上去（毕竟HashMap没有一个成员叫做capacity，capacity是作为table数组的大小而隐式存在的）。</li><li>else if (s &gt; threshold)说明传入map的size都已经大于当前map的threshold了，即当前map肯定是装不下两个map的并集的，所以这里必须要执行resize操作。</li><li>最后循环里的putVal可能也会触发resize操作。</li></ul></li></ul><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取当前key的value</p><h3 id="getNode-int-hash-Object-key"><a href="#getNode-int-hash-Object-key" class="headerlink" title="getNode(int hash,Object key)"></a>getNode(int hash,Object key)</h3><blockquote><p>该方法为final修饰的缺省类方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">//临时变量储存table数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    <span class="comment">//临时变量获取第一个元素</span></span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="comment">//n为table的长度</span></span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//如果table已经被初始化切table数组的长度大于0,在已知元素的查找位置上有元素则进入if判断</span></span><br><span class="line">    <span class="comment">//否则返回null,即没有找到元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//first元素存在,first元素即所需要查找的元素,直接返回first</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node </span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">// 如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着key没有匹配的键值对</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//// 如果是首节点是树节点，那么遍历树来查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//// 如果首节点不是树节点，就说明还是个普通的链表，那么逐个遍历比对即可 </span></span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">//循环判断当前的临时变量e是否与所需元素相同</span></span><br><span class="line">                <span class="comment">//相同则返回e元素,不相同则返回null</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))<span class="comment">// 比对时还是先看hash值是否相同、再看地址或equals</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ContainsKey-Object-key"><a href="#ContainsKey-Object-key" class="headerlink" title="ContainsKey(Object key)"></a>ContainsKey(Object key)</h3><blockquote><p>如果此映射包含指定键的映射，则返回true。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key,V value)"></a>put(K key,V value)</h3><blockquote><p> 将指定值与此映射中的指定键关联。如果映射之前包含键的映射，则替换旧值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-blooean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-blooean-evict" class="headerlink" title="putVal(int hash,K key,V value,boolean onlyIfAbsent,blooean evict)"></a>putVal(int hash,K key,V value,boolean onlyIfAbsent,blooean evict)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">     <span class="comment">// 如果存储元素的table为空，则进行必要字段的初始化，懒加载初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;<span class="comment">// 获取长度（16）</span></span><br><span class="line">     <span class="comment">// 如果根据hash值获取的结点为空，则新建一个结点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 此处 &amp; 代替了 % （除法散列法进行散列）</span></span><br><span class="line">        <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果新插入的结点和table中p结点的hash值，key值相同的话</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树结点的话，进行红黑树插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 代表这个单链表只有一个头部结点，则直接新建一个结点即可</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于8时，将链表转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">// 及时更新p</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在这个映射就覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 更改操作次数</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)  <span class="comment">// 大于临界值</span></span><br><span class="line">        <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">         <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在put值进入Node数组时，会先获取当前数组的长度，通过当前Key的hash值和当前数组最大索引位作与运算得出值应存放的数组索引位。当中需要注意的是，由于hashMap的扩容机制规定得出的Node数组容量始终为比当前cap大的最小2的幂值，因此n-1始终为一个全为1的奇数（二进制表示下），该数与key的hash作与运算，得出的结果只会在[0,n-1]之间。</p></li><li><p>若Node数组当前索引位下无值，则直接新建Node节点直接存放当前索引位。若有值，则说明插入key的hash与当前索引位上的元素的key的hash相同，此时比对两者的key是否是相同的，相同则将索引位上的p赋值给e。之后看p是否是红黑树，如果是的则进行红黑树插入，不是则说明是单链表，此时遍历该链表，当到达该链表尾节点时，将元素创建一个新的Node加入到链表成为新的尾节点，并检查该链表此时的长度是否不小于链表转红黑树的阈值长度。若不小于，则将该链表结构转换为红黑树，提高之后map查询时的效率。</p></li><li><p>若遍历完整个链表后，e的值不为空。即插入的元素的key与索引位相同，此时直接覆盖value。</p></li><li><p>之后再进行检查扩容等</p></li></ul><h3 id="Node-lt-K-V-gt-resize"><a href="#Node-lt-K-V-gt-resize" class="headerlink" title="Node&lt;K,V&gt;[] resize()"></a>Node&lt;K,V&gt;[] resize()</h3><blockquote><p>进行扩容机制，每次容量扩大至原有容量的一倍</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//创建临时变量指向现有Node数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//之后的临时变量初始化以便使用</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//大于Node数组最大容量则将下次扩容的阈值提至最大整型数</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将容量扩大一倍，将阈值扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">//阈值放在新的容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//都不满足时使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//新阈值初始化</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新阈值替换</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//新Node数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//懒加载</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历原有的Node数组，并将节点复制到新数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//清理原有数组索引位，之后交由GC进行垃圾回收</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//检查当前节点是否形成链表或红黑树，为空则没有</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//将e的hash和新的Node数组最大索引位与运算得出存放位置，并赋值该索引位</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//为红黑树则切割该树至新的索引位下</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20210323232622952.png" alt="算法推导1-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20210324150621823.png" alt="算法推导1-2"></p><h3 id="treeifyBin-Node-lt-K-V-gt-tab-int-hash"><a href="#treeifyBin-Node-lt-K-V-gt-tab-int-hash" class="headerlink" title="treeifyBin(Node&lt;K,V&gt;[] tab, int hash)"></a>treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap源码解析&quot;&gt;&lt;a href=&quot;#HashMap源码解析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码解析&quot;&gt;&lt;/a&gt;HashMap源码解析&lt;/h1&gt;&lt;h2 id=&quot;结构全览&quot;&gt;&lt;a href=&quot;#结构全览&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList源码解析</title>
    <link href="https://lyotoc.github.io/2022/07/20/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lyotoc.github.io/2022/07/20/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-07-20T03:38:09.000Z</published>
    <updated>2022-07-21T07:19:29.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h1><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220720114314084.png" alt="image-20220720114314084"></p><h2 id="继承实现类"><a href="#继承实现类" class="headerlink" title="继承实现类"></a>继承实现类</h2><p>从继承和实现的接口看，ArrayList继承了AbstractList抽象类，同时也就继承了集合的一众特性。</p><h2 id="ArrayList特性"><a href="#ArrayList特性" class="headerlink" title="ArrayList特性"></a>ArrayList特性</h2><h3 id="包含属性"><a href="#包含属性" class="headerlink" title="包含属性"></a>包含属性</h3><blockquote><p>ArrayList 是一个Java基于数组实现的长度可变的线性表，相比于数组需要在创建时先指定好容量大小，不能对容量大小做动态调整，ArrayList能很好的解决这一问题，做到根据元素多少作容量的动态调整。</p></blockquote><table><thead><tr><th align="left">属性名</th><th>说明</th><th>作用或影响</th></tr></thead><tbody><tr><td align="left">DEFAULT_CAPACITY</td><td>默认容量</td><td>在无参构造器即未指定容量大小时的默认初始容量，注意这里并不是在使用无参构造器创建对象的时候赋值的，在创建时只会将对象指向DEFAULTCAPACITY_EMPTY_ELEMENTDATA的内存地址，在add()时才会新建对象。</td></tr><tr><td align="left">EMPTY_ELEMENTDATA</td><td>空容量共享数组实例</td><td>被static final修饰，随类加载创建的一个空的Object数组，用于构造器创建时入参 incapacity或Collection的长度为0场景下赋予对象的默认共享数组。</td></tr><tr><td align="left">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</td><td>默认空共享数值</td><td>用于默认大小的空实例的共享空数组实例。我们将它与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时膨胀多少。</td></tr><tr><td align="left">elementData</td><td>数据缓冲区</td><td>被transient修饰，ArrayList的元素就被存在这里，当添加第一个元素时，任何带有elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组列表将被扩展为DEFAULT_CAPACITY。</td></tr><tr><td align="left">size</td><td>数组列表大小</td><td>数组列表的大小(它包含的元素的数量)</td></tr><tr><td align="left">MAX_ARRAY_SIZE</td><td>数组最大长度</td><td>要分配的数组的最大大小。有些VMs在数组中保留一些头字。分配更大的数组可能导致OutOfMemoryError:请求的数组大小超过虚拟机限制【Integer.MAX_VALUE - 8】</td></tr><tr><td align="left">modCount</td><td></td><td>这个列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，或者以这样一种方式打乱列表，使正在进行的迭代可能产生不正确的结果。 该字段由迭代器和listIterator方法返回的迭代器和列表迭代器实现使用。如果该字段的值发生意外变化，迭代器(或列表迭代器)将抛出ConcurrentModificationException，以响应next、remove、previous、set或add操作。这提供了快速失败的行为，而不是在迭代期间面对并发修改时的不确定行为。 子类使用此字段是可选的。如果一个子类希望提供快速失败的迭代器(和列表迭代器)，那么它只需要在它的add(int, E)和remove(int)方法(以及它覆盖的导致列表结构修改的任何其他方法)中增加这个字段。对add(int, E)或remove(int)的单个调用向该字段添加的值不能超过一个，否则迭代器(和列表迭代器)将抛出虚假的concurrentmodificationexception。如果实现不希望提供快速失败迭代器，则可以忽略此字段。<strong>在AbstractList声明,由protected transient修饰</strong></td></tr></tbody></table><h3 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h3><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>add方法有两个重写的重载方法</p><ul><li>方法一：<code>boolean add(E e)</code></li><li>方法二：<code>void add(int index, E element)</code></li></ul><p>方法一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用了<code>ensureCapacityInternal(int minCapacity)</code>方法</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220720152414946.png" alt="image-20220720152414946"><code>ensureCapacityInternal</code>调用的<code>calculateCapacity</code>比较<code>elementData</code>和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>是否是同一个对象，是则返回<strong>DEFAULT_CAPACITY</strong>和<strong>minCapacity</strong>较大的一个。不是则直接返回 <strong>minCapacity</strong>,返回的值作为<code>ensureExplicitCapacity</code>的入参</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220720153822448.png" alt="image-20220720153822448"></p><blockquote><p><code>modCount</code>用于记录集合的修改次数，即每次add或者remove的时候它的值都会加1。</p></blockquote><p>主要逻辑在<code>grow()</code>中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新容量[newCapacity]由oldCapacity扩展为之前的1.5倍，初次add时由于<code>elementData.length</code>等于0,即newCapacity等于0，newCapacity小于minCapacity,则直接使用minCapacity调用Arrays.copyOf创建数组。总之，取大的那个，当newCapacity大于MAX_ARRAY_SIZE时，则处理为Integer.MAX_VALUE或者MAX_ARRAY_SIZE。</p><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法与方法一出入在于先检查index是否在[0,size)区间内，再执行<code>ensureCapacityInternal</code>逻辑检查是否需要扩容，以及使用<code>native</code>方法实现index位置插入式填充。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>remove()有两个重写的重载方法</p><ul><li>方法一：<code>remove(int index)</code></li><li>方法二：<code>remove(Object o)</code></li></ul><p>方法一用于删除位于列表中指定位置的元素。将所有后续元素向左平移(从它们的下标减去1)。其中System.arraycopy(Object[] src,int srcPos,Object[] dest,int destPos,int length),将elementData的index+1索引位后的元素(包含index+1)挪到index索引位开始后 numMoved位置。即所有index后的元素向前挪一位，并将elementData最后一位置为null(由于indx后的所有元素都向前挪了一位，此时size-1和size-2上的元素相同，需要将最后一位也就是size-1上的元素置空)。置空后等待GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法二，如果指定元素在列表中出现，则从列表中删除第一个匹配项。如果列表不包含该元素，则该元素不变。更正式的是，删除索引为i的元素，这样(o&#x3D;&#x3D;null ?Get (i)&#x3D;&#x3D;null: o.equals(Get (i))(如果存在这样的元素)。如果这个列表包含指定的元素(或者等效地，如果这个列表因调用而改变)，则返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>从列表中删除所有元素。这个调用返回后，列表将为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// clear to let GC do its work</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">           elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h4><p>addAll()有两个重写的重载方法</p><ul><li>addAll(Collecion c)</li><li>addAll(int index,Collection c)</li></ul><p>方法一按照指定集合的Iterator返回的顺序，将指定集合中的所有元素追加到列表的末尾。如果在操作过程中修改了指定的集合，则此操作的行为为未定义。(这意味着如果指定的集合是这个列表，并且这个列表非空，则此调用的行为是未定义的。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法二是从指定位置开始，将指定集合中的所有元素插入到此列表中。将当前位于该位置的元素(如果有的话)和所有后续元素向右移动(增加它们的索引)。新元素将按照指定集合的迭代器返回的顺序出现在列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="removeAll-Collection-c"><a href="#removeAll-Collection-c" class="headerlink" title="removeAll(Collection c)"></a>removeAll(Collection c)</h4><p>从此列表中移除指定集合中包含的所有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="retainAll-Collection-c"><a href="#retainAll-Collection-c" class="headerlink" title="retainAll(Collection c)"></a>retainAll(Collection c)</h4><p>仅保留此列表中包含在指定集合中的元素。换句话说，从列表中删除指定集合中不包含的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当中使用的<code>batchRemove(Collection c,boolean complement)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">            <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">            <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">                <span class="comment">// clear to let GC do its work</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = <span class="literal">null</span>;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="listIterator-int-index"><a href="#listIterator-int-index" class="headerlink" title="listIterator(int index)"></a>listIterator(int index)</h4><p>返回一个列表迭代器，从列表中指定的位置开始，遍历列表中的元素(以正确的顺序)。指定的索引指示对next的初始调用将返回的第一个元素。对previous的初始调用将返回具有指定索引减1的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="listIterator"><a href="#listIterator" class="headerlink" title="listIterator()"></a>listIterator()</h4><p>返回列表中元素的列表迭代器(按正确的顺序)。 返回的列表迭代器是快速失败的[文档中写的是fail-fast,即快速失败。在迭代器创建后的任何时间列表在结构上被修改，除了通过迭代器自己的remove或add方法，迭代器将抛出ConcurrentModificationException。迭代器的快速失败行为应该只用于检测错误]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上两个方法返回的都是ListItr，该类是ArrayList的一个私有类，继承了Itr[ArryList私有的迭代器]，实现了ListIterator</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220721134235051.png" alt="图2-1"></p><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator()"></a>Iterator()</h4><blockquote><p>返回一个迭代器，以正确的顺序遍历列表中的元素。 返回的迭代器是快速失败的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上返回的迭代器为ArrayList内的AbstractList.Itr优化版本,具体结构及内部方法如上图[图2-1]所示。</p><h4 id="subList"><a href="#subList" class="headerlink" title="subList()"></a>subList()</h4><blockquote><p>返回在指定的frommindex(包含)和toIndex(不包含)之间的列表部分的视图。(如果frommindex和toIndex相等，则返回的列表为空。)返回的列表由该列表支持，因此返回列表中的非结构性更改会反映在该列表中，反之亦然。返回的列表支持所有可选列表操作。 这个方法消除了显式范围操作(数组中常见的那种类型)的需要。通过传递子列表视图而不是整个列表，任何需要列表的操作都可以用作范围操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上调用了<code>subListRangeCheck(int fromIndex,int toIndex,int size)</code>方法，如下，用于检查输入区间是否是可执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subListRangeCheck</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                                               <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>subList()返回通过入参使用构造器，创建一个SubList类，具体结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220721140805540.png" alt="image-20220721140805540"></p><p>subList并未在内存上实际新建结构存储数据，只是记录了索引区间、偏移量，实际上使用的仍然是ArrayList中的elementData来存取元素。其中的各种方法在SubList解析中说明。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>该方法为实现<code>Iterable</code>接口重写的方法[之所以说重写是因为该方法在<code>Iterable</code>接口中被<code>default</code>修饰]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> E[] elementData = (E[]) <span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            action.accept(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法的入参是一个Consumer消费型函数式接口，具体逻辑就是利用函数式接口动态的编写action操作当前List中的每一个元素，</p><h4 id="RemoveIf-Predicate-lt-super-E-gt-filter"><a href="#RemoveIf-Predicate-lt-super-E-gt-filter" class="headerlink" title="RemoveIf(Predicate&lt;? super E&gt; filter)"></a>RemoveIf(Predicate&lt;? super E&gt; filter)</h4><p>该方法重写了<code>Collection</code>的默认方法，删除此集合中满足给定谓词的所有元素。迭代期间或由谓词引发的错误或运行时异常会传递给调用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="comment">// figure out which elements are to be removed</span></span><br><span class="line">    <span class="comment">// any exception thrown from the filter predicate at this stage</span></span><br><span class="line">    <span class="comment">// will leave the collection unmodified</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">removeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BitSet</span> <span class="variable">removeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">anyToRemove</span> <span class="operator">=</span> removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="literal">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="replaceAll-UnaryOperator-lt-E-gt-operator"><a href="#replaceAll-UnaryOperator-lt-E-gt-operator" class="headerlink" title="replaceAll(UnaryOperator&lt;E&gt; operator)"></a>replaceAll(UnaryOperator&lt;E&gt; operator)</h4><p>该方法重写了List接口的默认方法，将列表中的每个元素替换为对该元素应用操作符的结果。操作符引发的错误或运行时异常会传递给调用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="sort-Comparator-lt-super-E-gt-c"><a href="#sort-Comparator-lt-super-E-gt-c" class="headerlink" title="sort(Comparator&lt;? super E&gt; c)"></a>sort(Comparator&lt;? super E&gt; c)</h4><p>该方法重写了List接口的默认方法，入参是一个Comparator,通过自定义的比较规则对容器内元素进行定制化排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="包含类"><a href="#包含类" class="headerlink" title="包含类"></a>包含类</h3><h4 id="Itr"><a href="#Itr" class="headerlink" title="Itr"></a>Itr</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220721151214328.png" alt="image-20220721151214328"></p><h4 id="ListItr"><a href="#ListItr" class="headerlink" title="ListItr"></a>ListItr</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220721151759473.png" alt="image-20220721151759473"></p><h4 id="SubList"><a href="#SubList" class="headerlink" title="SubList"></a>SubList</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220721151844959.png" alt="image-20220721151844959"></p><h4 id="ArrayListSpliterator"><a href="#ArrayListSpliterator" class="headerlink" title="ArrayListSpliterator"></a>ArrayListSpliterator</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220721151920859.png" alt="image-20220721151920859"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList源码解析&quot;&gt;&lt;a href=&quot;#ArrayList源码解析&quot; class=&quot;headerlink&quot; title=&quot;ArrayList源码解析&quot;&gt;&lt;/a&gt;ArrayList源码解析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsde</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础全览</title>
    <link href="https://lyotoc.github.io/2022/07/15/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E8%A7%88/"/>
    <id>https://lyotoc.github.io/2022/07/15/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E8%A7%88/</id>
    <published>2022-07-15T05:35:45.000Z</published>
    <updated>2022-07-20T02:34:12.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><h3 id="Java的配置"><a href="#Java的配置" class="headerlink" title="Java的配置"></a>Java的配置</h3><ul><li><p>Java的运行机制</p><ul><li><p>java语言运行机制及运行过程</p><ul><li>Java语言运行机制及运行过程.md</li></ul></li><li><p>java基础图谱</p></li><li><p>java8.0概括图谱</p></li></ul></li><li><p>JDK的安装</p><ul><li>Java开发工具</li><li>JRE</li></ul></li><li><p>环境变量的配置</p><ul><li>path 配置至 bin目录</li><li>JAVA_HOME 配置至jdk目录</li></ul></li></ul><h3 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h3><h3 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h3><ul><li><p>基础语法</p><ul><li><p>注释及编译原理</p><ul><li><p>注释的使用</p><ul><li><p>单行注释  &#x2F;&#x2F; ……………………</p></li><li><p>多行注释  &#x2F;* ……………………*&#x2F;</p></li><li><p>文档注释 </p><p>java-文档注释    格式： &#x2F;**             @author  指定java程序的作者              @version 指定源文本的版本             等等……             *&#x2F;    文档注释的使用：         注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。         dos命令调用javadoc解析文档注释：javadoc -d filename(生成的文件夹名字) -author -version target.java(需要解析的Java文件)</p></li></ul></li><li><p>编译字节码文件</p><p>1.  一个.java文件中可编写多个类，当时只能编写一个public类2.编译后生成一个或者多个类文件，依据源代码创建的类的数目，且类文件与所创建的类文件名同名。</p></li></ul><p> </p></li><li><p>基础语法结构</p><ul><li><p>关键字&amp;保留字</p></li><li><p>标识符及命名规则</p><p>Java中的名称命名规范：    包名：多单词组成时所有字母都小写：xxyyzz    类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz    变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz    常量名：所有之母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p></li><li><p>变量</p><ul><li><p>变量类型</p><ul><li><p>基本数据类型</p><ul><li><p>数值型</p><ul><li>整型{byte，short，int，long} &#x2F;*long型的变量数值以L或l结尾</li><li>浮点型{float，double}&#x2F;*float型的变量数值以F或f结尾</li></ul></li><li><p>字符串{char}&#x2F;<em>通常使用一对’’包含  1.可以直接使用’\u</em>***’直接转译字符,     2.通过调用charAt(i)使用字符串中某一特定角标对应的字符【i表示所需字符的索引】</p></li><li><p>布尔型{boolean}</p></li><li><p>进制问题</p><ul><li>进制之间的问题（Java）.md</li></ul></li></ul></li><li><p>引用数据类型</p><ul><li>类{class}</li><li>接口{interface}</li><li>数组{[]}</li></ul></li></ul></li></ul></li><li><p>运算符</p><ul><li><p>算术运算符</p><ul><li>Subtopic</li></ul></li><li><p>比较运算符</p><ul><li>Subtopic</li></ul></li><li><p>逻辑运算符</p><ul><li>Subtopic</li></ul></li><li><p>位运算符</p><ul><li>‘&gt;&gt;&gt;’右移，右移一位&#x2F;2</li><li>‘&lt;&lt;&lt;’左移，左移一位*2</li></ul></li><li><p>三元运算符</p><p>****************a ? x : y  x与y必须是同一个类型的参数</p><ul><li>a?x:y 判断句子，x为true y为false</li></ul></li></ul></li><li><p>分支结构</p><ul><li><p>if-else</p><p>逻辑得理清，遇到包含或者或者有交集的判断句得理清楚所选的结构是否合理，小范围的判断与大范围的判断是否会耦合</p></li><li><p>switch-case</p><p>switch表达式中只能使用的六种数据类型：short、char、int、枚举、byte、String ;</p></li></ul></li><li><p>循环结构</p><ul><li>for循环</li><li>while循环</li><li>do-while循环</li></ul></li></ul></li></ul></li><li><p>数组 </p><ul><li><p>数组的声明与初始化</p><ul><li><p>静态初始化</p><p><strong>静态初始化</strong>&#x2F;&#x2F;初始化一个整型的长度为5的一维数组   int [] exp &#x3D; new int []{1,2,3,4,5};PS:在java中数组初始化必须定义长度，否则在编译过程中会报空指针异常的错误</p></li><li><p>动态初始化</p><p>**动态初始化&#x2F;&#x2F;初始化一个整型的长度为5的一维数组 int [] exp &#x3D; new int[5];&#x2F;&#x2F;在初始化过程中，</p></li></ul></li><li><p>数组的默认初始化值</p><ul><li><p>基本数据类型</p><ul><li>整型（byte、short、long、int、）：0</li><li>浮点型(float、double)：0.0</li><li>字符串型(char):0或’\u0000’非’0’：</li><li>布尔型(boolean):false;</li></ul></li><li><p>引用数据类型</p><ul><li>null</li></ul></li></ul></li><li><p>数组的内存解析</p><ul><li>内存的简化结构</li><li>一维数组的简化结构</li></ul></li><li><p>二维数组的理解</p><p>**二维数组相当于是 一个一维数组的元素又是一个一维数组 </p><ul><li><p>初始化</p><ul><li><p>静态初始化</p><p>**静态初始化一个二维数组    int [][] nums &#x3D; new int [] [] {{1,2,3},{4,5},{6,7,8}};    或者    int [][] nums &#x3D; {{1,2,3},{4,5},{6,7,8}};    int[] nums[] &#x3D; {{1,2,3},{4,5},{6,7,8}};    int [] nums[] &#x3D; new int [] [] {{1,2,3},{4,5},{6,7,8}};</p></li><li><p>动态初始化</p><p>**动态初始化一个二维数组    int [][] nums &#x3D; new int [2][3];    int [][] nums &#x3D; new int [2][];</p></li></ul></li><li><p>数组的默认初始化值</p><p><em><strong>初始化方式一：  比如：int[][]arr &#x3D; new int [4][3];    外层元素的初始化值：地址值    内层元素的初始化值为：与一维数组初始化情况相同</strong></em>针对初始化方式二：比如：int [][]arr &#x3D; new int [4][]    外层元素的初始化值为：null    内层元素的初始化值为：不能调用，否则报错【报错：空指针异常】    </p></li><li><p>二维数组的内存解析</p></li></ul></li><li><p>数组相关</p><ul><li><p>数组ppt</p><ul><li>尚硅谷_宋红康_第3章_数组.pdf</li></ul></li><li><p>数组排序算法</p><p>***    1.快速排序      **常用    2.归并排序      **常用    3. 堆排序        **常用    4.希尔排序    5.插入排序    6.选择排序    7.计数排序    8. 桶排序    9.冒泡排序    10.基数排序</p></li></ul></li></ul></li><li><p>面向对象</p><ul><li><p>面向对象的结构及特点</p><ul><li><p>Java类及类的成员</p><ul><li>属性</li><li>方法</li><li>构造器</li><li>代码块</li><li>内部类</li></ul></li><li><p>面向对象的三大特征</p><ul><li>封装性</li><li>继承性</li><li>多态性</li></ul></li><li><p>其他关键字</p><ul><li><p>this</p><p>******方法中的变量参数与类中的属性（即成员变量）相同时，使用前缀this.表示类的成员变量 *<em><strong><strong>在实际的调用过程中，this表示被调用的对象的方法 通常过程中被省略</strong></strong></em>构造器调用 this( ) ，不能递归</p></li><li><p>super</p><p>在子类调用父类的构造器、属性及其方法 –首先调用所在上级父类中检索该构造器、属性及其方法，若没有则逐级上升</p></li><li><p>instanceof</p><ul><li><p>关键字的使用</p><p>比如：          a instanceof A:判断对象a是否是类A的实例，如果是，返回true;                                                                           如果不是，返回false；         if(p2 instanceof Woman){ }</p></li><li><p>使用情境</p><p>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。****************************************************************    如果 a instanceof A 返回true，则a instanceof B 也返回true.    其中，类B是类A的父类。</p></li></ul></li><li><p>static</p><ul><li><p>关键字的使用</p><p>***************************   2020年8月12日 –可以用来修饰类的结构：属性、方法、代码块、内部类；    –  使用static 修饰属性：静态变量             — 属性按是否使用static 修饰，又分为：静态属性vs非静态属性（实例变量）                      实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性是，不会导致其他对象的属性值的修改。                      静态变量：我们创建了类的多个对象，多个对象共享一个静态变量。当通过某一个修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。             — static修饰属性的其他说明：                      —-静态变量随着类的加载而加载，可以通过“类.静态变量”的方式进行调用                      —-静态变量的加载要早于对象的创建                      —-由于类只会加载一次，则静态变量在内存中也只会加载一次（存在一份），存在方法区的静态域中。                      —-                类变量          实例变量                               类          yes                no                              对象        yes                yes    –使用static修饰方法：静态方法                      –随着类的加载而加载，可以通过”类.静态方法“的方式进行调用                      –          静态方法     非静态方法                           类         yes             no                           对象      yes             yes                      静态方法中，只能调用静态的方法或者属性                      非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或者属性    –static注意点：         在静态的方法内，不能使用this关键字、super关键字         关于静态属性和静态方法的使用，从生命周期的角度去理解              </p></li><li><p>类变量与实例变量内存解析</p></li><li><p>静态相关的设计模式</p></li><li><p>拓展性</p><ul><li><p>main中静态的体现</p><ul><li>Subtopic</li></ul></li></ul></li></ul></li><li><p>final</p><ul><li><p>可用来修饰</p><ul><li>类</li><li>方法</li><li>变量</li></ul></li><li><p>final</p></li></ul></li><li><p>abstract</p><ul><li><p>抽象类</p><p>抽象类****************–被关键字 abstract 修饰的类–抽象类不能被实例化–抽象类一定有构造器</p></li><li><p>抽象方法</p><p>******************–抽象方法只能被定义在抽象类中–抽象方法的定义         public abstract void test ();–抽象方法在继承的子类中必须全被实现</p></li></ul><p> </p></li><li><p>interface</p><ul><li><p>接口</p><ul><li><p>如何定义的？可以包含哪些东西？</p><ul><li><p>JDK7及以前</p><ul><li>全局变量</li><li>抽象方法</li></ul></li><li><p>JDK8增加</p><ul><li>静态方法</li><li>默认方法</li></ul></li></ul></li><li><p>接口体现了多态性</p></li><li><p>接口是如何应用的？</p><ul><li>让类去实现（implements）</li><li>实现类必须实现接口定义的所有方法，才能实例化。</li><li>不实例化则子类只能声明为抽象类</li></ul></li><li><p>接口与接口有什么关系？</p><p>继承</p></li><li><p>接口和类有什么关系？</p><p>实现</p></li><li><p>接口不能定义构造器</p></li><li><p>接口可以被多实现</p></li></ul></li></ul></li><li><p>import</p><p>导包(import) *<em><strong>使用import显式导包，具体到类、接口</strong></em><strong>使用static import 具体到属性、方法</strong>***除此以外，还可隐式导包,即直接写出路径，如：com.util.ToNymber;</p></li><li><p>package</p><p>申明当前代码文件所在的包目录</p></li></ul></li></ul></li><li><p>对象的创建&amp;使用</p><ul><li><p>内存解析</p><ul><li>对象的内存解析</li><li>对象数组的内存解析</li></ul></li><li><p>对象变量的内存位置</p></li><li><p>匿名对象</p><p>匿名对象——即不声明对象名，直接实例化一个对象实体。例如： new student().xXX();</p></li></ul><p>             </p></li><li><p>方法</p><ul><li><p>方法的重载</p><p>两同一不同———在同一个类中、有同一个方法名。形参列表不同</p></li><li><p>方法的重写</p><p>**********方法的重写基于子类与父类的关系    - 重写的规定：             – 方法体的声明：权限修饰符 返回值类型 方法名（形参列表）{                                       &#x2F;&#x2F;方法体}                             –PS ：在子类中的叫重写的方法  在父类中叫重写的方法               – 子类重写的方法的方法名和形参列表与父类中被重写的方法名及形参列表相同             – 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符                 — 子类中不能重写父类中的private的方法             – 返回值的类型：                 &gt; 若父类杯中重写的返回值为void，则子类中的重写的返回值只能为void                 &gt;  若父类中的方法返回值为其他具体引用数据类型，则子类重写的方法的返回值为该具体类型或其子类                 &gt; 若父类中的方法返回值为基本数据类型，则子类重写的方法的返回值为该基本数据类型             –子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></li><li><p>可变个数的形参</p><p>***public void getName(String … name){}<strong>对形参的个数不定义，形参的个数可以为0-多个</strong>与同一个类之间的不同参数类型(或个数不同)的同名方法构成重载</p></li><li><p>方法的递归</p><p>&#x2F;** 自己调用自己，隐性的循环结构，需引导递归到正确的方向，避免陷入死循环</p></li></ul></li><li><p>封装与隐藏</p><ul><li><p>封装性的体现</p><p>** 封装性的体现依赖于权限修饰符</p></li><li><p>权限修饰符</p><p>**4种权限修饰符（从小到大排列）private,缺省，protected,public</p><ul><li>Subtopic</li></ul></li></ul></li><li><p>构造器</p><ul><li><p>特点</p><ul><li>每个类都有自己的构造器</li><li>构造器不同于方法</li><li>一个类可以定义多个构造器(构造器的重载)</li></ul></li></ul></li><li><p>代码块</p><ul><li><p>作用</p><p>用来初始化类、对象</p></li><li><p>修饰</p><p>只能用static修饰*************{}或者static {}</p></li><li><p>静态代码块&amp;非静态代码块</p><p>*<strong><strong><strong><strong><strong><strong>静态代码块–随着类的加载而加载，且只会加载一次</strong></strong></strong></strong></strong></strong>非静态代码块–随着类的加载而加载，每创建一个对象都会加载一次。</p></li></ul></li><li><p>内部类</p></li><li><p>包装类</p><ul><li><p>包装类的使用</p><p>********     针对八种基本数据类型定义相应的引用类型–包装类（封装类）    有了类的特点，就可以调用类中的方法，Java才是真正的面向对象    包装类对应操作基本数据类型    Integer—–int    Double—-double    Float —–float    Boolean—-boolean    Long ——long    Character—char    Byte——–byte    Short——short&#x2F;<strong><strong><strong><strong><strong>除布尔类型与字符串类型之外的所有包装类的父类都是Number</strong></strong></strong></strong></strong>*****&#x2F;</p></li><li><p>String、包装类与基本数据类型之间的相互转换</p><ul><li><p>包装类转化</p><ul><li>包装类转化.xlsx</li></ul></li><li><p>String与包装类及基本数据类型的相互装换</p><p><strong><strong><strong><strong><strong>因为包装类与基本数据类型之间有自动拆箱与封箱的功能，所以这里将基本数据类型与包装类规划为一类，只讨论他们与String类之间的类型转换，以下统一称作包装类</strong></strong></strong></strong></strong>*******–包装类装换成String    int num &#x3D; 10;    &#x2F;&#x2F;方式一：          String str1 &#x3D; num+””; &#x2F;&#x2F;直接使用“”连接起来    &#x2F;&#x2F;方式二：         调用String重载的ValueOf(Xxx xxx )         float f1 &#x3D; 12.3f;         String str2 &#x3D; String.valueOf(f1); &#x2F;&#x2F;结果为“12.3”–String转换成包装类         String str3 &#x3D; “23”         int num2 &#x3D; Integer.parseInt(str3);&#x2F;&#x2F;对于String转换成基本数据类型，可能会报错NumberFormatException</p></li></ul><p>  </p></li><li><p>自动拆箱与自动装箱</p><ul><li><p>定义</p><p>***********    能够实现基本数据类型与包装类之间的相互赋值装换         例如：                 int i &#x3D; 5;                 Integer j &#x3D; i ; &#x2F;**直接将基本数据类型赋值给包装类对象                 int num &#x3D; j;  &#x2F;**直接将包装类赋值给基本数据类型，拆箱动作自动完成</p></li><li><p>自动装箱的拓展知识</p><p>*********************    在 Integer 中为了提高代码的运行速度，在内部定义了一个静态的内部类IntegerCache中定义了Integer[ ]    其中数组元素包含了-128~127整型值。    比如：             Integer num1 &#x3D; 1;             Integer num2 &#x3D; 1;             sysout(num1 &#x3D;&#x3D; num2);   &#x2F;&#x2F;true 此时直接引用IntegerCache内部类中的Integer[ ]数组中的1，所以此时两者的地址值指向的是同一个</p></li></ul></li></ul><p>                   </p></li><li><p>拓展</p><ul><li><p>JVM内存结构</p></li><li><p>变量的赋值传递机制</p><ul><li><p>形参是基本数据类型</p><ul><li>将实参基本数据类型变量的“数据值”传递给形参</li></ul></li><li><p>形参是引用数据类型</p><ul><li>将实参引用数据类型变量的“地址值”传递给形参</li></ul></li></ul></li></ul></li></ul></li><li><p>面向对象进阶</p><ul><li><p>类的继承性</p><p><em><strong><strong>子类会继承父类的所有属性及方法          父类的构造器可以通过super方法进行调用         父类中的私有属性（private）子类也会继承，但由于封装性的影响，不可在子类中调用父类的私有属性</strong></strong></em> </p></li><li><p>多态性</p><ul><li><p>理解</p><p>可以理解为一个事物的多种形态 </p></li><li><p>何为多态性</p><p>*********    对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）    举例：             -  Person p &#x3D; new Man();                 Object obj &#x3D; new Date():              父类直接引用实例化一个子类的对象***********************    - 多态使用时，当调用子父类同名的参数的方法时，实际执行的时子类重写父类的方法—-虚拟方法的调用    -不能调用子类所特有的方法、属性；    -有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中申明的属性和方法。子类特有的属性和方法不能调用；    -向下转型，使用强制类型装换符         如：Man m1 &#x3D; (Man)p2;         –使用强转时，可能出现ClassCastException的异常，             </p></li><li><p>异常</p><p>—————对于抛出ClassCastException时，Java方面引入了instanceof关键字</p></li></ul></li><li><p>Object类</p><ul><li><p>定义</p><p>*******************************    Object类是所有Java类的根父类         - 如果在类的声明中未使用extends关键字指明其父类，则默认未Java.lang.Object类         - Object类中的功能（属性、方法）就具通用性            –属性：无            –方法：equals（）&#x2F;toString( )&#x2F;getClass()&#x2F;hashcode()&#x2F;clone()&#x2F;finalize()&#x2F;wait()&#x2F;notify()&#x2F;notifyAll()         - Object类只声明了一个空参的构造器</p></li></ul></li><li><p>单例模式</p><ul><li><p>定义</p><p>所谓类的单例模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p></li><li><p>类型</p><ul><li><p>饿汉式</p><ul><li>具体实现</li><li>优缺点</li></ul></li><li><p>懒汉式</p><ul><li>具体实现</li><li>优缺点</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><p>基本概念</p><ul><li><p>程序</p><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p></li><li><p>进程</p><p>程序的一次执行过程，它是动态的，有它自身的产生、存在和消亡的过程。—-生命周期</p></li><li><p>线程</p><p>进程可以分化为线程，是一个程序内部的一条执行路径。    **若一个进程同一时间并行执行多个线程，就是支持多线程的。    **线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小    **一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间→它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p></li></ul></li></ul><h2 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h2><h3 id="Eclipse使用"><a href="#Eclipse使用" class="headerlink" title="Eclipse使用"></a>Eclipse使用</h3><ul><li><p>使用基础</p><ul><li>Eclipse使用基础.md</li></ul></li><li><p>Debug调试</p><p>*设置断点调试</p></li></ul><h2 id="家庭记账管理系统"><a href="#家庭记账管理系统" class="headerlink" title="家庭记账管理系统"></a>家庭记账管理系统</h2><h3 id="家庭记账管理-md"><a href="#家庭记账管理-md" class="headerlink" title="家庭记账管理.md"></a>家庭记账管理.md</h3><h2 id="项目二：客户管理系统"><a href="#项目二：客户管理系统" class="headerlink" title="项目二：客户管理系统"></a>项目二：客户管理系统</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC核心详解</title>
    <link href="https://lyotoc.github.io/2022/07/07/JDBC%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lyotoc.github.io/2022/07/07/JDBC%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-07T01:27:43.000Z</published>
    <updated>2022-07-07T05:54:00.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h1><h2 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h2><p>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。</p><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/202009302218598.png" alt="在这里插入图片描述"></p><h2 id="Java中的数据存储技术"><a href="#Java中的数据存储技术" class="headerlink" title="Java中的数据存储技术"></a>Java中的数据存储技术</h2><p>在Java中，数据库存取技术可分为如下几类：</p><p>JDBC直接访问数据库</p><p>JDO (Java Data Object )技术</p><p>第三方O&#x2F;R工具，如Hibernate, Mybatis 等</p><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p><h2 id="JDBC介绍"><a href="#JDBC介绍" class="headerlink" title="JDBC介绍"></a>JDBC介绍</h2><ul><li><p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</p></li><li><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p></li><li><p>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p></li><li><p>如果没有JDBC，那么Java程序访问数据库时是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/Untitled.png" alt="Untitled"></p></li><li><p>有了JDBC可以达到这样的效果</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220707093929116.png" alt="Untitled"></p></li><li><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220707093947299.png" alt="Untitled"></p><p>JDBC制定了一组规范的接口，各大数据库厂商都提供的自家数据库JDBC驱动</p><p>JDBC驱动：就是JDBC接口的实现类</p><p>所以，JAVA程序员在操作数据库时，只要加载对应数据库驱动后</p><p>调用JDBC定义的接口方法，就可以实现对各个数据的操作</p><p>不需要去了解数据库厂家的具体实现和细节</p></li></ul><h2 id="JDBC体系结构"><a href="#JDBC体系结构" class="headerlink" title="JDBC体系结构"></a>JDBC体系结构</h2><ul><li>JDBC接口（API）包括两个层次：<ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul></li></ul><blockquote><p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p><p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程</strong></p></blockquote><h3 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222019969.png" alt="aa"></p><blockquote><p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><h1 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h1><h2 id="要素一：Driver接口实现类"><a href="#要素一：Driver接口实现类" class="headerlink" title="要素一：Driver接口实现类"></a>要素一：Driver接口实现类</h2><h3 id="Driver接口介绍"><a href="#Driver接口介绍" class="headerlink" title="Driver接口介绍"></a>Driver接口介绍</h3><ul><li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动： com.mysql.jdbc.Driver</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222041978.png" alt="尚硅谷_宋红康_JDBC.assets/1555576157618.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222055877.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oOiKsgU5-1601475477254)(尚硅谷_宋红康_JDBC.assets/1555576170074.png)]"></p><h3 id="加载与注册JDBC驱动"><a href="#加载与注册JDBC驱动" class="headerlink" title="加载与注册JDBC驱动"></a>加载与注册JDBC驱动</h3><ul><li>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名Class.forName(“com.mysql.jdbc.Driver”);</li><li>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序<ul><li>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</li><li>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2020093022215272.png" alt="qqq"></p><h2 id="要素二：URL"><a href="#要素二：URL" class="headerlink" title="要素二：URL"></a>要素二：URL</h2><ul><li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p></li><li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。</p><ul><li><p>jdbc:子协议:子名称</p><ul><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名</li></ul></li><li><p>举例：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222202882.png" alt="aaa"></p></li></ul></li><li><p><strong>几种常用数据库的 JDBC URL</strong></p><ul><li>MySQL的连接URL编写方式：<ul><li>jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值</li><li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu</li><li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li><li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu?user&#x3D;root&amp;password&#x3D;123456</li></ul></li><li>Oracle 9i的连接URL编写方式：<ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li>SQLServer的连接URL编写方式：<ul><li>jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称</li><li>jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;atguigu</li></ul></li></ul></li></ul><h2 id="要素三：用户名和密码"><a href="#要素三：用户名和密码" class="headerlink" title="要素三：用户名和密码"></a>要素三：用户名和密码</h2><ul><li>user,password可以用“属性名&#x3D;属性值”方式告诉数据库</li><li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li></ul><h3 id="数据库连接方式举例"><a href="#数据库连接方式举例" class="headerlink" title="数据库连接方式举例"></a>数据库连接方式举例</h3><h4 id="连接方式一"><a href="#连接方式一" class="headerlink" title="连接方式一"></a>连接方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            driver = <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API</p></blockquote><h4 id="连接方式二"><a href="#连接方式二" class="headerlink" title="连接方式二"></a>连接方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.实例化Driver</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><h4 id="连接方式三"><a href="#连接方式三" class="headerlink" title="连接方式三"></a>连接方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.实例化Driver</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(driverName);</span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line">            <span class="comment">//3.注册驱动</span></span><br><span class="line">            DriverManager.registerDriver(driver);</span><br><span class="line">            <span class="comment">//4.获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><h4 id="连接方式四"><a href="#连接方式四" class="headerlink" title="连接方式四"></a>连接方式四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">            Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">            <span class="comment">//3.注册驱动</span></span><br><span class="line">            <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">            static &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">                &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                    throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="连接方式五-最终版"><a href="#连接方式五-最终版" class="headerlink" title="连接方式五(最终版)"></a>连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.加载配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(is);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读取配置信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.加载驱动</span></span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        System.out.println(conn);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p><p><strong>使用配置文件的好处：</strong></p><p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p></blockquote><h1 id="使用PreparedStatement实现CRUD操作"><a href="#使用PreparedStatement实现CRUD操作" class="headerlink" title="使用PreparedStatement实现CRUD操作"></a>使用PreparedStatement实现CRUD操作</h1><h2 id="操作和访问数据库"><a href="#操作和访问数据库" class="headerlink" title="操作和访问数据库"></a>操作和访问数据库</h2><ul><li>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</li></ul><ul><li>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：<ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。</li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222227858.png" alt="img"></p><h2 id="使用Statement操作数据表的弊端"><a href="#使用Statement操作数据表的弊端" class="headerlink" title="使用Statement操作数据表的弊端"></a>使用Statement操作数据表的弊端</h2><ul><li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p></li><li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">excuteUpdate</span><span class="params">(String sql)</span>：执行更新操作INSERT、UPDATE、DELETE</span><br><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span>：执行查询操作SELECT</span><br></pre></td></tr></table></figure><ul><li><p>但是使用Statement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul></li><li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;‘a’ OR 1 &#x3D; ’ AND password &#x3D; ’ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p></li><li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p></li><li><p>代码演示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatementTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> get(sql, User.class);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222243357.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j4Enm68A-1601475477283)(尚硅谷_宋红康_JDBC.assets/1566569819744.png)]"></p><h2 id="PreparedStatement的使用"><a href="#PreparedStatement的使用" class="headerlink" title="PreparedStatement的使用"></a>PreparedStatement的使用</h2><h3 id="PreparedStatement介绍"><a href="#PreparedStatement介绍" class="headerlink" title="PreparedStatement介绍"></a>PreparedStatement介绍</h3><ul><li><p>可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象</p></li><li><p>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</p></li><li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p></li></ul><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li>代码的可读性和可维护性。</li></ul><ul><li>PreparedStatement 能最大可能提高性能：<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。</li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li><li>PreparedStatement 可以防止 SQL 注入</li></ul></li></ul><h4 id="Java与SQL对应数据类型转换表"><a href="#Java与SQL对应数据类型转换表" class="headerlink" title="Java与SQL对应数据类型转换表"></a>Java与SQL对应数据类型转换表</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte array</td><td>BINARY , VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h3 id="使用PreparedStatement实现增、删、改操作"><a href="#使用PreparedStatement实现增、删、改操作" class="headerlink" title="使用PreparedStatement实现增、删、改操作"></a>使用PreparedStatement实现增、删、改操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String sql,Object ... args)</span>&#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取数据库的连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用PreparedStatement实现查询操作"><a href="#使用PreparedStatement实现查询操作" class="headerlink" title="使用PreparedStatement实现查询操作"></a>使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p></blockquote><h3 id="ResultSet与ResultSetMetaData"><a href="#ResultSet与ResultSetMetaData" class="headerlink" title="ResultSet与ResultSetMetaData"></a>ResultSet与ResultSetMetaData</h3><h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><ul><li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p></li><li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p></li><li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p></li><li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p><ul><li>例如: getInt(1), getString(“name”)</li><li>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</li></ul></li><li><p>ResultSet 接口的常用方法：</p><ul><li>boolean next()</li><li>getString()</li><li>…</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222305105.png" alt="aaa"></p><h4 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData"></a>ResultSetMetaData</h4><ul><li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p></li><li><p>ResultSetMetaData meta &#x3D; rs.getMetaData();</p><ul><li>getColumnName(int column)：获取指定列的名称</li><li>getColumnLabel(int column)：获取指定列的别名</li><li>getColumnCount()：返回当前 ResultSet 对象中的列数。</li><li>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。</li><li>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。</li><li>isNullable(int column)：指示指定列中的值是否可以为 null。</li><li>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222318664.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UJxU6ECV-1601475477290)(尚硅谷_宋红康_JDBC.assets/1555579494691.png)]"></p></li></ul><p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p><p> 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p><p><strong>问题2：关于ResultSetMetaData</strong></p><ol><li>如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可</li><li>获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法</li><li>获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222333303.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UvkjnWE7-1601475477293)(尚硅谷_宋红康_JDBC.assets/1555579816884.png)]"></p><h3 id="资源的释放"><a href="#资源的释放" class="headerlink" title="资源的释放"></a>资源的释放</h3><ul><li>释放ResultSet, Statement,Connection。</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机</li><li>Connection的使用原则是尽量晚创建，尽量早的释放。</li><li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="JDBC-API小结"><a href="#JDBC-API小结" class="headerlink" title="JDBC API小结"></a>JDBC API小结</h3><ul><li>两种思想<ul><li>面向接口编程的思想</li><li>ORM思想(object relational mapping)<ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。 </p></blockquote><ul><li>两种技术<ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li></ul><h1 id="操作BLOB类型字段"><a href="#操作BLOB类型字段" class="headerlink" title="操作BLOB类型字段"></a>操作BLOB类型字段</h1><h3 id="MySQL-BLOB类型"><a href="#MySQL-BLOB类型" class="headerlink" title="MySQL BLOB类型"></a>MySQL BLOB类型</h3><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222439863.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zLrzXSMo-1601475477317)(尚硅谷_宋红康_JDBC.assets/1555581069798.png)]"></p></li><li><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p></li><li><p>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p></li><li><p>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</p></li></ul><h3 id="向数据表中插入大数据类型"><a href="#向数据表中插入大数据类型" class="headerlink" title="向数据表中插入大数据类型"></a>向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h3 id="修改数据表中的Blob类型字段"><a href="#修改数据表中的Blob类型字段" class="headerlink" title="修改数据表中的Blob类型字段"></a>修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h3 id="从数据表中读取大数据类型"><a href="#从数据表中读取大数据类型" class="headerlink" title="从数据表中读取大数据类型"></a>从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="number">4</span>);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line"><span class="type">Blob</span> <span class="variable">photo</span> <span class="operator">=</span> rs.getBlob(<span class="number">5</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> photo.getBinaryStream();</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line"><span class="type">byte</span> [] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(os !=  <span class="literal">null</span>)&#123;</span><br><span class="line">os.close();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h1><h3 id="批量执行SQL语句"><a href="#批量执行SQL语句" class="headerlink" title="批量执行SQL语句"></a>批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句；</li><li>clearBatch():清空缓存的数据</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h2 id="高效的批量插入"><a href="#高效的批量插入" class="headerlink" title="高效的批量插入"></a>高效的批量插入</h2><p>举例：向数据表中插入20000条数据</p><ul><li><p>数据库中提供一个goods表。创建如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="实现层次一：使用Statement"><a href="#实现层次一：使用Statement" class="headerlink" title="实现层次一：使用Statement"></a>实现层次一：使用Statement</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现层次二：使用PreparedStatement"><a href="#实现层次二：使用PreparedStatement" class="headerlink" title="实现层次二：使用PreparedStatement"></a>实现层次二：使用PreparedStatement</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h4 id="实现层次三"><a href="#实现层次三" class="headerlink" title="实现层次三"></a>实现层次三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> *  ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现层次四"><a href="#实现层次四" class="headerlink" title="实现层次四"></a>实现层次四</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="数据库事务介绍"><a href="#数据库事务介绍" class="headerlink" title="数据库事务介绍"></a>数据库事务介绍</h2><ul><li>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</li><li>事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。</li><li>为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</li></ul><h2 id="JDBC事务处理"><a href="#JDBC事务处理" class="headerlink" title="JDBC事务处理"></a>JDBC事务处理</h2><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li>当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</p><ul><li>调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</li><li>在出现异常时，调用 rollback(); 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><p>【案例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJDBCTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>, <span class="literal">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h2><ol><li>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li><li>隔离性（Isolation）<br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</li></ol><h4 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h4><ul><li>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:<ul><li>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。</li><li>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li></ul></li><li>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</li><li>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</li></ul><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><ul><li>数据库提供的4种事务隔离级别：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222520600.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oFEbbexm-1601475477320)(尚硅谷_宋红康_JDBC.assets/1555586275271.png)]"></p><ul><li>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</li><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li></ul><h4 id="在MySql中设置隔离级别"><a href="#在MySql中设置隔离级别" class="headerlink" title="在MySql中设置隔离级别"></a>在MySql中设置隔离级别</h4><ul><li>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</li><li>查看当前的隔离级别:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><ul><li>设置当前 mySQL 连接的隔离级别:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>  transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ul><li>设置数据库系统的全局的隔离级别:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ul><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p></li><li><p>&#96;&#96;&#96;sql<br>create user tom identified by ‘abc123’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 授予权限</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  #授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">  grant all privileges on *.* to tom@&#x27;%&#x27;  identified by &#x27;abc123&#x27;; </span><br><span class="line">  </span><br><span class="line">   #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">  grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="DAO及相关实现类"><a href="#DAO及相关实现类" class="headerlink" title="DAO及相关实现类"></a>DAO及相关实现类</h1><ul><li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li><li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li><li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222533733.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9HV2eqpU-1601475477323)(尚硅谷_宋红康_JDBC.assets/1566726681515.png)]"></p><ul><li>层次结构：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222549621.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VK9eIITx-1601475477331)(尚硅谷_宋红康_JDBC.assets/1566745811244.png)]"></p><h2 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"><span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BaseDao</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 获取子类的类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass();</span><br><span class="line"><span class="comment">// 获取父类的类型</span></span><br><span class="line"><span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line"><span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line"><span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line"><span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line"><span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line"><span class="built_in">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的增删改操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">count = queryRunner.update(conn, sql, params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t = queryRunner.query(conn, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;T&gt;(type), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line">List&lt;T&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">list = queryRunner.query(conn, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;T&gt;(type), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">count</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">count = queryRunner.query(conn, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>&lt;&gt;(), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Book&gt; <span class="title function_">getBooks</span><span class="params">(Connection conn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">saveBook</span><span class="params">(Connection conn,Book book)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteBookById</span><span class="params">(Connection conn,String bookId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Book <span class="title function_">getBookById</span><span class="params">(Connection conn,String bookId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Connection conn,Book book)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Page&lt;Book&gt; <span class="title function_">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Page&lt;Book&gt; <span class="title function_">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="type">double</span> minPrice, <span class="type">double</span> maxPrice)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param user</span></span><br><span class="line"><span class="comment"> * @return User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">User</span> getUser(Connection conn,<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param user</span></span><br><span class="line"><span class="comment"> * @return true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> checkUsername(Connection conn,<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void saveUser(Connection conn,<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;Book&gt; <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getBooks</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">beanList = getBeanList(conn,sql);</span><br><span class="line"><span class="keyword">return</span> beanList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveBook</span><span class="params">(Connection conn,Book book)</span> &#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> &#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">update(conn,sql, bookId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">getBookById</span><span class="params">(Connection conn,String bookId)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">book = getBean(conn,sql, bookId);</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Connection conn,Book book)</span> &#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title function_">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> &#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">totalRecord</span> <span class="operator">=</span> (<span class="type">long</span>) getValue(conn,sql);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="type">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title function_">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="type">double</span> minPrice, <span class="type">double</span> maxPrice)</span> &#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">totalRecord</span> <span class="operator">=</span> (<span class="type">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="type">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;User&gt; <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Connection conn,User user)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line"><span class="type">User</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUsername</span><span class="params">(Connection conn,User user)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line"><span class="type">User</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername());</span><br><span class="line"><span class="keyword">return</span> bean != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(Connection conn,User user)</span> &#123;</span><br><span class="line"><span class="comment">//写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line"><span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> price; <span class="comment">// 价格</span></span><br><span class="line"><span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line"><span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">imgPath</span> <span class="operator">=</span> <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line"><span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="JDBC数据库连接池的必要性"><a href="#JDBC数据库连接池的必要性" class="headerlink" title="JDBC数据库连接池的必要性"></a>JDBC数据库连接池的必要性</h2><ul><li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：</p><ul><li>在主程序（如servlet、beans）中建立数据库连接</li><li>进行sql操作</li><li>断开数据库连接</li></ul></li><li><p>这种模式开发，存在的问题:</p></li><li><p>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</p></li><li><p><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</p></li><li><p>这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</p></li></ul><h2 id="数据库连接池技术"><a href="#数据库连接池技术" class="headerlink" title="数据库连接池技术"></a>数据库连接池技术</h2><ul><li>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</li><li>数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li><li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222625571.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZXVJvRBu-1601475477337)(尚硅谷_宋红康_JDBC.assets/1555593464033.png)]"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222642230.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uuhSpvNH-1601475477340)(尚硅谷_宋红康_JDBC.assets/1555593598606.png)]"></p><ul><li><strong>数据库连接池技术的优点</strong></li></ul><ol><li><p><strong>资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p></li><li><p><strong>更快的系统反应速度</strong></p></li></ol><p>   数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><ol start="3"><li><p><strong>新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p></li><li><p><strong>统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ol><h2 id="多种开源的数据库连接池"><a href="#多种开源的数据库连接池" class="headerlink" title="多种开源的数据库连接池"></a>多种开源的数据库连接池</h2><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用<br>Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集<strong>DBCP</strong> 、<strong>C3P0</strong> 、<strong>Proxool</strong> 优点于一身的数据库连接池，但是速度不确定是否有<strong>BoneCP</strong>快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="C3P0数据库连接池"><a href="#C3P0数据库连接池" class="headerlink" title="C3P0数据库连接池"></a>C3P0数据库连接池</h4><ul><li><p>获取连接方式一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">ComboPooledDataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpds.setMaxPoolSize(100);</span></span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取连接方式二</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中，src下的配置文件为：【c3p0-config.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a>】</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DBCP数据库连接池"><a href="#DBCP数据库连接池" class="headerlink" title="DBCP数据库连接池"></a>DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><p>属性默认值说明<br>initialSize0连接池启动时创建的初始化连接数量<br>maxActive8连接池中可同时连接的最大的连接数<br>maxIdle8连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制<br>minIdle0连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。<br>maxWait无限制最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待<br>poolPreparedStatementsfalse开启池的Statement是否prepared<br>maxOpenPreparedStatements无限制开启池的prepared 后的同时最大连接数<br>minEvictableIdleTimeMillis连接池中连接，在时间段内一直空闲， 被逐出连接池的时间<br>removeAbandonedTimeout300超过时间限制，回收没有用(废弃)的连接<br>removeAbandonedfalse超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</p><table><thead><tr><th><strong>属性</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li><p>获取连接方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">BasicDataSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line"></span><br><span class="line">source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">source.setInitialSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取连接方式二：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中，src下的配置文件为：【dbcp.properties】</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure><h4 id="Druid（德鲁伊）数据库连接池"><a href="#Druid（德鲁伊）数据库连接池" class="headerlink" title="Druid（德鲁伊）数据库连接池"></a>Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>其中，src下的配置文件为：【druid.properties】</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall</span></span><br></pre></td></tr></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th>配置</th><th>缺省</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/使用ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h1 id="Apache-DBUtils实现CRUD操作"><a href="#Apache-DBUtils实现CRUD操作" class="headerlink" title="Apache-DBUtils实现CRUD操作"></a>Apache-DBUtils实现CRUD操作</h1><h2 id="Apache-DBUtils简介"><a href="#Apache-DBUtils简介" class="headerlink" title="Apache-DBUtils简介"></a>Apache-DBUtils简介</h2><ul><li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p></li><li><p>API介绍：</p><ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils</li></ul></li><li><p>API包说明：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222748867.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-awTVWb0u-1601475477345)(尚硅谷_宋红康_JDBC.assets/1555595163263.png)]"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222800740.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nHXDUBTD-1601475477354)(尚硅谷_宋红康_JDBC.assets/1555595198644.png)]"></p><h2 id="主要API的使用"><a href="#主要API的使用" class="headerlink" title="主要API的使用"></a>主要API的使用</h2><h3 id="DbUtils"><a href="#DbUtils" class="headerlink" title="DbUtils"></a>DbUtils</h3><ul><li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li>public static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。</li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException<br>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><h3 id="QueryRunner类"><a href="#QueryRunner类" class="headerlink" title="QueryRunner类"></a>QueryRunner类</h3><ul><li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p></li><li><p>QueryRunner类提供了两个构造器：</p><ul><li>默认的构造器</li><li>需要一个 javax.sql.DataSource 来作参数的构造器</li></ul></li><li><p>QueryRunner类的主要方法：</p></li><li><p><strong>更新</strong></p><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>…</li></ul></li><li><p><strong>插入</strong></p><ul><li>public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值</li><li>…</li></ul></li><li><p><strong>批处理</strong></p><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句</li><li>…</li></ul></li><li><p><strong>查询</strong></p><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>…</li></ul></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> runner.update(conn, sql, <span class="string">&quot;何成飞&quot;</span>, <span class="string">&quot;he@qq.com&quot;</span>, <span class="string">&quot;1992-09-08&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ResultSetHandler接口及实现类"><a href="#ResultSetHandler接口及实现类" class="headerlink" title="ResultSetHandler接口及实现类"></a>ResultSetHandler接口及实现类</h3><ul><li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p></li><li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p></li><li><p>接口的主要实现类：</p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li><li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li><li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li><li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li><li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li><li><strong>ScalarHandler：</strong>查询单个值对象</li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">System.out.println(customer);</span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line">List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">ResultSetHandler</span>&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"><span class="comment">//return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(customer);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line"><span class="comment">//ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//System.out.println(count);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试二：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line"><span class="type">ScalarHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>();</span><br><span class="line"><span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> (Date) runner.query(conn, sql, handler);</span><br><span class="line">System.out.println(birth);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateWithTx</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取连接的操作（</span></span><br><span class="line"><span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line"><span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line"><span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line"><span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//回滚数据</span></span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//3.关闭连接等操作</span></span><br><span class="line"><span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC概述&quot;&gt;&lt;a href=&quot;#JDBC概述&quot; class=&quot;headerlink&quot; title=&quot;JDBC概述&quot;&gt;&lt;/a&gt;JDBC概述&lt;/h1&gt;&lt;h2 id=&quot;数据的持久化&quot;&gt;&lt;a href=&quot;#数据的持久化&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JDBC" scheme="https://lyotoc.github.io/tags/JDBC/"/>
    
    <category term="数据库" scheme="https://lyotoc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程</title>
    <link href="https://lyotoc.github.io/2022/06/30/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://lyotoc.github.io/2022/06/30/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-06-30T03:59:35.000Z</published>
    <updated>2022-07-12T09:07:45.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程是操作系统的最小可操作分配资源，Java的线程通过调用<code>Thread.start()</code>启动，本质上是在调用<code>native</code>方法<code>start0()</code>,该方法通过<code>JNI(Java Native Interface)</code>调用,通过C++实现计算机本地线程资源</p></blockquote><h1 id="并发大纲"><a href="#并发大纲" class="headerlink" title="并发大纲"></a>并发大纲</h1><p><strong>java.util.concurrent包涵以下三个模块内容</strong></p><ol><li>atomic</li><li>locks</li><li>其它</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1654244836651-52adc269-4bcd-49af-9fe1-b7794908f108.png" alt="image.png"></p><h1 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h1><p><em><strong>脑图</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/yuque_diagram.jpg" alt="并发编程脑图"></p><h2 id="Java多线程相关概念"><a href="#Java多线程相关概念" class="headerlink" title="Java多线程相关概念"></a>Java多线程相关概念</h2><ul><li><strong>并发(concurrent)</strong></li></ul><blockquote><ol><li>是在同一实体上的多个事件</li><li>是在一台处理器上“同时”处理多个任务</li><li>同一时刻，其实是只有一个事情在发生</li></ol></blockquote><ul><li><strong>并行（parallel）</strong></li></ul><blockquote><ol><li>是在不同实体上的多个事件</li><li>是在多台处理器上同时处理多个任务</li><li>同一时刻，大家真的都在做事情，你做你的，我做我的，但是我们都在做</li></ol></blockquote><ul><li><strong>进程</strong></li></ul><blockquote><p>简单的说，在系统中运行一个应用程序就是一个进程，每个进程都有自己的内存空间和系统资源。</p></blockquote><ul><li><strong>线程</strong></li></ul><blockquote><p>也被称为<code>轻量级进程</code>，在同一个进程内会有1个或多个线程，也是大多数操作系统进行时序调度的基本单元。</p></blockquote><ul><li><strong>管程(Monitor)</strong></li></ul><blockquote><p>监视器，即锁</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220630152657690.png" alt="image-20220630152657690"></p><h2 id="Java多线程是怎么开启的？"><a href="#Java多线程是怎么开启的？" class="headerlink" title="Java多线程是怎么开启的？"></a>Java多线程是怎么开启的？</h2><blockquote><p>查看源码就知道，多线程的开启调用了一个start0()的本地方法，该方法会调用C++底层源码执行调用硬件资源开启线程。Java运行于虚拟机上，无法操作硬件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">         * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 本地方法，底层的C++ ，Java运行于虚拟机之上 无法直接操作硬件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>可以通过以下方法开启线程</strong></p><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口+FutureTask(通过实现该接口可以拿到返回结果，并处理异常)</li><li>线程池</li></ol><p>方式1和方式2：主进程无法获取线程的运算结果。</p><p>方式3：主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。</p><p>方式4：通过如下两种方式初始化线程池</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631603318411-339177fe-d521-460b-8099-61509e882135.png" alt="img"></p><p>区别;<br>   1、2不能得到返回值。3可以获取返回值<br>   1、2、3都不能控制资源<br>   4、可以控制资源，性能稳定。</p><h2 id="开发中为什么使用线程池"><a href="#开发中为什么使用线程池" class="headerlink" title="开发中为什么使用线程池"></a>开发中为什么使用线程池</h2><ul><li><p>降低资源的消耗：通过重复利用已经创建好的线程降低线程的创建和销毁带来的损耗</p></li><li><p>提高响应速度：因为线程池中的线程数没有超过线程池的最大上限时，有的线程处于等待分配任务的状态，当任务来时无需创建新的线程就能执行</p></li><li><p>提高线程的可管理性：线程池会根据当前系统特点对池内的线程进行优化处理，减少创建和销毁线程带来的系统开销。无限的创建和销毁线程不仅消耗系统资源，还降低系统的稳定性，使用线程池进行统一分配</p></li></ul><h2 id="使用线程的基本方式"><a href="#使用线程的基本方式" class="headerlink" title="使用线程的基本方式"></a>使用线程的基本方式</h2><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）、继承Thread</span><br><span class="line">         <span class="type">Thread01</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line">         thread.start();<span class="comment">//启动线程</span></span><br><span class="line"><span class="comment">// 继承Thread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            System.out.println(<span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Thread的join方法</strong></p><p>join()方法的作用就是让主线程等待子线程执行结束之后再运行主线程。下面示例中t2 为主线程，需要等待子线程t1 执行完成再执行<br>使用场景：线程2依赖于线程1执行的返回结果。在线程2 中调用线程1的join方法，当线程调用了这个方法时，线程1会强占CPU资源，直到线程执行结果为止（谁调用join方法，谁就强占cpu资源，直至执行结束）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;线程1醒了&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1 i:&quot;</span>+i);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          t1.join();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;线程2 i:&quot;</span>+i);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">100</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t2.start();</span><br><span class="line">    t1.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">1</span>醒了</span><br><span class="line">线程<span class="number">1</span> i:<span class="number">0</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">2</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">3</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">4</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">5</span></span><br><span class="line">……</span><br><span class="line">线程<span class="number">1</span> i:<span class="number">99</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">0</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">1</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">2</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">3</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">4</span></span><br><span class="line">……</span><br><span class="line">线程<span class="number">2</span> i:<span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>实现Runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>）、实现Runnable接口</span><br><span class="line">        <span class="type">Runable01</span> <span class="variable">runable01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runable01</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runable01).start();</span><br><span class="line">   <span class="comment">// 实现Runnable接口</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">R1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">           System.out.println(<span class="string">&quot;R1&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>实现Callable&lt;T&gt;接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>）、实现Callable接口 + FutureTask （可以拿到返回结果，可以处理异常）</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="comment">//阻塞等待整个线程执行完成，获取返回结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> futureTask.get();    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实现Callable接口 （可以拿到返回结果，可以处理异常）</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">           System.out.println(<span class="string">&quot;C1&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">66</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>实现 Runnable 接口和 Callable 接口的区别</strong></p><p>Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。<br>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。</p><p><code>Runnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Callable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算返回的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池技术"><a href="#线程池技术" class="headerlink" title="线程池技术"></a>线程池技术</h2><blockquote><p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p></blockquote><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="Executors-创建线程池"><a href="#Executors-创建线程池" class="headerlink" title="Executors 创建线程池"></a><strong>Executors 创建线程池</strong></h3><p>通过 <strong>Executor</strong> 框架的工具类 <strong>Executors</strong> 来实现我们可以创建三种类型的<strong>ThreadPoolExecutor</strong>：</p><ul><li>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>ScheduledThreadPoolExecutor 主要用来在给定的延迟后运行任务，或者定期执行任务。 这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下它的思想即可。</li><li>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li></ul><p>对应 Executors 工具类中的方法如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692714-f8367307-610f-4b25-a8d8-de54edda759e.png" alt="img"></p><blockquote><p>Executors 返回线程池对象的弊端如下：<br>●CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程导致 OOM。<br>●FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</p></blockquote><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><h3 id="ThreadPoolExecutor-创建线程池"><a href="#ThreadPoolExecutor-创建线程池" class="headerlink" title="ThreadPoolExecutor 创建线程池"></a><strong>ThreadPoolExecutor 创建线程池</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692548-c26740fa-88f1-4d72-b223-8258719d2709.png" alt="img"></p><p>ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                      TimeUnit unit,</span></span><br><span class="line"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                      ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                      RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">ThreadPoolExecutor构造函数重要参数分析</span></span><br><span class="line"><span class="comment">ThreadPoolExecutor 3 个最重要的参数：</span></span><br><span class="line"><span class="comment">● corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</span></span><br><span class="line"><span class="comment">● maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</span></span><br><span class="line"><span class="comment">● workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</span></span><br><span class="line"><span class="comment">ThreadPoolExecutor其他常见参数:</span></span><br><span class="line"><span class="comment">● keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</span></span><br><span class="line"><span class="comment">● unit : keepAliveTime 参数的时间单位。</span></span><br><span class="line"><span class="comment">● threadFactory :executor 创建新线程的时候会用到。</span></span><br><span class="line"><span class="comment">● handler :饱和策略。关于饱和策略下面单独介绍一下。</span></span><br><span class="line"><span class="comment">例题举例1：</span></span><br><span class="line"><span class="comment">一个线程池 core 7； max 20 ，queue：50，100并发进来怎么分配的；</span></span><br><span class="line"><span class="comment">7个会立即得到执行，50个会进入队列，再开13个进行执行。剩下的30个就使用拒绝策略。</span></span><br><span class="line"><span class="comment">如果不想抛弃还要执行，拒绝策略采用CallerRunsPolicy；</span></span><br><span class="line"><span class="comment">例题举例2：</span></span><br><span class="line"><span class="comment">我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，</span></span><br><span class="line"><span class="comment">所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务执行完成后，才会执行剩下的 5 个任务。</span></span><br><span class="line"><span class="comment">等待队列装不满，所以用不到maximumPoolSize</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor 饱和策略<br>ThreadPoolExecutor 饱和策略定义:<br>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。[默认测策]</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。<br>对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p><h3 id="一个简单的线程池-Demo"><a href="#一个简单的线程池-Demo" class="headerlink" title="一个简单的线程池 Demo"></a><strong>一个简单的线程池 Demo</strong></h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。<br>首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）</p><p><code>MyRunnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p><p><code>ThreadPoolExecutorDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li>corePoolSize: 核心线程数为 5</li><li>maximumPoolSize ：最大线程数 10</li><li>keepAliveTime : 等待时间为 1L</li><li>unit: 等待时间的单位为 TimeUnit.SECONDS</li><li>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100</li><li>handler:饱和策略为 CallerRunsPolicy</li></ol><p><strong>Output：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程池对象执行-execute-方法和-submit-方法的区别是什么"><a href="#线程池对象执行-execute-方法和-submit-方法的区别是什么" class="headerlink" title="线程池对象执行 execute()方法和 submit()方法的区别是什么?"></a>线程池对象执行 execute()方法和 submit()方法的区别是什么?</h3><ol><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以AbstractExecutorService接口中的一个 submit 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>submit方法调用的 newTaskFor 方法得到了一个 FutureTask 对象，<br>调用execute(ftask);<br>最终返回了FutureTask </p></blockquote><h2 id="用户线程与守护线程"><a href="#用户线程与守护线程" class="headerlink" title="用户线程与守护线程"></a>用户线程与守护线程</h2><p><strong>用户线程</strong></p><blockquote><p>一般情况下不作说明均为用户线程</p><p>系统的工作线程，它会完成这个程序需要完成的业务操作</p></blockquote><p><strong>守护线程</strong></p><blockquote><ol><li>一种特殊的线程为其它线程服务的，在后台默默地完成一些系统性的，比如垃圾回收线程就是最典型的例子</li><li>守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，java虚拟机会自动退出。</li></ol></blockquote><h3 id="线程的deamon的属性"><a href="#线程的deamon的属性" class="headerlink" title="线程的deamon的属性"></a>线程的deamon的属性</h3><p> 涉及两个方法 <code>isDeamon()</code>,<code>setDeamon(Boolea  b)</code>，前者判断该线程为守护线程[true为守护线程，false为用户线程]，后者为设置当前线程[true为守护线程，false为用户线程]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 开始运行，&quot;</span>+(Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span>:<span class="string">&quot;用户线程&quot;</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----end 主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 开始运行，守护线程</span><br><span class="line">main -----end 主线程</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果用户线程全部结束意味着程序需要完成的业务操作已经全部结束了，守护线程随着JVM一同结束工作，setDeamon(true)方法必须在start()之前设置，否则报IllegalThreadStateException异常</p><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2><p><strong>Future</strong>接口(FutureTask实现类)定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><ul><li>例如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙其他事情或者先执行完，过了一会才去获取子任务的执行结果或变更的任务状态。</li></ul><p><strong>Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务</strong></p><p>Future是Java5新加的一个接口，它提供了一种异步并行计算的功能。如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。<br>代码说话：<br>Runnable接口<br>Callable接口<br>Future接口和FutureTask实现类</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>该实现类满足了异步执行任务的要求，即多线程、有返回、异步任务。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220630171049484.png" alt="FutureTask的继承实现关系"></p><p>FutureTask使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">futureTaskTest</span><span class="params">()</span>&#123;</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;come in call()&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello Callable&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Future编码及优缺点分析"><a href="#Future编码及优缺点分析" class="headerlink" title="Future编码及优缺点分析"></a>Future编码及优缺点分析</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>future线程池异步多线程任务配合，能显著提高程序的执行效率</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>get()方法容易导致阻塞</li></ul><blockquote><p>调用get()方法是直接主线程直接去访问子线程获取结果，此时如果子线程任务未结束就会导致主线程阻塞等待</p></blockquote><ul><li>isDone()论询</li></ul><blockquote><p>轮询的方式会耗费无谓的CPU资源而且也不见得能及时地得到计算结果，如果想要异步获取结果，通常都会以轮询地方式去获取结果，尽量不要阻塞</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureAPIDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-------------come in&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;task over&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;忙其它任务了&quot;</span>);</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line">        <span class="comment">// 1.设置指定时间，限定等待时间</span></span><br><span class="line">      <span class="comment">//System.out.println(futureTask.get(5,TimeUnit.SECONDS));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>希望能实现子线程完成后主动向主线程汇报的需求</li></ul><h4 id="FutureTask源码结构"><a href="#FutureTask源码结构" class="headerlink" title="FutureTask源码结构"></a>FutureTask源码结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220706162204093.png" alt="image-20220706162204093"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655705978070-830eea78-f873-4daa-a625-136d692fff00.png" alt="image.png"></p><ul><li>作为线程：实现了Runnable接口</li><li>异步处理：实现了Future接口</li><li>有返回值：构造注入了Callable&lt;T&gt;,提供了Callable功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p>在 JDK 1.7 ， ForkJoin，并行执行任务！提高效率。大数据量！  大数据：Map Reduce （把大任务拆分为小任务）</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632721661519-7e143e5f-ed05-40d8-823f-dcc76e57637c.png" alt="img"></p><p>就是在必要的情况下，将一个大任务，进行拆分（fork） 成若干个小任务（拆到给出的临界值为止），再将一个个的小任务运算的结果进行join汇总</p><h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><blockquote><p>工作窃取模式 （work-stealing）：当执行新的任务时它可以将其拆分成 更小的任务执行，并将小任务加到线程队列中，当没有任务执行时，再从一个随机线程的队列中偷一个并把它放在自己的队列中 相对于一般的线程池实现 ，fork&#x2F;join 框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行那么该线程会处于等待状态。而在fork&#x2F;join 框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题（窃取过来）来执行，这种方式减少了线程的等待时间，提高了性能</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632724412453-f817290f-d167-4281-bc6f-06c6dd273a3f.png" alt="img"></p><h3 id="ForkJoinTask实现类"><a href="#ForkJoinTask实现类" class="headerlink" title="ForkJoinTask实现类"></a>ForkJoinTask实现类</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1654151499135-73f8ea34-16d9-4d2f-af99-174a845ea562.png" alt="image.png"></p><ul><li>RecursiveTask&lt;V&gt;：有返回值的递归任务</li><li>RecursiveAction：无返回值得递归事件</li></ul><h4 id="实现类Demo"><a href="#实现类Demo" class="headerlink" title="实现类Demo"></a>实现类Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求和计算的任务！</span></span><br><span class="line"><span class="comment"> * 3000   6000（ForkJoin）  9000（Stream并行流）</span></span><br><span class="line"><span class="comment"> * // 如何使用 forkjoin</span></span><br><span class="line"><span class="comment"> * // 1、forkjoinPool 通过它来执行</span></span><br><span class="line"><span class="comment"> * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task)</span></span><br><span class="line"><span class="comment"> * // 3. 计算类要继承 ForkJoinTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> Long end;    <span class="comment">// 1990900000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end-start)&lt;temp)&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// forkjoin 递归</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            task1.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试类Demo"><a href="#测试类Demo" class="headerlink" title="测试类Demo"></a>测试类Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个任务，别人效率高你几十倍！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// test1(); // 12224</span></span><br><span class="line">        <span class="comment">// test2(); // 10038</span></span><br><span class="line">        <span class="comment">// test3(); // 153</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通程序员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会使用ForkJoin</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);<span class="comment">// 提交任务</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Stream并行流 ()  (]</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用过 CountDownLatch 么？什么场景下用的？<br>CountDownLatch 的作用就是 允许 count 个线程阻塞在一个地方，直至这count个线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 CountDownLatch 。具体场景是下面这样的：<br>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。<br>为此我们定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。<br>伪代码是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>有没有可以改进的地方呢？</strong><br>可以使用 CompletableFuture 类来改进！Java8 的 CompletableFuture 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的代码还可以接续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过集合来添加任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[fileFutures.size()])</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture-1"><a href="#CompletableFuture-1" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Bi函数式接口"><a href="#Bi函数式接口" class="headerlink" title="Bi函数式接口"></a>Bi函数式接口</h3><h4 id="BiConsumer"><a href="#BiConsumer" class="headerlink" title="BiConsumer"></a>BiConsumer</h4><p>函数式接口<code>BiConsumer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> BiConsumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> BiConsumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title function_">andThen</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    <span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与普通的消费者接口不同的是，BiConsumer可以传入两个参数</p></blockquote><h4 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; BiFunction&lt;T, U, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与普通的Function接口不同的是，BiFunction可以传入两个参数。</p></blockquote><h4 id="BiPredicate"><a href="#BiPredicate" class="headerlink" title="BiPredicate"></a>BiPredicate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiPredicate</span>&lt;T, U&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input arguments match the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title function_">and</span><span class="params">(BiPredicate&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; test(t, u) &amp;&amp; other.test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; !test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title function_">or</span><span class="params">(BiPredicate&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; test(t, u) || other.test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与普通的断言接口不同的是，BiPredicate可以传入两个参数。</p></blockquote><h3 id="CompletableFuture启动异步任务"><a href="#CompletableFuture启动异步任务" class="headerlink" title="CompletableFuture启动异步任务"></a>CompletableFuture启动异步任务</h3><h4 id="CompletableFuture创建方式"><a href="#CompletableFuture创建方式" class="headerlink" title="CompletableFuture创建方式"></a>CompletableFuture创建方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the &#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125; after</span></span><br><span class="line"><span class="comment"> * it runs the given action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the action to run before completing the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the given executor after it runs the given</span></span><br><span class="line"><span class="comment"> * action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the action to run before completing the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor the executor to use for asynchronous execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,</span></span><br><span class="line"><span class="params">                                               Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the &#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125; with</span></span><br><span class="line"><span class="comment"> * the value obtained by calling the given Supplier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function returning the value to be used</span></span><br><span class="line"><span class="comment"> * to complete the returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the function&#x27;s return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the given executor with the value obtained</span></span><br><span class="line"><span class="comment"> * by calling the given Supplier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function returning the value to be used</span></span><br><span class="line"><span class="comment"> * to complete the returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor the executor to use for asynchronous execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the function&#x27;s return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span><br><span class="line"><span class="params">                                                   Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runAsync方法不支持返回值。其中Executor指的是可以传入我们的线程池对象</li><li>supplyAsync可以支持返回值。其中Executor指的是可以传入我们的线程池对象</li></ul><h3 id="CompletableFuture回调方法"><a href="#CompletableFuture回调方法" class="headerlink" title="CompletableFuture回调方法"></a>CompletableFuture回调方法</h3><h4 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete"></a>whenComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>whenComplete可以处理正常的计算结果</p><blockquote><p>whenComplete和whenCompleteAsync的区别：<br>whenComplete：是当前线程执行当前任务，等待任务执行之后继续执行当前的whenComplete<br>whenCompleteAsync：是执行把whenCompleteAsync这个任务提交给线程池中的其他线程来进行执行。<br>方法不以Async结尾，意味着Action使用相同的线程执行<br>方法以Async结尾可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.cf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-16 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureUseDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----1秒钟后出结果：&quot;</span> + result);</span><br><span class="line">                <span class="keyword">if</span>(result &gt; <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;,threadPool).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----计算完成，更新系统UpdateValue：&quot;</span>+v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;异常情况：&quot;</span>+e.getCause()+<span class="string">&quot;\t&quot;</span>+e.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程先去忙其它任务&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">future1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----1秒钟后出结果：&quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程先去忙其它任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is completed when this</span></span><br><span class="line"><span class="comment"> * CompletableFuture completes, with the result of the given</span></span><br><span class="line"><span class="comment"> * function of the exception triggering this CompletableFuture&#x27;s</span></span><br><span class="line"><span class="comment"> * completion when it completes exceptionally; otherwise, if this</span></span><br><span class="line"><span class="comment"> * CompletableFuture completes normally, then the returned</span></span><br><span class="line"><span class="comment"> * CompletableFuture also completes normally with the same value.</span></span><br><span class="line"><span class="comment"> * Note: More flexible versions of this functionality are</span></span><br><span class="line"><span class="comment"> * available using methods &#123;<span class="doctag">@code</span> whenComplete&#125; and &#123;<span class="doctag">@code</span> handle&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn the function to use to compute the value of the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture if this CompletableFuture completed</span></span><br><span class="line"><span class="comment"> * exceptionally</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;Throwable, ? extends T&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniExceptionallyStage(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exceptionally处理异常情况。</p><h4 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h4><p>handle：whenComplete和exceptionally的结合版。方法执行后的处理，无论成功与失败都可处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法执行完成后的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">          System.out.println(<span class="string">&quot;CompletableFuture...&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">10</span>/<span class="number">1</span>;</span><br><span class="line">      &#125;, service).handle((t,u)-&gt;&#123; <span class="comment">// R apply(T t, U u);</span></span><br><span class="line">          System.out.println(<span class="string">&quot;handle:&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (t != <span class="literal">null</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;存在返回结果:&quot;</span> + t);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (u != <span class="literal">null</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;存在日常:&quot;</span> + u);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> completableFuture2.get();</span><br><span class="line">      System.out.println(integer);</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture异步任务场景"><a href="#CompletableFuture异步任务场景" class="headerlink" title="CompletableFuture异步任务场景"></a>CompletableFuture异步任务场景</h3><h4 id="线程串行化"><a href="#线程串行化" class="headerlink" title="线程串行化"></a>线程串行化</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608072243-885c7014-2a11-413a-bedc-915a8d6a4f49.png" alt="image.png"></p><ul><li>thenRun：不能获取到上一步的执行结果，无返回值</li><li>thenAcceptAsyne 能接受上—步结果，但是无返回值</li><li>thenApplyAsync 能接受上—步结果，有返回值</li></ul><p><strong>我们即要能感知到上一步的执行结果，也要能有自己线程执行成功的自己的返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">我是B</span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;CompletableFuture...&quot;);</span></span><br><span class="line"><span class="comment">//            return 10;//拿到A的返回值</span></span><br><span class="line"><span class="comment">//        &#125;, service).thenApplyAsync((u)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;返回值&quot; + u);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务2启动&quot;);</span></span><br><span class="line"><span class="comment">//            return 5;//自己的返回值再返回出去</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println(completableFuture2.get());</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        CompletableFuture...</span></span><br><span class="line"><span class="comment">        返回值10</span></span><br><span class="line"><span class="comment">        任务2启动</span></span><br><span class="line"><span class="comment">        5</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">                * */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双线程均完成才能后续"><a href="#双线程均完成才能后续" class="headerlink" title="双线程均完成才能后续"></a>双线程均完成才能后续</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608481956-26c05f7b-f884-40a5-ab82-29ae5e58948f.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608525031-b674bf15-05f0-4bad-9d83-cad4467054cf.png" alt="image.png"></p><ul><li>runAfterBothAsync 两人任务组合，不能得到前任务的结果和无返回值</li><li>thenAcceptBothAsync 两人任务组合，能得到前任务的结果和无返回值</li><li>thenCombineAsync 两人任务组合，能得到前任务的结果和有返回值</li></ul><p>传入的参数：CompletionStage是什么？其实还是我们的CompletableFuture</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608617737-c042b566-2caf-4b92-ada9-1e9aef21d02e.png" alt="image.png"></p><p>两个任务必须都完成，触发该Runnable参数指定的任务即当前lambda表达式的内容<br>thenCombine:组合两个 future,获取两个 future的返回结果,并返回当前任务的返回值<br>thenAcceptBoth:组合两个 future,获取两个 future任务的返回结果,然后处理任务,没有返回值。<br>runAfterBoth组合两个future，不需要获取future的结果,只需两个future处理完任务后处理该任务<br>tips：方法的参数源码<br>CompletionStage&lt;? extends U&gt; other,：合作线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; completableFuture3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;任务1...&quot;);</span></span><br><span class="line"><span class="comment">//                    return 111;</span></span><br><span class="line"><span class="comment">//                &#125;, service);</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; completableFuture4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务2...&quot;);</span></span><br><span class="line"><span class="comment">//            return 222;</span></span><br><span class="line"><span class="comment">//        &#125;, service);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        completableFuture3.runAfterBothAsync(completableFuture4,()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;任务3...&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;,service);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        任务1...</span></span><br><span class="line"><span class="comment">        当前线程：12</span></span><br><span class="line"><span class="comment">        任务2...</span></span><br><span class="line"><span class="comment">        任务3...</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        completableFuture3.thenAcceptBothAsync(completableFuture4, (f1,f2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务3...&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;f1:&quot; + f1 + &quot;.f2:&quot; + f2);</span></span><br><span class="line"><span class="comment">//        &#125;, service);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        任务1...</span></span><br><span class="line"><span class="comment">        当前线程：12</span></span><br><span class="line"><span class="comment">        任务2...</span></span><br><span class="line"><span class="comment">        任务3...</span></span><br><span class="line"><span class="comment">        f1:111.f2:222</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; integerCompletableFuture = completableFuture3.thenCombineAsync(completableFuture4, (f1, f2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务3...&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;f1:&quot; + f1 + &quot;.f2:&quot; + f2);</span></span><br><span class="line"><span class="comment">//            return 3;</span></span><br><span class="line"><span class="comment">//        &#125;, service);</span></span><br><span class="line"><span class="comment">//        System.out.println(integerCompletableFuture.get());</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        任务1...</span></span><br><span class="line"><span class="comment">        当前线程：12</span></span><br><span class="line"><span class="comment">        任务2...</span></span><br><span class="line"><span class="comment">        任务3...</span></span><br><span class="line"><span class="comment">        f1:111.f2:222</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双线程完成其一就能后"><a href="#双线程完成其一就能后" class="headerlink" title="双线程完成其一就能后"></a>双线程完成其一就能后</h4><h5 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------- Arbitrary-arity constructions -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is completed when all of</span></span><br><span class="line"><span class="comment"> * the given CompletableFutures complete.  If any of the given</span></span><br><span class="line"><span class="comment"> * CompletableFutures complete exceptionally, then the returned</span></span><br><span class="line"><span class="comment"> * CompletableFuture also does so, with a CompletionException</span></span><br><span class="line"><span class="comment"> * holding this exception as its cause.  Otherwise, the results,</span></span><br><span class="line"><span class="comment"> * if any, of the given CompletableFutures are not reflected in</span></span><br><span class="line"><span class="comment"> * the returned CompletableFuture, but may be obtained by</span></span><br><span class="line"><span class="comment"> * inspecting them individually. If no CompletableFutures are</span></span><br><span class="line"><span class="comment"> * provided, returns a CompletableFuture completed with the value</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Among the applications of this method is to await completion</span></span><br><span class="line"><span class="comment"> * of a set of independent CompletableFutures before continuing a</span></span><br><span class="line"><span class="comment"> * program, as in: &#123;<span class="doctag">@code</span> CompletableFuture.allOf(c1, c2,</span></span><br><span class="line"><span class="comment"> * c3).join();&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs the CompletableFutures</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new CompletableFuture that is completed when all of the</span></span><br><span class="line"><span class="comment"> * given CompletableFutures complete</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the array or any of its elements are</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> andTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is completed when any of</span></span><br><span class="line"><span class="comment"> * the given CompletableFutures complete, with the same result.</span></span><br><span class="line"><span class="comment"> * Otherwise, if it completed exceptionally, the returned</span></span><br><span class="line"><span class="comment"> * CompletableFuture also does so, with a CompletionException</span></span><br><span class="line"><span class="comment"> * holding this exception as its cause.  If no CompletableFutures</span></span><br><span class="line"><span class="comment"> * are provided, returns an incomplete CompletableFuture.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs the CompletableFutures</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new CompletableFuture that is completed with the</span></span><br><span class="line"><span class="comment"> * result or exception of any of the given CompletableFutures when</span></span><br><span class="line"><span class="comment"> * one completes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the array or any of its elements are</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>allOf：等待所有任务完成</li><li>anyOf：只要有一个任务完成</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; img = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查询商品图片信息&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1.jpg&quot;</span>;</span><br><span class="line">&#125;,service);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; attr = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;查询商品属性&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;麒麟990 5G  钛空银&quot;</span>;</span><br><span class="line">&#125;,service);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; desc = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查询商品介绍&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">&#125;,service);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等这三个都做完</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(img, attr, desc);</span><br><span class="line">allOf.join();</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(&quot;main....end&quot;  + desc.get() + attr.get() + img.get());</span></span><br><span class="line"><span class="comment">//CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(img, attr, desc);</span></span><br><span class="line"><span class="comment">//anyOf.get();</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;main....end&quot;</span> + img.get()+attr.get()+desc.get());</span><br><span class="line"></span><br><span class="line">main....start</span><br><span class="line">查询商品图片信息</span><br><span class="line">查询商品介绍</span><br><span class="line">#这里卡2s</span><br><span class="line">查询商品属性</span><br><span class="line">main....end1.jpg麒麟<span class="number">990</span> 5G  钛空银华为</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture-自定义线程池"><a href="#CompletableFuture-自定义线程池" class="headerlink" title="CompletableFuture+自定义线程池"></a>CompletableFuture+自定义线程池</h3><h4 id="CompletableFuture-自定义线程池-1"><a href="#CompletableFuture-自定义线程池-1" class="headerlink" title="CompletableFuture+自定义线程池"></a>CompletableFuture+自定义线程池</h4><p>线程池配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: cx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span>: 2020-06-23 20:24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThreadPoolConfigProperties.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">(ThreadPoolConfigProperties pool)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                pool.getCoreSize(),</span><br><span class="line">                pool.getMaxSize(),</span><br><span class="line">                pool.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadPoolConfigProperties"><a href="#ThreadPoolConfigProperties" class="headerlink" title="ThreadPoolConfigProperties"></a>ThreadPoolConfigProperties</h3><p>将配置参数抽取出来到application.properties<br>加上@Component，或者MyThreadConfig导入ThreadPoolConfigProperties.class的时候加上@EnableConfigurationProperties注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;gulimall.thread&quot;)</span></span><br><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfigProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer keepAliveTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SkuItemVo <span class="title function_">item</span><span class="params">(Long skuId)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SkuItemVo</span> <span class="variable">skuItemVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuItemVo</span>();</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;SkuInfoEntity&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//1、sku基本信息的获取  pms_sku_info</span></span><br><span class="line">        <span class="type">SkuInfoEntity</span> <span class="variable">info</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(skuId);</span><br><span class="line">        skuItemVo.setInfo(info);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="comment">//3、获取spu的销售属性组合</span></span><br><span class="line">        List&lt;SkuItemSaleAttrVo&gt; saleAttrVos = skuSaleAttrValueService.getSaleAttrBySpuId(res.getSpuId());</span><br><span class="line">        skuItemVo.setSaleAttr(saleAttrVos);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; descFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="comment">//4、获取spu的介绍    pms_spu_info_desc</span></span><br><span class="line">        <span class="type">SpuInfoDescEntity</span> <span class="variable">spuInfoDescEntity</span> <span class="operator">=</span> spuInfoDescService.getById(res.getSpuId());</span><br><span class="line">        skuItemVo.setDesc(spuInfoDescEntity);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; baseAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="comment">//5、获取spu的规格参数信息</span></span><br><span class="line">        List&lt;SpuItemAttrGroupVo&gt; attrGroupVos = attrGroupService.getAttrGroupWithAttrsBySpuId(</span><br><span class="line">            res.getSpuId(), res.getCatalogId());</span><br><span class="line">        skuItemVo.setGroupAttrs(attrGroupVos);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Long spuId = info.getSpuId();</span></span><br><span class="line">    <span class="comment">// Long catalogId = info.getCatalogId();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、sku的图片信息    pms_sku_images</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; imageFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        List&lt;SkuImagesEntity&gt; imagesEntities = skuImagesService.getImagesBySkuId(skuId);</span><br><span class="line">        skuItemVo.setImages(imagesEntities);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; seckillFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//3、远程调用查询当前sku是否参与秒杀优惠活动</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">skuSeckilInfo</span> <span class="operator">=</span> seckillFeignService.getSkuSeckilInfo(skuId);</span><br><span class="line">        <span class="keyword">if</span> (skuSeckilInfo.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//查询成功</span></span><br><span class="line">            <span class="type">SeckillSkuVo</span> <span class="variable">seckilInfoData</span> <span class="operator">=</span> skuSeckilInfo.getData(<span class="string">&quot;data&quot;</span>, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;SeckillSkuVo&gt;() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            skuItemVo.setSeckillSkuVo(seckilInfoData);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (seckilInfoData != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt; seckilInfoData.getEndTime()) &#123;</span><br><span class="line">                    skuItemVo.setSeckillSkuVo(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等到所有任务都完成</span></span><br><span class="line">    CompletableFuture.allOf(saleAttrFuture,descFuture,baseAttrFuture,imageFuture,seckillFuture).get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skuItemVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-properties如下"><a href="#application-properties如下" class="headerlink" title="application.properties如下"></a>application.properties如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.type=redis</span><br><span class="line"></span><br><span class="line">#spring.cache.cache-names=qq,毫秒为单位</span><br><span class="line">spring.cache.redis.time-to-live=<span class="number">3600000</span></span><br><span class="line"></span><br><span class="line">#如果指定了前缀就用我们指定的前缀，如果没有就默认使用缓存的名字作为前缀</span><br><span class="line">#spring.cache.redis.key-prefix=CACHE_</span><br><span class="line">spring.cache.redis.use-key-prefix=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">#是否缓存空值，防止缓存穿透</span><br><span class="line">spring.cache.redis.cache-<span class="literal">null</span>-values=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">#配置线程池</span><br><span class="line">gulimall.thread.coreSize=<span class="number">20</span></span><br><span class="line">gulimall.thread.maxSize=<span class="number">200</span></span><br><span class="line">gulimall.thread.keepAliveTime=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">#开启debug日志</span><br><span class="line">logging.level.org.springframework.cloud.openfeign=debug</span><br><span class="line">logging.level.org.springframework.cloud.sleuth=debug</span><br><span class="line"></span><br><span class="line">#服务追踪</span><br><span class="line">spring.zipkin.base-url=http:<span class="comment">//192.168.18.80:9411/</span></span><br><span class="line">#关闭服务发现</span><br><span class="line">spring.zipkin.discovery-client-enabled=<span class="literal">false</span></span><br><span class="line">spring.zipkin.sender.type=web</span><br><span class="line">#配置采样器</span><br><span class="line">spring.sleuth.sampler.probability=<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="本地锁"><a href="#本地锁" class="headerlink" title="本地锁"></a>本地锁</h1><h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><h3 id="Synchronized关键字-1"><a href="#Synchronized关键字-1" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h3><p><strong>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。为什么呢？</strong></p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。<br>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。<br>所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 synchronized 关键字。</p><h3 id="synchronized-关键字使用方式"><a href="#synchronized-关键字使用方式" class="headerlink" title="synchronized 关键字使用方式"></a>synchronized 关键字使用方式</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p><ol><li><strong>修饰实例方法</strong>: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修饰代码块 ：指定加锁对象，对给定对象&#x2F;类加锁。<br>synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。<br>synchronized(类.class) 表示进入同步代码前要获得 当前 class 的锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。</li><li>synchronized 关键字加到实例方法上是给对象实例上锁。</li><li>尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！</li><li>构造方法可以使用 synchronized 关键字修饰么？先说结论：构造方法不能使用 synchronized 关键字修饰。构造方法本身就属于线程安全的，不存在同步的构造方法一说。</li></ul><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><h3 id="双重校验锁实现对象单例（线程安全）"><a href="#双重校验锁实现对象单例（线程安全）" class="headerlink" title="双重校验锁实现对象单例（线程安全）"></a>双重校验锁实现对象单例（线程安全）</h3><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p><h4 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><h4 id="同步版"><a href="#同步版" class="headerlink" title="同步版"></a>同步版</h4><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="comment">//封死了</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。</p><p>但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。</p><h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><p>这就引出了双重检验锁。双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance &#x3D;&#x3D; null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;<span class="comment">//Single Checked</span></span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;<span class="comment">//Double Checked</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检验锁-volatile"><a href="#双重检验锁-volatile" class="headerlink" title="双重检验锁+volatile"></a>双重检验锁+volatile</h4><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：<br>1为 uniqueInstance 分配内存空间<br>2初始化 uniqueInstance<br>3将 uniqueInstance 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h5 id="双重校验锁为什么要判断两次？"><a href="#双重校验锁为什么要判断两次？" class="headerlink" title="双重校验锁为什么要判断两次？"></a><strong>双重校验锁为什么要判断两次？</strong></h5><p>今天写synchronized用例的时候，两个线程共享一个对象数据，当操作i的时候，在同步代码块外面判断了一次i&lt;100,但是每一次跑，都会出现i&#x3D;100,的情况，此时我想起了单例模式的双重校验锁，为什么要判断两次呢？因为可能出现线程1和线程2，在i&#x3D;99的时候，同时判断了一次，都进到了for循环里面，此时线程1进入同步代码块，线程2进如阻塞队列，当线程1跑出代码块后，线程2进入同步代码块，线程1对i进行加一操作后，i变成了100，所以线程2就输出了100，所以要在同步代码块中再加一次判断，判断i的值<br>synchronized代码块使用起来比synchronized方法要灵活得多。因为也许一个方法中只有一部分代码只需要同步，如果此时对整个方法用synchronized进行同步，会影响程序执行效率。而使用synchronized代码块就可以避免这个问题，synchronized代码块可以实现只对需要同步的地方进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SychronizedTest2</span> <span class="variable">synchronized2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SychronizedTest2</span>();</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> synchronized2.<span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                data.insert();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                data.insert();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i ++)</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!arr.contains(i))&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 正在插入&quot;</span>+i);</span><br><span class="line">                            arr.add(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-关键字的底层原理"><a href="#synchronized-关键字的底层原理" class="headerlink" title="synchronized 关键字的底层原理"></a>synchronized 关键字的底层原理</h3><h4 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：<br>1首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件<br>2然后执行javap -c -s -v -l SynchronizedDemo.class。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692227-c460e796-19dd-48fe-a4c9-e89a71684d8a.png" alt="img"></p><p>从上面我们可以看出：<br><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中：</strong></p><ul><li><strong>monitorenter 指令指向同步代码块的开始位置</strong></li><li><strong>monitorexit 指令则指明同步代码块的结束位置。</strong></li></ul><p>当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。<br>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor</a>实现的。每个对象中都内置了一个 ObjectMonitor对象。<br>另外，wait&#x2F;notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。<br>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。<br>在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h4 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692170-9fa06ca0-6bc4-49e3-9f04-2434718e51c9.png" alt="img"></p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，<br>该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h4 id="synchronized原理总结"><a href="#synchronized原理总结" class="headerlink" title="synchronized原理总结"></a>synchronized原理总结</h4><ol><li>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</li><li>修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</li><li>不过两者的本质都是对对象监视器 monitor 的获取。</li></ol><h3 id="synchronized的阻塞通知方法"><a href="#synchronized的阻塞通知方法" class="headerlink" title="synchronized的阻塞通知方法"></a>synchronized的阻塞通知方法</h3><h4 id="Object的wait方法"><a href="#Object的wait方法" class="headerlink" title="Object的wait方法"></a>Object的wait方法</h4><h4 id="Object的notify方法"><a href="#Object的notify方法" class="headerlink" title="Object的notify方法"></a>Object的notify方法</h4><h3 id="Synchronized-版生产消费问题【等待，业务，通知】"><a href="#Synchronized-版生产消费问题【等待，业务，通知】" class="headerlink" title="Synchronized 版生产消费问题【等待，业务，通知】"></a>Synchronized 版生产消费问题【等待，业务，通知】</h3><p>加锁口诀：三个单词</p><ul><li>判断（等待）</li><li>业务</li><li>通知</li></ul><h4 id="四线程Demo"><a href="#四线程Demo" class="headerlink" title="四线程Demo"></a>四线程Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们同步代码块当中的等待方法用的是wait，那wait&#x2F;sleep 有什么区别呢？</p><blockquote><p><strong>来自不同的类</strong><br>sleep 是 Thread 的静态方法，<br>wait 是 Object 的方法，任何对象实例都能调用。<br><strong>关于锁的释放</strong><br>sleep 不会释放锁，它也不需要占用锁。<br>wait 会释放锁，但调用它的前提 是当前线程占有锁，即代码要在 synchronized 中。  </p></blockquote><h4 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h4><p>上面的输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">D:\java8u211\jdk\bin\java.exe <span class="string">&quot;-javaagent:D:\idea\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=57232:D:\idea\IntelliJ IDEA 2019.1.4\bin&quot;</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath D:\java8u211\jdk\jre\lib\charsets.jar;D:\java8u211\jdk\jre\lib\deploy.jar;D:\java8u211\jdk\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\java8u211\jdk\jre\lib\ext\cldrdata.jar;D:\java8u211\jdk\jre\lib\ext\dnsns.jar;D:\java8u211\jdk\jre\lib\ext\jaccess.jar;D:\java8u211\jdk\jre\lib\ext\jfxrt.jar;D:\java8u211\jdk\jre\lib\ext\localedata.jar;D:\java8u211\jdk\jre\lib\ext\nashorn.jar;D:\java8u211\jdk\jre\lib\ext\sunec.jar;D:\java8u211\jdk\jre\lib\ext\sunjce_provider.jar;D:\java8u211\jdk\jre\lib\ext\sunmscapi.jar;D:\java8u211\jdk\jre\lib\ext\sunpkcs11.jar;D:\java8u211\jdk\jre\lib\ext\zipfs.jar;D:\java8u211\jdk\jre\lib\javaws.jar;D:\java8u211\jdk\jre\lib\jce.jar;D:\java8u211\jdk\jre\lib\jfr.jar;D:\java8u211\jdk\jre\lib\jfxswt.jar;D:\java8u211\jdk\jre\lib\jsse.jar;D:\java8u211\jdk\jre\lib\management-agent.jar;D:\java8u211\jdk\jre\lib\plugin.jar;D:\java8u211\jdk\jre\lib\resources.jar;D:\java8u211\jdk\jre\lib\rt.jar;E:\_九阴真经\juc2\kuang_livenote\【遇见狂神说】JUC视频笔记\代码\target\classes;E:\dev_dir_temp\apache-maven-<span class="number">3.3</span><span class="number">.9</span>\respository\org\projectlombok\lombok\<span class="number">1.18</span><span class="number">.8</span>\lombok-<span class="number">1.18</span><span class="number">.8</span>.jar com.kuang.pc.A</span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">A=&gt;<span class="number">2</span></span><br><span class="line">C=&gt;<span class="number">3</span></span><br><span class="line">B=&gt;<span class="number">2</span></span><br><span class="line">B=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">A=&gt;<span class="number">2</span></span><br><span class="line">C=&gt;<span class="number">3</span></span><br><span class="line">D=&gt;<span class="number">2</span></span><br><span class="line">D=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">B=&gt;-<span class="number">1</span></span><br><span class="line">B=&gt;-<span class="number">2</span></span><br><span class="line">B=&gt;-<span class="number">3</span></span><br><span class="line">D=&gt;-<span class="number">4</span></span><br><span class="line">D=&gt;-<span class="number">5</span></span><br><span class="line">D=&gt;-<span class="number">6</span></span><br><span class="line">D=&gt;-<span class="number">7</span></span><br><span class="line">D=&gt;-<span class="number">8</span></span><br><span class="line">D=&gt;-<span class="number">9</span></span><br><span class="line">D=&gt;-<span class="number">10</span></span><br><span class="line">C=&gt;-<span class="number">9</span></span><br><span class="line">A=&gt;-<span class="number">8</span></span><br><span class="line">C=&gt;-<span class="number">7</span></span><br><span class="line">A=&gt;-<span class="number">6</span></span><br><span class="line">C=&gt;-<span class="number">5</span></span><br><span class="line">A=&gt;-<span class="number">4</span></span><br><span class="line">C=&gt;-<span class="number">3</span></span><br><span class="line">A=&gt;-<span class="number">2</span></span><br><span class="line">C=&gt;-<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632577122892-fbf287e5-ece7-49c0-b518-a2ffec7050fc.png" alt="image.png"></p><p>拿两个加法线程A、B来说，比如A先执行，执行时调用了wait方法，那它会等待，此时会释放锁，那么线程B获得锁并且也会执行wait方法，<strong>两个加线程一起等待被唤醒</strong>。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，<strong>那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后B再执行。</strong></p><p>所以如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632577725001-175d394b-fca9-4fdf-ac47-066794fad3cb.png" alt="image.png"></p><h4 id="虚假唤醒修复"><a href="#虚假唤醒修复" class="headerlink" title="虚假唤醒修复"></a>虚假唤醒修复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">D:\java8u211\jdk\bin\java.exe <span class="string">&quot;-javaagent:D:\idea\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=56573:D:\idea\IntelliJ IDEA 2019.1.4\bin&quot;</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath D:\java8u211\jdk\jre\lib\charsets.jar;D:\java8u211\jdk\jre\lib\deploy.jar;D:\java8u211\jdk\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\java8u211\jdk\jre\lib\ext\cldrdata.jar;D:\java8u211\jdk\jre\lib\ext\dnsns.jar;D:\java8u211\jdk\jre\lib\ext\jaccess.jar;D:\java8u211\jdk\jre\lib\ext\jfxrt.jar;D:\java8u211\jdk\jre\lib\ext\localedata.jar;D:\java8u211\jdk\jre\lib\ext\nashorn.jar;D:\java8u211\jdk\jre\lib\ext\sunec.jar;D:\java8u211\jdk\jre\lib\ext\sunjce_provider.jar;D:\java8u211\jdk\jre\lib\ext\sunmscapi.jar;D:\java8u211\jdk\jre\lib\ext\sunpkcs11.jar;D:\java8u211\jdk\jre\lib\ext\zipfs.jar;D:\java8u211\jdk\jre\lib\javaws.jar;D:\java8u211\jdk\jre\lib\jce.jar;D:\java8u211\jdk\jre\lib\jfr.jar;D:\java8u211\jdk\jre\lib\jfxswt.jar;D:\java8u211\jdk\jre\lib\jsse.jar;D:\java8u211\jdk\jre\lib\management-agent.jar;D:\java8u211\jdk\jre\lib\plugin.jar;D:\java8u211\jdk\jre\lib\resources.jar;D:\java8u211\jdk\jre\lib\rt.jar;E:\_九阴真经\juc2\kuang_livenote\【遇见狂神说】JUC视频笔记\代码\target\classes;E:\dev_dir_temp\apache-maven-<span class="number">3.3</span><span class="number">.9</span>\respository\org\projectlombok\lombok\<span class="number">1.18</span><span class="number">.8</span>\lombok-<span class="number">1.18</span><span class="number">.8</span>.jar com.kuang.pc.A</span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线程是操作系统的最小可操作分配资源，Java的线程通过调用&lt;code&gt;Thread.start()&lt;/code&gt;启动，本质上是在调用&lt;code&gt;native&lt;/code&gt;方法&lt;code&gt;start0()&lt;/code&gt;,该方法通过&lt;code&gt;JNI(</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JUC" scheme="https://lyotoc.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://lyotoc.github.io/2022/06/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://lyotoc.github.io/2022/06/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-06-20T02:40:16.000Z</published>
    <updated>2022-06-22T07:13:20.273Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是<a href="https://so.csdn.net/so/search?q=Lambda&spm=1001.2101.3001.7020">Lambda</a>表达式</h2><blockquote><p>Lambda是一个匿名函数，可以把<code>lambda表达式</code>理解为一段可以传递的代码</p></blockquote><h2 id="初见Lambda表达式"><a href="#初见Lambda表达式" class="headerlink" title="初见Lambda表达式"></a>初见Lambda表达式</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001163917413.png" alt="img"></p><p>r1是一个Runnable接口的匿名实现类的对象，r2是使用Lambda表达式来创建对象，两个对象的效果一样，但是r2的代码明显更加简洁。这就是Lambda表达式。</p><p>化简为Lambda表达式的原则：能省就省。上图中Runnable接口只有一个需要实现的方法（即run方法），所以我们不需要写方法名就可以确定方法名（这其实就是函数式接口），由于r2是Runnable接口的对象，所以我们也可以确定类名。所以就化简为了( )→System.out.print(“xxx”);</p><p>再看个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001163952338.png" alt="img"></p><p>我们如何把上面的代码化简为Lambda表达式呢？可以看到这里仅仅多了两个参数，所以我们把两个参数加上即可：</p><p>  <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164011376.png" alt="img"></p><p>我们还有一个更加简洁的版本：方法引用</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164029882.png" alt="img"></p><p>方法引用我们后面会讲，先介绍Lambda表达式：</p><h3 id="Lambda表达式写法"><a href="#Lambda表达式写法" class="headerlink" title="Lambda表达式写法"></a>Lambda表达式写法</h3><p>( xx,xx ) - &gt; 方法体</p><p>左边：接口中抽象方法的形参列表</p><p>右边：重写接口中抽象方法的方法体</p><p>Lambda表达式的本质：作为接口的一个实例（对象）</p><p>表达式共有六种使用情况</p><h4 id="1-无参，无返回值"><a href="#1-无参，无返回值" class="headerlink" title="1. 无参，无返回值"></a>1. 无参，无返回值</h4><p>这是我们前面的Runnable接口的例子。</p><h4 id="2-一个参数，无返回值"><a href="#2-一个参数，无返回值" class="headerlink" title="2. 一个参数，无返回值"></a>2. 一个参数，无返回值</h4><p>不使用Lambda表达式：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164050287.png" alt="img"></p><p>使用Lambda表达式：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116410432.png" alt="img"></p><p>Lambda表达式的方法体中，如果只有一条语句，那么大括号写不写都行。</p><h4 id="3-数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”"><a href="#3-数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”" class="headerlink" title="3. 数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”"></a>3. 数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”</h4><p>还是上面Consumer的例子，由于Consumer中的泛型为<String>，编译器可以推断出参数类型为String，所以我们不需要在Lambda表达式的形参列表中声明String，</p><p>类型推断的另一个例子：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164137508.png" alt="img"></p><p>由于泛型中已经声明了String，我们就不需要在后面的&lt;&gt;中声明String了。</p><h4 id="4-Lambda表达式如果只有一个参数，那么参数的小括号可以省略"><a href="#4-Lambda表达式如果只有一个参数，那么参数的小括号可以省略" class="headerlink" title="4. Lambda表达式如果只有一个参数，那么参数的小括号可以省略"></a>4. Lambda表达式如果只有一个参数，那么参数的小括号可以省略</h4><p>还是Cosnumer的例子，省略小括号后：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164220606.png" alt="img"></p><h4 id="5-Lambda有多个参数，有返回值"><a href="#5-Lambda有多个参数，有返回值" class="headerlink" title="5. Lambda有多个参数，有返回值"></a>5. Lambda有多个参数，有返回值</h4><p><strong>不使用Lambda表达式：</strong><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116422960.png" alt="img"></p><p><strong>使用Lambda表达式：</strong><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164238120.png" alt="img"></p><p>由于类型推断，我们可以把o1和o2的类型省略。</p><p>如果实现的compare方法中有多个语句，那么我们不能省略方法体的大括号和return关键字：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164253242.png" alt="img"></p><h4 id="6-当Lambda方法体只有一条语句，那么return和大括号都可以省略"><a href="#6-当Lambda方法体只有一条语句，那么return和大括号都可以省略" class="headerlink" title="6. 当Lambda方法体只有一条语句，那么return和大括号都可以省略"></a>6. 当Lambda方法体只有一条语句，那么return和大括号都可以省略</h4><p>这就是上面的comparator例子：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164305622.png" alt="img"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Lambda表达式：(形参列表) - &gt; { 方法体 }</p><p>本质：接口的实例对象。</p><p><strong>对于接口的要求：要求此接口必须只声明了一个抽象方法（这就是函数式接口）。</strong>上面的例子中的接口，我们看源码的话会发现接口上都有一个注解*@FunctionalInterface*，表明这是一个函数式接口。这个注解仅仅是为了检验此接口是否为函数式接口，不加也行。</p><p>形参列表：参数类型可以省略；如果参数列表只有一个参数，那么小括号也可以省略，没有参数或者有一个以上的参数就不能省略小括号。</p><p>方法体：如果方法体只有一条执行语句，则可以省略大括号和return关键字。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>只声明了一个抽象方法的接口。java不仅支持面向对象编程（OOP）也可以面向函数编程（OOF）</p><p>Lambda表达式就是一个函数式接口的对象。</p><p>以前用匿名实现类表示的现在都可以用Lambda表达式来写。</p><h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><p>四大函数式接口指的是<code>Consumer</code>、<code>Function</code>、<code>Predicate</code>、<code>Supplier</code>，位于<code>java.util.function</code>包下</p><p>第一种：<strong>Consumer&lt;T&gt;</strong>:消费型接口      void accept(T t);</p><p>第二种：<strong>Supplier&lt;T&gt;</strong>:供给型接口      T get();</p><p>第三种：<strong>Function&lt;T,R&gt;</strong>:函数型接口 ，T为自变量，R为因变量     R apply(T t);</p><p>第四种：<strong>Predicate&lt;T&gt;</strong>:断言型接口 boolean test(T t)</p><p>消费型接口示例：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164346440.png" alt="img"></p><p>断言型接口示例：</p><p>定义一个方法，第二个参数为断言型接口，想要实现的功能为：基于某种规则pre，来筛选list中符合规则的字符串。<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164354200.png" alt="img"></p><p>筛选规则我们可以通过Lambda表达式来实现：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164400502.png" alt="img"></p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="使用情形"><a href="#使用情形" class="headerlink" title="使用情形"></a>使用情形</h3><p>当要传递给Lambda表达式方法体的操作，已经有实现的方法了，此时可以使用方法引用。</p><p>方法引用本质上就是Lambda表达式，即方法引用也是函数式接口的实例。</p><h3 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h3><p>类(或对象) : : 方法名</p><p>参数列表都不用写了</p><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><p>对于下面的情况1和情况2：<strong>要求接口中的抽象方法的形参列表和返回值，与方法引用的方法的形参列表和返回值都相同。而且本来我们Lambda表达式的方法体代码中正好用到了方法引用的方法，我们就可以使用方法引用来替换Lambda表达式。</strong></p><p>对于情况3，可以不满足上面的描述，具体往下看。</p><p>方法引用一共分为如下三种情况</p><h4 id="1-对象-非静态方法"><a href="#1-对象-非静态方法" class="headerlink" title="1. 对象 : : 非静态方法"></a>1. 对象 : : 非静态方法</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164411857.png" alt="img"></p><p>分析：Lambda表达式中的方法体为System.out.println(str)，然后调用con1的accept方法。我们发现PrintStream类中的println方法和accept方法参数列表和返回值都一样，我们可以理解为println方法已经实现了accept方法（传递给Lambda表达式方法体的操作，已经有实现的方法了），所以我们可以使用方法引用</p><p>再来看一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164417289.png" alt="img"></p><p>觉得难以理解没关系，这只是一种新的语法，逻辑上确实难以理解，用多了就懂了。</p><h4 id="2-类-静态方法"><a href="#2-类-静态方法" class="headerlink" title="2. 类 : : 静态方法"></a>2. 类 : : 静态方法</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164424105.png" alt="img"></p><p>再来一个示例：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164428981.png" alt="img"></p><h4 id="3-类-非静态方法（有难度）"><a href="#3-类-非静态方法（有难度）" class="headerlink" title="3. 类 : : 非静态方法（有难度）"></a>3. 类 : : 非静态方法（有难度）</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164437918.png" alt="img"></p><p>我们发现compare的两个参数，第一个参数可以当做调用者调用String类的compareTo方法，第二个参数仍然作为参数。这时就可以使用类：：非静态方法的形式。注意我们仍然不写compareTo的参数列表。</p><p>再看个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164443372.png" alt="img"></p><p>只有一个参数的时候，也可以用类：：非静态方法，apply方法唯一的一个参数当做getName方法的调用者。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><h3 id="1-无参构造器"><a href="#1-无参构造器" class="headerlink" title="1. 无参构造器"></a>1. 无参构造器</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164448820.png" alt="img"></p><p>可以看到Employee类的无参构造方法，和get方法一样没有参数，当new 无参构造方法( )的时候会返回一个Employee对象。当我们Lambda表达式的方法体中调用了new Employee( )的时候，就可以使用方法引用Employee : : new 。</p><h3 id="2-有参构造器"><a href="#2-有参构造器" class="headerlink" title="2. 有参构造器"></a>2. 有参构造器</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164454488.png" alt="img"></p><p>我们同样不能在方法引用上加参数，因为参数可以通过apply传递。</p><p>再来看一个两个参数的构造器：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164501688.png" alt="img"></p><h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116450739.png" alt="img"></p><p>返回值为一个数组对象，其他的和构造器引用类似。</p><p>把数组看做一个特殊的类，则写法与构造器引用一致。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>可以不会写，但是要能看懂，因为很多源码使用了Lambda表达式或者方法引用。</p><h1 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h1><h2 id="创建Stream的方式"><a href="#创建Stream的方式" class="headerlink" title="创建Stream的方式"></a>创建Stream的方式</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; stream();  返回一个顺序流</span></span><br><span class="line">Stream&lt;Employee&gt; stream0 = employees.stream();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; parallelStream(); 返回一个并行流</span></span><br><span class="line">Stream&lt;Employee&gt; stream1 = employees.parallelStream();</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java8中的Arrays的静态方法stream()可以获取数组流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Arrays.stream(arr);</span><br></pre></td></tr></table></figure><h3 id="Stream本身的of"><a href="#Stream本身的of" class="headerlink" title="Stream本身的of()"></a>Stream本身的of()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; intStream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="comment">//  public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line"><span class="comment">//遍历前10个偶数</span></span><br><span class="line"></span><br><span class="line">Stream.iterate(<span class="number">0</span>,t -&gt; t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成</span></span><br><span class="line"><span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h2><p>多个中间操作可以连接起来形成一个<strong>流水线</strong>，除非流水线线上触发终止操作，否则<strong>中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</strong></p><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filter()</td><td>接受Lambda，从流中排除某些元素</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成的hashCode()和equals()去除重复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前N个元素的流，若流中元素不足N个，则返回一个空流，与limit(n)互补</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line">list.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//distinct 去除重复元素</span></span><br><span class="line">list.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//limit 取集合中的前10个元素</span></span><br><span class="line">list.stream().limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//skip 跳过前10个元素并打印集合剩下的其它的元素</span></span><br><span class="line">list.stream().skip(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>map(Function f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td>mapToDouble(ToDoubleFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的DouleStream</td></tr><tr><td>mapToInt(ToIntFuction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的IntStream</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的LongStream</td></tr><tr><td>flatMap(Function f)</td><td>接收一个函数作为参数，将流中的每一个值都换成另一个流，然后把所有流都连接成一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map</span></span><br><span class="line">List&lt;String&gt; strs = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">strs.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"><span class="comment">//flatMap</span></span><br><span class="line"><span class="comment">//此时得到的是多个Stream组成的Stream</span></span><br><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream().map(API::formStringToStream);</span><br><span class="line">stream.forEach(item -&gt; item.forEach(System.out::println));</span><br><span class="line"><span class="comment">//若使用flatMap则会自动拆箱，对元素进行操作，得到的是一个内含元素的stream</span></span><br><span class="line">Stream&lt;Character&gt; stream1 = list.stream().flatMap(API::formStringToStream);</span><br><span class="line">stream1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">formStirngToStream</span><span class="params">(Stirng str)</span>&#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">for</span>(Character c : str.toCharArray())&#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sorted() 自然排序</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">10</span>,<span class="number">43</span>,<span class="number">65</span>,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">list.stream().sorted().froEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于未实现Comparable接口的类使用sorted会抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sorted(Comparator com) 定制排序</span></span><br><span class="line">List&lt;Employee&gt; employees = Employee.getEmployees();</span><br><span class="line">employees.stream.sorted((e1,e2) -&gt; Integer.compare(e1.getAge,e2.getAge)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="Stream的终止操作"><a href="#Stream的终止操作" class="headerlink" title="Stream的终止操作"></a>Stream的终止操作</h2><blockquote><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List,Integer,甚至是void。</p><p>流进行了终止操作后，不能再次使用。</p></blockquote><h3 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中的元素的总个数</td></tr><tr><td>max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>min(Comparator c)</td><td>返回流中的最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allMatch(Predicate p) 检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">// 是否所有的员工的年龄都大于18岁</span></span><br><span class="line"><span class="type">blooean</span> <span class="variable">allMatch</span> <span class="operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//anyMatch(Predicate p)  检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">//是否存在员工的工资大于 10000</span></span><br><span class="line"><span class="type">blooean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> employees.stream().anyMatch(e-&gt;e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//noneMatch(Predicate p)检查是否没有匹配所有元素</span></span><br><span class="line"><span class="comment">//是否存在员工姓“雷”</span></span><br><span class="line"><span class="type">boolean</span> employees.stream().noneMatch(e -&gt; e.getName().startWith(“雷”));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//findFirst()返回第一个元素</span></span><br><span class="line">Optional&lt;Employee&gt; employee = employees.stream().findFrist();</span><br><span class="line"><span class="comment">//findAny()返回当前流中的任意一个元素</span></span><br><span class="line">Optional&lt;Employee&gt; employee = employees.parallelStream().findAny();</span><br><span class="line"><span class="comment">//count()返回流中的元素的总个数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line"><span class="comment">//max(Comparator c)返回流中最大值</span></span><br><span class="line"><span class="comment">//返回最高的工资</span></span><br><span class="line">Optional&lt;Double&gt; maxSalary = employees.stream().map(Employee::getSalary).max(Double::compare);</span><br><span class="line"><span class="comment">//min(Comparator c)返回流中的最小值</span></span><br><span class="line"><span class="comment">//返回最低工资员工</span></span><br><span class="line">Optional&lt;Double&gt; minSalaryEmp = employees.stream().min((e1,e2) -&gt;Double.compare(e1.getSalary(),e2.getSalary()));</span><br><span class="line"><span class="comment">//forEach(Consumer c) 内部迭代</span></span><br><span class="line">employees.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">//使用集合的遍历操作</span></span><br><span class="line">employees.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduce(T iden, BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回T</span></span><br><span class="line"><span class="comment">//计算自然数的和</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>,Integer::sum);</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce(BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span></span><br><span class="line">Optional&lt;Double&gt; sumMoney = employees.stream().map(Employee::getSalary).reduce(Double::sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220622144546304.png" alt="image-20220622144546304"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220622144706835.png" alt="image-20220622144706835"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">List&lt;Employee&gt; emps = employees.stream().filter(e-&gt;e.getSalary()&gt;<span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><blockquote><p>到目前为止，臭名昭著的空指针异常是导致Jva应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式米防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java8类库的一部分。Optional&lt;T&gt;类(Gava.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null,表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</p><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true,调用get()方法会返回该对象。</p></blockquote><p>● Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><ul><li><p><strong>创建Optional类对象的方法</strong></p><ul><li>Optional.of(Tt):创建一个Optional实例，t必须非空；</li><li>Optional.empty):创建一个空的Optional实例</li><li>Optional.ofNullable(T t):t可以为null</li></ul></li><li><p><strong>判断Optional容器中是否包含对象：</strong></p><ul><li>boolean isPresent():判断是否包含对象</li><li>void ifPresent(Consumer&lt;?super T&gt;consumer):如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ul></li><li><p><strong>获取Optional容器的对象：</strong></p><ul><li><p>Tget():如果调用对象包含值，返回该值，否则抛异常</p></li><li><p>T orElse(T other):如果有值则将其返回，否则返回指定的other对象。</p></li><li><p>T orElseGet( Supplier&lt;?extends T下other)：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</p></li><li><p>T orElseThrow(Supplier&lt;?extends X&gt;exceptionSupplier):如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</p></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;h2 id=&quot;什么是Lambda表达式&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>k8s使用及理解</title>
    <link href="https://lyotoc.github.io/2022/06/15/k8s%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%90%86%E8%A7%A3/"/>
    <id>https://lyotoc.github.io/2022/06/15/k8s%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%90%86%E8%A7%A3/</id>
    <published>2022-06-15T09:26:29.000Z</published>
    <updated>2022-06-27T06:58:26.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PART1-概念"><a href="#PART1-概念" class="headerlink" title="PART1 概念"></a>PART1 概念</h1><h2 id="K8S概述和特性"><a href="#K8S概述和特性" class="headerlink" title="K8S概述和特性"></a>K8S概述和特性</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>容器化集群管理系统</p></li><li><p>部署应用容器化</p></li><li><p>利于应用扩展</p></li><li><p>让部署容器化应用更加简洁和高效</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>自动装箱</p><ul><li>基于容器对应用运行环境的资源配置要求自动部署应用容器</li></ul></li><li><p>自我修复<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928101336750.png" alt="image-20200928101336750"></p><ul><li>容器失败时，会重启该容器</li><li>运行Node节点出现问题时，会重新调度、部署<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122112241092.png" alt="image-20201122112241092"></li><li>当容器未通过监控检查时，会关闭该容器直到正常运行，才会对外提供服务</li></ul></li><li><p>水平扩展</p><ul><li>通过简单的命令、用户UI界面或基于CPU等资源的使用情况，对应用容器扩容或剪裁<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122112301750.png" alt="image-20201122112301750"></li></ul></li><li><p>服务发现</p><ul><li>用户不需使用额外的服务发现机制，就能够基于Kubernetes自身能力实现服务发现和负载均衡<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928101711968.png" alt="image-20200928101711968"></li></ul></li><li><p>滚动更新</p><ul><li><p>可以根据应用的变化，对应用容器运行的应用进行一次或批量式更新</p><blockquote><p>添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用</p></blockquote></li></ul></li><li><p>版本回退</p><ul><li>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li></ul></li><li><p>密钥和配置管理</p><ul><li>在不需要重新构建镜像的情况下，可以部署和更新密钥及应用配置，类似热部署</li></ul></li><li><p>存储编排</p><ul><li>提供一次性任务、定时任务，满足批量数据处理和分析的场景</li></ul></li></ul><h2 id="K8S架构组件"><a href="#K8S架构组件" class="headerlink" title="K8S架构组件"></a>K8S架构组件</h2><h3 id="完整架构图"><a href="#完整架构图" class="headerlink" title="完整架构图"></a><strong>完整架构图</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928103059652.png" alt="完整的架构图"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110124821.png" alt="image-20200928110124821"></p><h3 id="架构细节"><a href="#架构细节" class="headerlink" title="架构细节"></a>架构细节</h3><p>K8S架构主要包含两部分：<code>Master</code>（<strong>主控节点</strong>）和 <code>node</code>（<strong>工作节点</strong>）</p><p><strong>master节点架构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122113057343.png" alt="master节点架构图"></p><p><strong>Node节点架构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122155629990.png" alt="image-20201122155629990"></p><p>k8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；</p><ul><li><strong>master</strong>：主控节点<ul><li>API Server：集群统一入口，以restful风格进行操作，同时交给etcd存储<ul><li>提供认证、授权、访问控制、API注册和发现等机制</li></ul></li><li>scheduler：节点的调度，选择node节点应用部署</li><li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li><li>etcd：存储系统，用于保存集群中的相关数据</li></ul></li><li><strong>Work node</strong>：工作节点<ul><li>Kubelet：master派到node节点代表，管理本机容器<ul><li>一个集群中每个节点上运行的代理，它保证容器都运行在Pod中</li><li>负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理</li></ul></li><li>kube-proxy：提供网络代理，负载均衡等操作</li></ul></li><li>容器运行环境【<strong>Container Runtime</strong>】<ul><li>容器运行环境是负责运行容器的软件</li><li>Kubernetes支持多个容器运行环境：Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。</li></ul></li><li>fluentd：是一个守护进程，它有助于提升 集群层面日志</li></ul><h2 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul><li><p>Pod是K8s中最小的单元</p></li><li><p>一组容器的集合</p></li><li><p>共享网络【一个Pod中的所有容器共享同一网络】</p></li><li><p>生命周期是短暂的（服务器重启后，就找不到了）</p></li></ul><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><ul><li>声明在Pod容器中可访问的文件目录</li><li>可以被挂载到Pod中一个或多个容器指定路径下</li><li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>确保预期的pod副本数量【ReplicaSet】</li><li>无状态应用部署【Deployment】<ul><li>无状态就是指，不需要依赖于网络或者ip</li></ul></li><li>有状态应用部署【StatefulSet】<ul><li>有状态需要特定的条件</li></ul></li><li>确保所有的node运行同一个pod 【DaemonSet】</li><li>一次性任务和定时任务【Job和CronJob】</li></ul><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><ul><li>定义一组Pod副本数目，版本等</li><li>通过控制器【Controller】维持Pod数目【自动回复失败的Pod】</li><li>通过控制器以指定的策略控制版本【滚动升级、回滚等】<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161601349.png" alt="image-20201122161601349"></li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul><li>定义一组pod的访问规则</li><li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li><li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161132055.png" alt="image-20201122161132055"></p><p>可以用来组合pod，同时对外提供服务</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>label：标签，用于对象资源查询，筛选</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161713638.png" alt="image-20201122161713638"></p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制【鉴权、资源】</li><li>每个资源都属于一个namespace</li><li>同一个namespace所有资源不能重复</li><li>不同namespace可以资源名重复</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>我们通过Kubernetes的API来操作整个集群</p><p>同时我们可以通过 kubectl 、ui、curl 最终发送 http + json&#x2F;yaml 方式的请求给API Server，然后控制整个K8S集群，K8S中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述</p><p>如下：使用yaml部署一个nginx的pod</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122162612448.png" alt="image-20201122162612448"></p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122163512535.png" alt="image-20201122163512535"></p><ul><li>通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APlserver写入etcd</li><li>此时Controller Manager通过API Server的监听资源变化的接口监听到此RC事件</li><li>分析之后，发现当前集群中还没有它所对应的Pod实例</li><li>于是根据RC里的Pod模板定义一个生成Pod对象，通过APIServer写入etcd</li><li>此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，然后通过API Server讲这一结果写入etcd中</li><li>目标Node上运行的Kubelet进程通过APiserver监测到这个”新生的Pod.并按照它的定义，启动该Pod并任劳任怨地负责它的下半生，直到Pod的生命结束</li><li>随后，我们通过Kubectl提交一个新的映射到该Pod的Service的创建请求</li><li>ControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的Endpoints信息，并通过APIServer写入到etod中，</li><li>接下来，所有Node上运行的Proxy进程通过APIServer查询并监听Service对象与其对应的Endponts信息，建立一个软件方式的负载均衡器来实现Service访问到后端Pod的流量转发功能</li></ul><h1 id="PART2-搭建K8S集群"><a href="#PART2-搭建K8S集群" class="headerlink" title="PART2  搭建K8S集群"></a>PART2  搭建K8S集群</h1><h2 id="搭建k8s环境平台规划"><a href="#搭建k8s环境平台规划" class="headerlink" title="搭建k8s环境平台规划"></a>搭建k8s环境平台规划</h2><h3 id="单master集群"><a href="#单master集群" class="headerlink" title="单master集群"></a>单master集群</h3><p>单个<code>master</code>节点，然后管理多个<code>node</code>节点</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110456495.png" alt="image-20200928110456495"></p><p><strong>该模型下存在较为明显且致命的缺点</strong></p><ul><li>由于是只有一个master节点做node节点的集群管理，在此模型下如果master节点发生故障宕机时，则无法对node节点做管理</li></ul><h3 id="多master集群"><a href="#多master集群" class="headerlink" title="多master集群"></a>多master集群</h3><p>多个master节点，管理多个node节点，同时中间多了一个负载均衡的过程</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110543829.png" alt="image-20200928110543829"></p><h3 id="服务器硬件配置要求"><a href="#服务器硬件配置要求" class="headerlink" title="服务器硬件配置要求"></a>服务器硬件配置要求</h3><h4 id="最低要求"><a href="#最低要求" class="headerlink" title="最低要求"></a>最低要求</h4><table><thead><tr><th>节点</th><th>要求</th></tr></thead><tbody><tr><td>master</td><td>2核 4G 20G</td></tr><tr><td>node</td><td>4核 8G 40G</td></tr></tbody></table><h3 id="部署Kubernetes集群主要的两种方式"><a href="#部署Kubernetes集群主要的两种方式" class="headerlink" title="部署Kubernetes集群主要的两种方式"></a>部署Kubernetes集群主要的两种方式</h3><h4 id="Kubeadm"><a href="#Kubeadm" class="headerlink" title="Kubeadm"></a>Kubeadm</h4><ol><li><p>介绍kubeadm是一个K8S部署工具，提供kubeadm init 和 kubeadm join，用于快速部署Kubernetes集群</p><p>官网地址：<a href="https://gitee.com/link?target=https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">点我传送</a></p></li></ol><h4 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h4><p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p><p>Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p><h3 id="Kubeadm部署集群"><a href="#Kubeadm部署集群" class="headerlink" title="Kubeadm部署集群"></a>Kubeadm部署集群</h3><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p><ul><li>创建一个Master 节点kubeadm init</li><li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li></ul><h3 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h3><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p><ul><li>一台或多台机器，操作系统为Centos7.X</li><li>硬件配置：2GB或更多GAM，2个CPU或更多CPU，硬盘30G</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>192.168.177.130</td></tr><tr><td>node1</td><td>192.168.177.131</td></tr><tr><td>node2</td><td>192.168.177.132</td></tr></tbody></table><p>然后开始在每台机器上执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭selinux</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久关闭</span></span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭swap</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时</span></span><br><span class="line">swapoff -a </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久关闭</span></span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据规划设置主机名【master节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8smaster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据规划设置主机名【node1节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8snode1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据规划设置主机名【node2节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8snode2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在master添加hosts</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.177.130 k8smaster</span><br><span class="line">192.168.177.131 k8snode1</span><br><span class="line">192.168.177.132 k8snode2</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将桥接的IPv4流量传递到iptables的链</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效</span></span><br><span class="line">sysctl --system  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间同步</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装Docker-x2F-kubeadm-x2F-kubelet"><a href="#安装Docker-x2F-kubeadm-x2F-kubelet" class="headerlink" title="安装Docker&#x2F;kubeadm&#x2F;kubelet"></a>安装Docker&#x2F;kubeadm&#x2F;kubelet</h3><p>所有节点安装Docker&#x2F;kubeadm&#x2F;kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>首先配置一下Docker的阿里yum源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name=Docker CE Edge - \$basearch</span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后yum方式安装docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># yum安装</span><br><span class="line">yum -y install docker-ce</span><br><span class="line"></span><br><span class="line"># 查看docker版本</span><br><span class="line">docker --version  </span><br><span class="line"></span><br><span class="line"># 启动docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>配置docker的镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后重启docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="添加kubernetes软件源"><a href="#添加kubernetes软件源" class="headerlink" title="添加kubernetes软件源"></a>添加kubernetes软件源</h3><p>然后我们还需要配置一下yum的k8s软件源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="安装kubeadm，kubelet和kubectl"><a href="#安装kubeadm，kubelet和kubectl" class="headerlink" title="安装kubeadm，kubelet和kubectl"></a>安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装kubelet、kubeadm、kubectl，同时指定版本</span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"># 设置开机启动</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><h3 id="部署Kubernetes-Master【master节点】"><a href="#部署Kubernetes-Master【master节点】" class="headerlink" title="部署Kubernetes Master【master节点】"></a>部署Kubernetes Master【master节点】</h3><p>在 192.168.177.130 执行，也就是master节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094302491.png" alt="image-20200929094302491"></p><p>当我们出现下面的情况时，表示kubernetes的镜像已经安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094620145.png" alt="image-20200929094620145"></p><p>使用kubectl工具 【master节点操作】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>执行完成后，我们使用下面命令，查看我们正在运行的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094933142.png" alt="2"></p><p>能够看到，目前有一个master节点已经运行了，但是还处于未准备状态</p><p>下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上</p><h3 id="加入Kubernetes-Node【Slave节点】"><a href="#加入Kubernetes-Node【Slave节点】" class="headerlink" title="加入Kubernetes Node【Slave节点】"></a>加入Kubernetes Node【Slave节点】</h3><p>下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点</p><p>执行在kubeadm init输出的kubeadm join命令：</p><blockquote><p>注意，以下的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</span><br></pre></td></tr></table></figure><p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><p>当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113165358663.png" alt="image-20201113165358663"></p><h3 id="部署CNI网络插件"><a href="#部署CNI网络插件" class="headerlink" title="部署CNI网络插件"></a>部署CNI网络插件</h3><p>上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载网络插件配置</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">##①首先下载v0.13.1-rc2-amd64 镜像</span><br><span class="line">##参考博客：https://www.cnblogs.com/pyxuexi/p/14288591.html</span><br><span class="line">##② 导入镜像，命令，，特别提示，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，重要的事情说3遍。不然抱错。如果没有操作，报错后，需要删除节点，重置，在导入镜像，重新加入才行。本地就是这样操作成功的！</span><br><span class="line">docker load &lt; flanneld-v0.13.1-rc2-amd64.docker</span><br><span class="line">#####下载本地，替换将image: quay.io/coreos/flannel:v0.13.1-rc2 替换为 image: quay.io/coreos/flannel:v0.13.1-rc2-amd64</span><br><span class="line"></span><br><span class="line"># 查看状态 【kube-system是k8s中的最小单元】</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure><p>运行后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113165929510.png" alt="image-20201113165929510"></p><p>运行完成后，我们查看状态可以发现，已经变成了Ready状态了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113194557147.png" alt="image-20201113194557147"></p><p>如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> master节点将该节点删除</span><br><span class="line"></span><br><span class="line">##20210223 yan 查阅资料添加###kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line"></span><br><span class="line">kubectl delete node k8snode1</span><br><span class="line"> </span><br><span class="line"># 然后到k8snode1节点进行重置</span><br><span class="line"> kubeadm reset</span><br><span class="line"># 重置完后在加入</span><br><span class="line">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</span><br></pre></td></tr></table></figure><h3 id="测试kubernetes集群"><a href="#测试kubernetes集群" class="headerlink" title="测试kubernetes集群"></a>测试kubernetes集群</h3><p>我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动</p><p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载nginx 【会联网拉取nginx镜像】</span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"># 查看状态</span><br><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p>如果我们出现Running状态的时候，表示已经成功运行了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113203537028.png" alt="image-20201113203537028"></p><p>下面我们就需要将端口暴露出去，让其它外界能够访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 暴露端口</span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line"># 查看一下对外的端口</span><br><span class="line">kubectl get pod,svc</span><br></pre></td></tr></table></figure><p>能够看到，我们已经成功暴露了 80端口 到 30529上</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113203840915.png" alt="image-20201113203840915"></p><p>我们到我们的宿主机浏览器上，访问如下地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.177.130:30529/</span><br></pre></td></tr></table></figure><p>发现我们的nginx已经成功启动了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113204056851.png" alt="image-20201113204056851"></p><p>到这里为止，我们就搭建了一个单master的k8s集群</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113204158884.png" alt="image-20201113204158884"></p><h3 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h3><h4 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h4><p>在执行Kubernetes init方法的时候，出现这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</span><br></pre></td></tr></table></figure><p>是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可</p><h4 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h4><p>我们在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR Swap]: running with swap on is not supported. Please disable swap</span><br></pre></td></tr></table></figure><p>错误原因是我们需要关闭swap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 关闭swap</span><br><span class="line"># 临时</span><br><span class="line">swapoff -a </span><br><span class="line"># 临时</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h4 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h4><p>在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused</span><br></pre></td></tr></table></figure><p>解决方法，首先需要到 master 节点，创建一个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件夹</span><br><span class="line">mkdir /etc/systemd/system/kubelet.service.d</span><br><span class="line"></span><br><span class="line"># 创建文件</span><br><span class="line">vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line"># 添加如下内容</span><br><span class="line">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;</span><br><span class="line"></span><br><span class="line"># 重置</span><br><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><p>然后删除刚刚创建的配置目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.kube</span><br></pre></td></tr></table></figure><p>然后 在master重新初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5</span><br></pre></td></tr></table></figure><p>添加完成后，我们使用下面命令，查看节点是否成功添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h4 id="错误四"><a href="#错误四" class="headerlink" title="错误四"></a>错误四</h4><p>我们再执行查看节点的时候， kubectl get nodes 会出现问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;)</span><br></pre></td></tr></table></figure><p>这是因为我们之前创建的配置文件还存在，也就是这些配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>我们需要做的就是把配置文件删除，然后重新执行一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.kube</span><br></pre></td></tr></table></figure><p>然后再次创建一下即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME&#x2F;.kube 给移除掉，再次创建时就会出现问题了</p><h4 id="错误五"><a href="#错误五" class="headerlink" title="错误五"></a>错误五</h4><p>安装的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Another app is currently holding the yum lock; waiting for it to exit...</span><br></pre></td></tr></table></figure><p>是因为yum上锁占用，解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><h4 id="错误六"><a href="#错误六" class="headerlink" title="错误六"></a>错误六</h4><p>在使用下面命令，添加node节点到集群上的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb  --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span><br></pre></td></tr></table></figure><p>然后出现了这个错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8smaster ~]# kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb     --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span><br><span class="line">W1117 06:55:11.220907   11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p>出于安全考虑，Linux系统<strong>默认是禁止数据包转发</strong>的。所谓<strong>转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包</strong>。这通常就是路由器所要实现的功能。也就是说 <strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</strong> 文件的值不支持转发</p><ul><li>0：禁止</li><li>1：转发</li></ul><p>所以我们需要将值修改成1即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>修改完成后，重新执行命令即可</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PART1-概念&quot;&gt;&lt;a href=&quot;#PART1-概念&quot; class=&quot;headerlink&quot; title=&quot;PART1 概念&quot;&gt;&lt;/a&gt;PART1 概念&lt;/h1&gt;&lt;h2 id=&quot;K8S概述和特性&quot;&gt;&lt;a href=&quot;#K8S概述和特性&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="k8s" scheme="https://lyotoc.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>JVM原理</title>
    <link href="https://lyotoc.github.io/2022/06/14/JVM%E5%8E%9F%E7%90%86/"/>
    <id>https://lyotoc.github.io/2022/06/14/JVM%E5%8E%9F%E7%90%86/</id>
    <published>2022-06-14T07:08:37.000Z</published>
    <updated>2022-07-15T01:51:20.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM原理"><a href="#JVM原理" class="headerlink" title="JVM原理"></a>JVM原理</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220715095030245.png" alt="image-20220715095030245"></p><h3 id="Java内存区域的分配"><a href="#Java内存区域的分配" class="headerlink" title="Java内存区域的分配"></a>Java内存区域的分配</h3><p>JVM虚拟机内存模型实现规范：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/JVM1.8.png"></p><p>按线程是否共享分为以下区域：</p><p>所有线程共享的数据区：</p><ul><li><p>方法区（JVM规范中的一部分，不是实际的实现）: 存储每一个类的结构信息（运行时常量池、静态变量、方法数据、构造函数和普通方法的字节码、JIT编译后的代码)，没有要求使用垃圾回收因为回收效率太低。（运行时常量池：存放编译器生成的各种字面量和符号引用，在类加载后放到运行时常量池中）</p></li><li><p>堆区: 最大的一块区域，是大部分类实例、对象、数组分配内存的区域，没有限制只能将对象分配在堆，所以出现逃逸分析的技术</p></li></ul><p>每个线程都会有一块私有的数据区： </p><ul><li><p>虚拟机栈: 虚拟机栈与线程同时创建，每个方法在执行时在其中创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法返回地址。正常调用完成后恢复调用者的局部变量表、操作数栈、递增程序计数器来跳过刚才执行的指令，或抛出异常不将返回值返回给调用者</p></li><li><p>本地方法栈: 功能与虚拟机栈相同，为native方法服务</p></li><li><p>pc寄存器: 任意时刻线程只会执行一个方法的代码，如果不是native的，就存放当前正在执行的字节码指令的地址，如果是native，则是undefined</p></li></ul><p>以HotSpot虚拟机实现为例，Java8中内存区域如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655346980098.jpg"></p><p>与规范中的区别：</p><ul><li><p>直接内存：非Java标准，是JVM以外的本地内存，在Java4出现的NIO中，为了防止Java堆和Native堆之间往复的数据复制带来的性能损耗，此后NIO可以使用Native的方式直接在Native堆分配内存。JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。</p></li><li><p>元数据区（方法区的实现）：Java7以及之前是使用的永久代来实现方法区，大小是在启动时固定的。Java8中用元空间替代了永久代，元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性。元空间存储JIT即时编译后的native代码，可能还存在短指针数据区CCS</p></li><li><p>堆区: Java7之后运行时常量池从方法区移到这里，为Java8移除永久带的做好准备</p></li></ul><h3 id="Java对象不都是分配在堆上"><a href="#Java对象不都是分配在堆上" class="headerlink" title="Java对象不都是分配在堆上"></a>Java对象不都是分配在堆上</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸是指在某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收。由于其被其它变量引用，由于无法回收，即称为逃逸。</p><p>逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁。</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><ul><li><p>加载（获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象）</p></li><li><p>验证（验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全）</p></li><li><p>准备（为类变量分配内存并设置初始值）</p></li><li><p>解析（将常量池的符号引用替换为直接引用，符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针）</p></li><li><p>初始化（执行类构造器、类变量赋值、静态语句块）</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>启动类加载器：用C++语言实现，是虚拟机自身的一部分，它负责将 <JAVA_HOME>&#x2F;lib路径下的核心类库，无法被Java程序直接引用<br>扩展类加载器：用Java语言实现，它负责加载<JAVA_HOME>&#x2F;lib&#x2F;ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用<br>系统类加载器：用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用</p><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>定义：如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是<strong>双亲委派模式</strong>。</p><p>优点：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次防止恶意覆盖Java核心API。</p><p>三次大型破坏双亲委派模式的事件：</p><ul><li><p>在双亲委派模式出来之前，用户继承ClassLoader就是为了重写loadClass方法，但双亲委派模式需要这个方法，所以1.2之后添加了findClass供以后的用户重写</p></li><li><p>如果基础类要调回用户的代码，如JNDI&#x2F;JDBC需要调用ClassPath下的自己的代码来进行资源管理，Java团队添加了一个线程上下文加载器，如果该加载器没有被设置过，那么就默认是应用程序类加载器</p></li><li><p>为了实现代码热替换，OSGi是为了实现自己的类加载逻辑，用平级查找的逻辑替换掉了向下传递的逻辑。但其实可以不破坏双亲委派逻辑而是自定义类加载器来达到代码热替换。比如<a href="https://www.cnblogs.com/pfxiong/p/4070462.html">这篇文章</a></p></li></ul><h3 id="内存分配（堆上的内存分配）"><a href="#内存分配（堆上的内存分配）" class="headerlink" title="内存分配（堆上的内存分配）"></a>内存分配（堆上的内存分配）</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655346667997.jpg"></p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><h5 id="进入条件"><a href="#进入条件" class="headerlink" title="进入条件"></a>进入条件</h5><p>优先选择在新生代的Eden区被分配。</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h5 id="进入条件-1"><a href="#进入条件-1" class="headerlink" title="进入条件"></a>进入条件</h5><ul><li><p>大对象，-XX:PretenureSizeThreshold 大于这个参数的对象直接在老年代分配，来避免新生代GC以及分配担保机制和Eden与Survivor之间的复制</p></li><li><p>经过第一次Minor GC仍然存在，能被Survivor容纳，就会被移动到Survivor中，此时年龄为1，当年龄大于预设值就进入老年代  </p></li><li><p>如果Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象进入老年代  </p></li><li><p>如果Survivor空间无法容纳新生代中Minor GC之后还存活的对象</p></li></ul><h3 id="GC回收机制"><a href="#GC回收机制" class="headerlink" title="GC回收机制"></a>GC回收机制</h3><h4 id="回收对象"><a href="#回收对象" class="headerlink" title="回收对象"></a>回收对象</h4><p>不可达对象：通过一系列的GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时则此对象是不可用的。<br>GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。</p><p>彻底死亡条件：<br>条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。<br>条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。</p><h4 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h4><p>新生代因为每次GC都有大批对象死去，只需要付出少量存活对象的复制成本且无碎片所以使用“复制算法”<br>老年代因为存活率高、没有分配担保空间，所以使用“标记-清理”或者“标记-整理”算法</p><p>复制算法：将可用内存按容量划分为Eden、from survivor、to survivor，分配的时候使用Eden和一个survivor，Minor GC后将存活的对象复制到另一个survivor，然后将原来已使用的内存一次清理掉。这样没有内存碎片。<br>标记-清除：首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象。会产生大量碎片，导致无法分配大对象从而导致频繁GC。<br>标记-整理：首先标记出所有需要回收的对象，让所有存活的对象向一端移动。</p><h4 id="Minor-GC条件"><a href="#Minor-GC条件" class="headerlink" title="Minor GC条件"></a>Minor GC条件</h4><p>当Eden区空间不足以继续分配对象，发起Minor GC。</p><h4 id="Full-GC条件"><a href="#Full-GC条件" class="headerlink" title="Full GC条件"></a>Full GC条件</h4><ul><li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行</p></li><li><p>老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）</p></li><li><p>方法区空间不足</p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>串行收集器Serial是最古老的收集器，只使用一个线程去回收，可能会产生较长的停顿</p><p>新生代使用Serial收集器<code>复制</code>算法、老年代使用Serial Old<code>标记-整理</code>算法</p><p>参数：<code>-XX:+UseSerialGC</code>，默认开启<code>-XX:+UseSerialOldGC</code></p><h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><p>并行收集器Parallel关注<strong>可控的吞吐量</strong>，能精确地控制吞吐量与最大停顿时间是该收集器最大的特点，也是1.8的Server模式的默认收集器，使用多线程收集。ParNew垃圾收集器是Serial收集器的多线程版本。</p><p>新生代<code>复制</code>算法、老年代<code>标记-整理</code>算法</p><p>参数：<code>-XX:+UseParallelGC</code>，默认开启<code>-XX:+UseParallelOldGC</code></p><h3 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h3><p>并发收集器CMS是以<strong>最短停顿时间</strong>为目标的收集器。G1关注能在大内存的前提下精确控制<strong>停顿时间</strong>且垃圾回收效率高。</p><p>CMS针对老年代，有初始标记、并发标记、重新标记、并发清除四个过程，标记阶段会Stop The World，使用<code>标记-清除</code>算法，所以会产生内存碎片。</p><p>参数：<code>-XX:+UseConcMarkSweepGC</code>，默认开启<code>-XX:+UseParNewGC</code></p><p>G1将堆划分为多个大小固定的独立区域，根据每次允许的收集时间优先回收垃圾最多的区域，使用<code>标记-整理</code>算法，是1.9的Server模式的默认收集器</p><p>参数：<code>-XX:+UseG1GC</code></p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互</p><p>STW总会发生，不管是新生代还是老年代，比如CMS在初始标记和重复标记阶段会停顿，G1在初始标记阶段也会停顿，所以并不是选择了一款停顿时间低的垃圾收集器就可以避免STW的，我们只能尽量去减少STW的时间。</p><p>那么为什么一定要STW？因为在定位堆中的对象时JVM会记录下对所有对象的引用，如果在定位对象过程中，有新的对象被分配或者刚记录下的对象突然变得无法访问，就会导致一些问题，比如部分对象无法被回收，更严重的是如果GC期间分配的一个GC Root对象引用了准备被回收的对象，那么该对象就会被错误地回收。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a><a href="https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ">Java内存模型</a></h2><p>定义：JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性</p><p>实现：volatile、synchronized、final、concurrent包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字</p><p>主内存：所有变量都保存在主内存中<br>工作内存：每个线程的独立内存，保存了该线程使用到的变量的主内存副本拷贝，线程对变量的操作必须在工作内存中进行</p><p>每个线程都有自己的本地内存共享副本，如果A线程要更新主内存还要让B线程获取更新后的变量，那么需要：</p><ul><li><p>将本地内存A中更新共享变量</p></li><li><p>将更新的共享变量刷新到主内存中</p></li><li><p>线程B从主内存更新最新的共享变量</p></li></ul><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a><a href="https://www.cnblogs.com/chenssy/p/6393321.html">happens-before</a></h2><p>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before。特别关注在多线程之间的内存可见性。</p><p>它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。</p><ul><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p></li><li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</p></li><li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p></li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>前提：在进行GC优化之前，需要确认项目的架构和代码等已经没有优化空间</p><p>目的：优化JVM垃圾收集性能从而增大吞吐量或减少停顿时间，让应用在某个业务场景上发挥最大的价值。吞吐量是指应用程序线程用时占程序总用时的比例。暂停时间是应用程序线程让与GC线程执行而完全暂停的时间段</p><p>对于交互性web应用来说，一般都是减少停顿时间，所以有以下方法：</p><ul><li><p>如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大</p></li><li><p>让大对象进入年老代。可以使用参数-XX:PetenureSizeThreshold 设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配</p></li><li><p>设置对象进入年老代的年龄。如果对象每经过一次 GC 依然存活，则年龄再加 1。当对象年龄达到阈值时，就移入年老代，成为老年对象</p></li><li><p>使用关注系统停顿的 CMS 回收器</p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM原理&quot;&gt;&lt;a href=&quot;#JVM原理&quot; class=&quot;headerlink&quot; title=&quot;JVM原理&quot;&gt;&lt;/a&gt;JVM原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer</title>
    <link href="https://lyotoc.github.io/2022/06/07/%E5%89%91%E6%8C%87Offer/"/>
    <id>https://lyotoc.github.io/2022/06/07/%E5%89%91%E6%8C%87Offer/</id>
    <published>2022-06-07T07:08:37.000Z</published>
    <updated>2022-06-30T02:40:27.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h3><p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/"><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></a></p><blockquote><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><p>方法一：新建一个数组并利用index记录每个元素出现的次数，大于1则返回该数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">     <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">         arr[num]++;</span><br><span class="line">         <span class="keyword">if</span>(arr[num] &gt; <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用散列表的特征，hashset.add()元素重复时返回fasle,此时返回该元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></p><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。</p><p>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p></blockquote><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] nums : matrix) &#123;</span><br><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(nums, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：获得当前下标位置的元素 num<br>如果 num 和 target 相等，返回 true<br>如果 num 大于 target，列下标减 1<br>如果 num 小于 target，行下标加 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, column = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> matrix[row][column];</span><br><span class="line">            <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                column--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h3><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p><blockquote><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> a : s.toCharArray())&#123;</span><br><span class="line">           <span class="keyword">if</span>(a == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">               sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               sb.append(a);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></p><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"> 输入：head = [1,3,2]</span><br><span class="line"> 输出：[2,3,1]</span><br></pre></td></tr></table></figure></blockquote><p>方法一：递归回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[--size];</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="type">int</span>[] nums = reversePrint(head.next);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - size--;</span><br><span class="line">        nums[index] = head.val;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用栈的特性输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line"><span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h3><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></p><p><strong>方法一</strong></p><script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script> <video id="video" controls loop="false" width="100%"></video> <script>   var video = document.getElementById('video');   if(Hls.isSupported()) {   var hls = new Hls();   hls.loadSource('https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/2022_06_0812_37_16/index.m3u8');   hls.attachMedia(video);   hls.on(Hls.Events.MANIFEST_PARSED,function() {   video.pause(); }); } else if (video.canPlayType('application/vnd.apple.mpegurl')) {   video.src = 'https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/2022_06_0812_37_16/index.m3u8';   video.addEventListener('loadedmetadata',function() {   video.pause(); }); } </script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; inOrderindexMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        inOrderindexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            inOrderindexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, </span></span><br><span class="line"><span class="params">                                    <span class="type">int</span>[] inorder, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preorder[preLeft];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> inOrderindexMap.get(rootValue);</span><br><span class="line"></span><br><span class="line">        root.left = buildTree(preorder, preLeft + <span class="number">1</span>, preLeft + pIndex - inLeft, inorder, inLeft, pIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, preLeft + pIndex - inLeft + <span class="number">1</span>, preRight, inorder, pIndex + <span class="number">1</span>, inRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>这道题是一道典型的递归解法的算法题，我们可以：</p><blockquote><p>先按照前序遍历和中序遍历的特点，来模拟重建二叉树<br>在模拟的过程中，看看是否符合递归的三个特点：</p><ol><li>这个问题能不能拆分成若干个子问题，子问题解决了，那么这个问题就解决了</li><li>所有子问题的求解方法是不是和大问题的求解方法是一样的</li><li>是不是存在知道结果的最小子问题</li></ol><p>在符合上面的递归特点后，我们就专门看一个子问题的解法，根据一个子问题的解法 来实现递归的代码</p></blockquote><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h3><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></p><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inStack ;</span><br><span class="line">    Stack&lt;Integer&gt; outStack ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="built_in">this</span>.outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">     inStack.push(value);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">if</span>(inStack.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          in2Out();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in2Out</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用两个栈实现入列及出列，分别对两个栈做不同分工。</p></blockquote><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h3><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></p><blockquote><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一 动态规划</strong></p><blockquote><p>斐波那契数的边界条件是 F(0)&#x3D;0F(0)&#x3D;0F(0)&#x3D;0 和 F(1)&#x3D;1F(1)&#x3D;1F(1)&#x3D;1。当 n&gt;1n&gt;1n&gt;1 时，每一项的和都等于前两项的和，因此有如下递推关系：</p><p>F(n)&#x3D;F(n−1)+F(n−2)F(n)&#x3D;F(n-1)+F(n-2) F(n)&#x3D;F(n−1)+F(n−2)</p><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0)F(0)F(0) 和 F(1)F(1)F(1)。</p><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)O(n)O(n) 的实现。由于 F(n)F(n)F(n) 只和 F(n−1)F(n-1)F(n−1) 与 F(n−2)F(n-2)F(n−2) 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 O(1)O(1)O(1)。如下的代码中给出的就是这种实现。</p><p>计算过程中，答案需要取模 1e9+7。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/10_I_fig1.gif" alt="实现思想"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = (p + q) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：矩阵快速幂</strong></p><p>方法一的时间复杂度是 O(n)O(n)O(n)。使用矩阵快速幂的方法可以降低时间复杂度。</p><p>首先我们可以构建这样一个递推关系：<br>$$<br>\begin{bmatrix}1&amp;1\\1&amp;0 \end{bmatrix}​\begin{bmatrix}F(n)\\F(n−1) \end{bmatrix}​&#x3D;\begin{bmatrix}F(n)+F(n−1)\\F(n)\end{bmatrix}&#x3D;\begin{bmatrix}F(n+1)\\F(n)\end{bmatrix}​<br>$$<br>因此：<br>$$<br>\begin{bmatrix}F(n+1)\\F(n)\end{bmatrix} &#x3D; \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^n &#x3D; \begin{bmatrix} F(1)\\F(0)\end{bmatrix}<br>$$<br>令：<br>$$<br>M&#x3D;\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}<br>$$<br>因此只要我们能快速计算矩阵 M 的 n 次幂，就可以得到 F(n) 的值。如果直接求取<code>M^n</code>，时间复杂度是 O(n)，可以定义矩阵乘法，然后用快速幂算法来加速这里 <code>M^n</code> 的求取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span>[][] res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] pow(<span class="type">int</span>[][] a, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] multiply(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = (<span class="type">int</span>) (((<span class="type">long</span>) a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + (<span class="type">long</span>) a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]) % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h3><p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p><code>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一 动态规划</strong></p><blockquote><p>该题和上题一致，属于是斐波那契数列的变种。不过起始值是从1开始的</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/108249e4d62d429f9cd6cab5bbd6afca581ee61c7d762a4c8ea0c62e08e10762-Picture13.png" alt="青蛙跳台阶"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % mod;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;剑指-Offer-03-数组中重复的数字&quot;&gt;&lt;a href=&quot;#剑指-Offer-03-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 03. 数组中重复的数字&quot;&gt;&lt;/a&gt;剑指 Offer 03. 数组中重复的数字&lt;/h3</summary>
      
    
    
    
    <category term="面试" scheme="https://lyotoc.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="算法" scheme="https://lyotoc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
