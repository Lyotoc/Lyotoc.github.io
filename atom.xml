<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lyoto&#39;s Blog</title>
  
  
  <link href="https://lyotoc.github.io/atom.xml" rel="self"/>
  
  <link href="https://lyotoc.github.io/"/>
  <updated>2022-07-20T02:34:12.106Z</updated>
  <id>https://lyotoc.github.io/</id>
  
  <author>
    <name>Lyoto</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础全览</title>
    <link href="https://lyotoc.github.io/2022/07/15/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E8%A7%88/"/>
    <id>https://lyotoc.github.io/2022/07/15/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E8%A7%88/</id>
    <published>2022-07-15T05:35:45.000Z</published>
    <updated>2022-07-20T02:34:12.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><h3 id="Java的配置"><a href="#Java的配置" class="headerlink" title="Java的配置"></a>Java的配置</h3><ul><li><p>Java的运行机制</p><ul><li><p>java语言运行机制及运行过程</p><ul><li>Java语言运行机制及运行过程.md</li></ul></li><li><p>java基础图谱</p></li><li><p>java8.0概括图谱</p></li></ul></li><li><p>JDK的安装</p><ul><li>Java开发工具</li><li>JRE</li></ul></li><li><p>环境变量的配置</p><ul><li>path 配置至 bin目录</li><li>JAVA_HOME 配置至jdk目录</li></ul></li></ul><h3 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h3><h3 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h3><ul><li><p>基础语法</p><ul><li><p>注释及编译原理</p><ul><li><p>注释的使用</p><ul><li><p>单行注释  &#x2F;&#x2F; ……………………</p></li><li><p>多行注释  &#x2F;* ……………………*&#x2F;</p></li><li><p>文档注释 </p><p>java-文档注释    格式： &#x2F;**             @author  指定java程序的作者              @version 指定源文本的版本             等等……             *&#x2F;    文档注释的使用：         注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。         dos命令调用javadoc解析文档注释：javadoc -d filename(生成的文件夹名字) -author -version target.java(需要解析的Java文件)</p></li></ul></li><li><p>编译字节码文件</p><p>1.  一个.java文件中可编写多个类，当时只能编写一个public类2.编译后生成一个或者多个类文件，依据源代码创建的类的数目，且类文件与所创建的类文件名同名。</p></li></ul><p> </p></li><li><p>基础语法结构</p><ul><li><p>关键字&amp;保留字</p></li><li><p>标识符及命名规则</p><p>Java中的名称命名规范：    包名：多单词组成时所有字母都小写：xxyyzz    类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz    变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz    常量名：所有之母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p></li><li><p>变量</p><ul><li><p>变量类型</p><ul><li><p>基本数据类型</p><ul><li><p>数值型</p><ul><li>整型{byte，short，int，long} &#x2F;*long型的变量数值以L或l结尾</li><li>浮点型{float，double}&#x2F;*float型的变量数值以F或f结尾</li></ul></li><li><p>字符串{char}&#x2F;<em>通常使用一对’’包含  1.可以直接使用’\u</em>***’直接转译字符,     2.通过调用charAt(i)使用字符串中某一特定角标对应的字符【i表示所需字符的索引】</p></li><li><p>布尔型{boolean}</p></li><li><p>进制问题</p><ul><li>进制之间的问题（Java）.md</li></ul></li></ul></li><li><p>引用数据类型</p><ul><li>类{class}</li><li>接口{interface}</li><li>数组{[]}</li></ul></li></ul></li></ul></li><li><p>运算符</p><ul><li><p>算术运算符</p><ul><li>Subtopic</li></ul></li><li><p>比较运算符</p><ul><li>Subtopic</li></ul></li><li><p>逻辑运算符</p><ul><li>Subtopic</li></ul></li><li><p>位运算符</p><ul><li>‘&gt;&gt;&gt;’右移，右移一位&#x2F;2</li><li>‘&lt;&lt;&lt;’左移，左移一位*2</li></ul></li><li><p>三元运算符</p><p>****************a ? x : y  x与y必须是同一个类型的参数</p><ul><li>a?x:y 判断句子，x为true y为false</li></ul></li></ul></li><li><p>分支结构</p><ul><li><p>if-else</p><p>逻辑得理清，遇到包含或者或者有交集的判断句得理清楚所选的结构是否合理，小范围的判断与大范围的判断是否会耦合</p></li><li><p>switch-case</p><p>switch表达式中只能使用的六种数据类型：short、char、int、枚举、byte、String ;</p></li></ul></li><li><p>循环结构</p><ul><li>for循环</li><li>while循环</li><li>do-while循环</li></ul></li></ul></li></ul></li><li><p>数组 </p><ul><li><p>数组的声明与初始化</p><ul><li><p>静态初始化</p><p><strong>静态初始化</strong>&#x2F;&#x2F;初始化一个整型的长度为5的一维数组   int [] exp &#x3D; new int []{1,2,3,4,5};PS:在java中数组初始化必须定义长度，否则在编译过程中会报空指针异常的错误</p></li><li><p>动态初始化</p><p>**动态初始化&#x2F;&#x2F;初始化一个整型的长度为5的一维数组 int [] exp &#x3D; new int[5];&#x2F;&#x2F;在初始化过程中，</p></li></ul></li><li><p>数组的默认初始化值</p><ul><li><p>基本数据类型</p><ul><li>整型（byte、short、long、int、）：0</li><li>浮点型(float、double)：0.0</li><li>字符串型(char):0或’\u0000’非’0’：</li><li>布尔型(boolean):false;</li></ul></li><li><p>引用数据类型</p><ul><li>null</li></ul></li></ul></li><li><p>数组的内存解析</p><ul><li>内存的简化结构</li><li>一维数组的简化结构</li></ul></li><li><p>二维数组的理解</p><p>**二维数组相当于是 一个一维数组的元素又是一个一维数组 </p><ul><li><p>初始化</p><ul><li><p>静态初始化</p><p>**静态初始化一个二维数组    int [][] nums &#x3D; new int [] [] {{1,2,3},{4,5},{6,7,8}};    或者    int [][] nums &#x3D; {{1,2,3},{4,5},{6,7,8}};    int[] nums[] &#x3D; {{1,2,3},{4,5},{6,7,8}};    int [] nums[] &#x3D; new int [] [] {{1,2,3},{4,5},{6,7,8}};</p></li><li><p>动态初始化</p><p>**动态初始化一个二维数组    int [][] nums &#x3D; new int [2][3];    int [][] nums &#x3D; new int [2][];</p></li></ul></li><li><p>数组的默认初始化值</p><p><em><strong>初始化方式一：  比如：int[][]arr &#x3D; new int [4][3];    外层元素的初始化值：地址值    内层元素的初始化值为：与一维数组初始化情况相同</strong></em>针对初始化方式二：比如：int [][]arr &#x3D; new int [4][]    外层元素的初始化值为：null    内层元素的初始化值为：不能调用，否则报错【报错：空指针异常】    </p></li><li><p>二维数组的内存解析</p></li></ul></li><li><p>数组相关</p><ul><li><p>数组ppt</p><ul><li>尚硅谷_宋红康_第3章_数组.pdf</li></ul></li><li><p>数组排序算法</p><p>***    1.快速排序      **常用    2.归并排序      **常用    3. 堆排序        **常用    4.希尔排序    5.插入排序    6.选择排序    7.计数排序    8. 桶排序    9.冒泡排序    10.基数排序</p></li></ul></li></ul></li><li><p>面向对象</p><ul><li><p>面向对象的结构及特点</p><ul><li><p>Java类及类的成员</p><ul><li>属性</li><li>方法</li><li>构造器</li><li>代码块</li><li>内部类</li></ul></li><li><p>面向对象的三大特征</p><ul><li>封装性</li><li>继承性</li><li>多态性</li></ul></li><li><p>其他关键字</p><ul><li><p>this</p><p>******方法中的变量参数与类中的属性（即成员变量）相同时，使用前缀this.表示类的成员变量 *<em><strong><strong>在实际的调用过程中，this表示被调用的对象的方法 通常过程中被省略</strong></strong></em>构造器调用 this( ) ，不能递归</p></li><li><p>super</p><p>在子类调用父类的构造器、属性及其方法 –首先调用所在上级父类中检索该构造器、属性及其方法，若没有则逐级上升</p></li><li><p>instanceof</p><ul><li><p>关键字的使用</p><p>比如：          a instanceof A:判断对象a是否是类A的实例，如果是，返回true;                                                                           如果不是，返回false；         if(p2 instanceof Woman){ }</p></li><li><p>使用情境</p><p>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。****************************************************************    如果 a instanceof A 返回true，则a instanceof B 也返回true.    其中，类B是类A的父类。</p></li></ul></li><li><p>static</p><ul><li><p>关键字的使用</p><p>***************************   2020年8月12日 –可以用来修饰类的结构：属性、方法、代码块、内部类；    –  使用static 修饰属性：静态变量             — 属性按是否使用static 修饰，又分为：静态属性vs非静态属性（实例变量）                      实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性是，不会导致其他对象的属性值的修改。                      静态变量：我们创建了类的多个对象，多个对象共享一个静态变量。当通过某一个修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。             — static修饰属性的其他说明：                      —-静态变量随着类的加载而加载，可以通过“类.静态变量”的方式进行调用                      —-静态变量的加载要早于对象的创建                      —-由于类只会加载一次，则静态变量在内存中也只会加载一次（存在一份），存在方法区的静态域中。                      —-                类变量          实例变量                               类          yes                no                              对象        yes                yes    –使用static修饰方法：静态方法                      –随着类的加载而加载，可以通过”类.静态方法“的方式进行调用                      –          静态方法     非静态方法                           类         yes             no                           对象      yes             yes                      静态方法中，只能调用静态的方法或者属性                      非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或者属性    –static注意点：         在静态的方法内，不能使用this关键字、super关键字         关于静态属性和静态方法的使用，从生命周期的角度去理解              </p></li><li><p>类变量与实例变量内存解析</p></li><li><p>静态相关的设计模式</p></li><li><p>拓展性</p><ul><li><p>main中静态的体现</p><ul><li>Subtopic</li></ul></li></ul></li></ul></li><li><p>final</p><ul><li><p>可用来修饰</p><ul><li>类</li><li>方法</li><li>变量</li></ul></li><li><p>final</p></li></ul></li><li><p>abstract</p><ul><li><p>抽象类</p><p>抽象类****************–被关键字 abstract 修饰的类–抽象类不能被实例化–抽象类一定有构造器</p></li><li><p>抽象方法</p><p>******************–抽象方法只能被定义在抽象类中–抽象方法的定义         public abstract void test ();–抽象方法在继承的子类中必须全被实现</p></li></ul><p> </p></li><li><p>interface</p><ul><li><p>接口</p><ul><li><p>如何定义的？可以包含哪些东西？</p><ul><li><p>JDK7及以前</p><ul><li>全局变量</li><li>抽象方法</li></ul></li><li><p>JDK8增加</p><ul><li>静态方法</li><li>默认方法</li></ul></li></ul></li><li><p>接口体现了多态性</p></li><li><p>接口是如何应用的？</p><ul><li>让类去实现（implements）</li><li>实现类必须实现接口定义的所有方法，才能实例化。</li><li>不实例化则子类只能声明为抽象类</li></ul></li><li><p>接口与接口有什么关系？</p><p>继承</p></li><li><p>接口和类有什么关系？</p><p>实现</p></li><li><p>接口不能定义构造器</p></li><li><p>接口可以被多实现</p></li></ul></li></ul></li><li><p>import</p><p>导包(import) *<em><strong>使用import显式导包，具体到类、接口</strong></em><strong>使用static import 具体到属性、方法</strong>***除此以外，还可隐式导包,即直接写出路径，如：com.util.ToNymber;</p></li><li><p>package</p><p>申明当前代码文件所在的包目录</p></li></ul></li></ul></li><li><p>对象的创建&amp;使用</p><ul><li><p>内存解析</p><ul><li>对象的内存解析</li><li>对象数组的内存解析</li></ul></li><li><p>对象变量的内存位置</p></li><li><p>匿名对象</p><p>匿名对象——即不声明对象名，直接实例化一个对象实体。例如： new student().xXX();</p></li></ul><p>             </p></li><li><p>方法</p><ul><li><p>方法的重载</p><p>两同一不同———在同一个类中、有同一个方法名。形参列表不同</p></li><li><p>方法的重写</p><p>**********方法的重写基于子类与父类的关系    - 重写的规定：             – 方法体的声明：权限修饰符 返回值类型 方法名（形参列表）{                                       &#x2F;&#x2F;方法体}                             –PS ：在子类中的叫重写的方法  在父类中叫重写的方法               – 子类重写的方法的方法名和形参列表与父类中被重写的方法名及形参列表相同             – 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符                 — 子类中不能重写父类中的private的方法             – 返回值的类型：                 &gt; 若父类杯中重写的返回值为void，则子类中的重写的返回值只能为void                 &gt;  若父类中的方法返回值为其他具体引用数据类型，则子类重写的方法的返回值为该具体类型或其子类                 &gt; 若父类中的方法返回值为基本数据类型，则子类重写的方法的返回值为该基本数据类型             –子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></li><li><p>可变个数的形参</p><p>***public void getName(String … name){}<strong>对形参的个数不定义，形参的个数可以为0-多个</strong>与同一个类之间的不同参数类型(或个数不同)的同名方法构成重载</p></li><li><p>方法的递归</p><p>&#x2F;** 自己调用自己，隐性的循环结构，需引导递归到正确的方向，避免陷入死循环</p></li></ul></li><li><p>封装与隐藏</p><ul><li><p>封装性的体现</p><p>** 封装性的体现依赖于权限修饰符</p></li><li><p>权限修饰符</p><p>**4种权限修饰符（从小到大排列）private,缺省，protected,public</p><ul><li>Subtopic</li></ul></li></ul></li><li><p>构造器</p><ul><li><p>特点</p><ul><li>每个类都有自己的构造器</li><li>构造器不同于方法</li><li>一个类可以定义多个构造器(构造器的重载)</li></ul></li></ul></li><li><p>代码块</p><ul><li><p>作用</p><p>用来初始化类、对象</p></li><li><p>修饰</p><p>只能用static修饰*************{}或者static {}</p></li><li><p>静态代码块&amp;非静态代码块</p><p>*<strong><strong><strong><strong><strong><strong>静态代码块–随着类的加载而加载，且只会加载一次</strong></strong></strong></strong></strong></strong>非静态代码块–随着类的加载而加载，每创建一个对象都会加载一次。</p></li></ul></li><li><p>内部类</p></li><li><p>包装类</p><ul><li><p>包装类的使用</p><p>********     针对八种基本数据类型定义相应的引用类型–包装类（封装类）    有了类的特点，就可以调用类中的方法，Java才是真正的面向对象    包装类对应操作基本数据类型    Integer—–int    Double—-double    Float —–float    Boolean—-boolean    Long ——long    Character—char    Byte——–byte    Short——short&#x2F;<strong><strong><strong><strong><strong>除布尔类型与字符串类型之外的所有包装类的父类都是Number</strong></strong></strong></strong></strong>*****&#x2F;</p></li><li><p>String、包装类与基本数据类型之间的相互转换</p><ul><li><p>包装类转化</p><ul><li>包装类转化.xlsx</li></ul></li><li><p>String与包装类及基本数据类型的相互装换</p><p><strong><strong><strong><strong><strong>因为包装类与基本数据类型之间有自动拆箱与封箱的功能，所以这里将基本数据类型与包装类规划为一类，只讨论他们与String类之间的类型转换，以下统一称作包装类</strong></strong></strong></strong></strong>*******–包装类装换成String    int num &#x3D; 10;    &#x2F;&#x2F;方式一：          String str1 &#x3D; num+””; &#x2F;&#x2F;直接使用“”连接起来    &#x2F;&#x2F;方式二：         调用String重载的ValueOf(Xxx xxx )         float f1 &#x3D; 12.3f;         String str2 &#x3D; String.valueOf(f1); &#x2F;&#x2F;结果为“12.3”–String转换成包装类         String str3 &#x3D; “23”         int num2 &#x3D; Integer.parseInt(str3);&#x2F;&#x2F;对于String转换成基本数据类型，可能会报错NumberFormatException</p></li></ul><p>  </p></li><li><p>自动拆箱与自动装箱</p><ul><li><p>定义</p><p>***********    能够实现基本数据类型与包装类之间的相互赋值装换         例如：                 int i &#x3D; 5;                 Integer j &#x3D; i ; &#x2F;**直接将基本数据类型赋值给包装类对象                 int num &#x3D; j;  &#x2F;**直接将包装类赋值给基本数据类型，拆箱动作自动完成</p></li><li><p>自动装箱的拓展知识</p><p>*********************    在 Integer 中为了提高代码的运行速度，在内部定义了一个静态的内部类IntegerCache中定义了Integer[ ]    其中数组元素包含了-128~127整型值。    比如：             Integer num1 &#x3D; 1;             Integer num2 &#x3D; 1;             sysout(num1 &#x3D;&#x3D; num2);   &#x2F;&#x2F;true 此时直接引用IntegerCache内部类中的Integer[ ]数组中的1，所以此时两者的地址值指向的是同一个</p></li></ul></li></ul><p>                   </p></li><li><p>拓展</p><ul><li><p>JVM内存结构</p></li><li><p>变量的赋值传递机制</p><ul><li><p>形参是基本数据类型</p><ul><li>将实参基本数据类型变量的“数据值”传递给形参</li></ul></li><li><p>形参是引用数据类型</p><ul><li>将实参引用数据类型变量的“地址值”传递给形参</li></ul></li></ul></li></ul></li></ul></li><li><p>面向对象进阶</p><ul><li><p>类的继承性</p><p><em><strong><strong>子类会继承父类的所有属性及方法          父类的构造器可以通过super方法进行调用         父类中的私有属性（private）子类也会继承，但由于封装性的影响，不可在子类中调用父类的私有属性</strong></strong></em> </p></li><li><p>多态性</p><ul><li><p>理解</p><p>可以理解为一个事物的多种形态 </p></li><li><p>何为多态性</p><p>*********    对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）    举例：             -  Person p &#x3D; new Man();                 Object obj &#x3D; new Date():              父类直接引用实例化一个子类的对象***********************    - 多态使用时，当调用子父类同名的参数的方法时，实际执行的时子类重写父类的方法—-虚拟方法的调用    -不能调用子类所特有的方法、属性；    -有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中申明的属性和方法。子类特有的属性和方法不能调用；    -向下转型，使用强制类型装换符         如：Man m1 &#x3D; (Man)p2;         –使用强转时，可能出现ClassCastException的异常，             </p></li><li><p>异常</p><p>—————对于抛出ClassCastException时，Java方面引入了instanceof关键字</p></li></ul></li><li><p>Object类</p><ul><li><p>定义</p><p>*******************************    Object类是所有Java类的根父类         - 如果在类的声明中未使用extends关键字指明其父类，则默认未Java.lang.Object类         - Object类中的功能（属性、方法）就具通用性            –属性：无            –方法：equals（）&#x2F;toString( )&#x2F;getClass()&#x2F;hashcode()&#x2F;clone()&#x2F;finalize()&#x2F;wait()&#x2F;notify()&#x2F;notifyAll()         - Object类只声明了一个空参的构造器</p></li></ul></li><li><p>单例模式</p><ul><li><p>定义</p><p>所谓类的单例模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p></li><li><p>类型</p><ul><li><p>饿汉式</p><ul><li>具体实现</li><li>优缺点</li></ul></li><li><p>懒汉式</p><ul><li>具体实现</li><li>优缺点</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><p>基本概念</p><ul><li><p>程序</p><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p></li><li><p>进程</p><p>程序的一次执行过程，它是动态的，有它自身的产生、存在和消亡的过程。—-生命周期</p></li><li><p>线程</p><p>进程可以分化为线程，是一个程序内部的一条执行路径。    **若一个进程同一时间并行执行多个线程，就是支持多线程的。    **线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小    **一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间→它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p></li></ul></li></ul><h2 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h2><h3 id="Eclipse使用"><a href="#Eclipse使用" class="headerlink" title="Eclipse使用"></a>Eclipse使用</h3><ul><li><p>使用基础</p><ul><li>Eclipse使用基础.md</li></ul></li><li><p>Debug调试</p><p>*设置断点调试</p></li></ul><h2 id="家庭记账管理系统"><a href="#家庭记账管理系统" class="headerlink" title="家庭记账管理系统"></a>家庭记账管理系统</h2><h3 id="家庭记账管理-md"><a href="#家庭记账管理-md" class="headerlink" title="家庭记账管理.md"></a>家庭记账管理.md</h3><h2 id="项目二：客户管理系统"><a href="#项目二：客户管理系统" class="headerlink" title="项目二：客户管理系统"></a>项目二：客户管理系统</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC核心详解</title>
    <link href="https://lyotoc.github.io/2022/07/07/JDBC%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lyotoc.github.io/2022/07/07/JDBC%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-07T01:27:43.000Z</published>
    <updated>2022-07-07T05:54:00.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h1><h2 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h2><p>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。</p><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/202009302218598.png" alt="在这里插入图片描述"></p><h2 id="Java中的数据存储技术"><a href="#Java中的数据存储技术" class="headerlink" title="Java中的数据存储技术"></a>Java中的数据存储技术</h2><p>在Java中，数据库存取技术可分为如下几类：</p><p>JDBC直接访问数据库</p><p>JDO (Java Data Object )技术</p><p>第三方O&#x2F;R工具，如Hibernate, Mybatis 等</p><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p><h2 id="JDBC介绍"><a href="#JDBC介绍" class="headerlink" title="JDBC介绍"></a>JDBC介绍</h2><ul><li><p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</p></li><li><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p></li><li><p>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p></li><li><p>如果没有JDBC，那么Java程序访问数据库时是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/Untitled.png" alt="Untitled"></p></li><li><p>有了JDBC可以达到这样的效果</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220707093929116.png" alt="Untitled"></p></li><li><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220707093947299.png" alt="Untitled"></p><p>JDBC制定了一组规范的接口，各大数据库厂商都提供的自家数据库JDBC驱动</p><p>JDBC驱动：就是JDBC接口的实现类</p><p>所以，JAVA程序员在操作数据库时，只要加载对应数据库驱动后</p><p>调用JDBC定义的接口方法，就可以实现对各个数据的操作</p><p>不需要去了解数据库厂家的具体实现和细节</p></li></ul><h2 id="JDBC体系结构"><a href="#JDBC体系结构" class="headerlink" title="JDBC体系结构"></a>JDBC体系结构</h2><ul><li>JDBC接口（API）包括两个层次：<ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul></li></ul><blockquote><p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p><p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程</strong></p></blockquote><h3 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222019969.png" alt="aa"></p><blockquote><p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><h1 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h1><h2 id="要素一：Driver接口实现类"><a href="#要素一：Driver接口实现类" class="headerlink" title="要素一：Driver接口实现类"></a>要素一：Driver接口实现类</h2><h3 id="Driver接口介绍"><a href="#Driver接口介绍" class="headerlink" title="Driver接口介绍"></a>Driver接口介绍</h3><ul><li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动： com.mysql.jdbc.Driver</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222041978.png" alt="尚硅谷_宋红康_JDBC.assets/1555576157618.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222055877.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oOiKsgU5-1601475477254)(尚硅谷_宋红康_JDBC.assets/1555576170074.png)]"></p><h3 id="加载与注册JDBC驱动"><a href="#加载与注册JDBC驱动" class="headerlink" title="加载与注册JDBC驱动"></a>加载与注册JDBC驱动</h3><ul><li>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名Class.forName(“com.mysql.jdbc.Driver”);</li><li>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序<ul><li>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</li><li>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2020093022215272.png" alt="qqq"></p><h2 id="要素二：URL"><a href="#要素二：URL" class="headerlink" title="要素二：URL"></a>要素二：URL</h2><ul><li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p></li><li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。</p><ul><li><p>jdbc:子协议:子名称</p><ul><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名</li></ul></li><li><p>举例：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222202882.png" alt="aaa"></p></li></ul></li><li><p><strong>几种常用数据库的 JDBC URL</strong></p><ul><li>MySQL的连接URL编写方式：<ul><li>jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值</li><li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu</li><li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li><li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu?user&#x3D;root&amp;password&#x3D;123456</li></ul></li><li>Oracle 9i的连接URL编写方式：<ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li>SQLServer的连接URL编写方式：<ul><li>jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称</li><li>jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;atguigu</li></ul></li></ul></li></ul><h2 id="要素三：用户名和密码"><a href="#要素三：用户名和密码" class="headerlink" title="要素三：用户名和密码"></a>要素三：用户名和密码</h2><ul><li>user,password可以用“属性名&#x3D;属性值”方式告诉数据库</li><li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li></ul><h3 id="数据库连接方式举例"><a href="#数据库连接方式举例" class="headerlink" title="数据库连接方式举例"></a>数据库连接方式举例</h3><h4 id="连接方式一"><a href="#连接方式一" class="headerlink" title="连接方式一"></a>连接方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            driver = <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API</p></blockquote><h4 id="连接方式二"><a href="#连接方式二" class="headerlink" title="连接方式二"></a>连接方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.实例化Driver</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><h4 id="连接方式三"><a href="#连接方式三" class="headerlink" title="连接方式三"></a>连接方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.实例化Driver</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(driverName);</span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line">            <span class="comment">//3.注册驱动</span></span><br><span class="line">            DriverManager.registerDriver(driver);</span><br><span class="line">            <span class="comment">//4.获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><h4 id="连接方式四"><a href="#连接方式四" class="headerlink" title="连接方式四"></a>连接方式四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">            Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">            <span class="comment">//3.注册驱动</span></span><br><span class="line">            <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">            static &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">                &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                    throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="连接方式五-最终版"><a href="#连接方式五-最终版" class="headerlink" title="连接方式五(最终版)"></a>连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.加载配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(is);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读取配置信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.加载驱动</span></span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        System.out.println(conn);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p><p><strong>使用配置文件的好处：</strong></p><p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p></blockquote><h1 id="使用PreparedStatement实现CRUD操作"><a href="#使用PreparedStatement实现CRUD操作" class="headerlink" title="使用PreparedStatement实现CRUD操作"></a>使用PreparedStatement实现CRUD操作</h1><h2 id="操作和访问数据库"><a href="#操作和访问数据库" class="headerlink" title="操作和访问数据库"></a>操作和访问数据库</h2><ul><li>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</li></ul><ul><li>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：<ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。</li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222227858.png" alt="img"></p><h2 id="使用Statement操作数据表的弊端"><a href="#使用Statement操作数据表的弊端" class="headerlink" title="使用Statement操作数据表的弊端"></a>使用Statement操作数据表的弊端</h2><ul><li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p></li><li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">excuteUpdate</span><span class="params">(String sql)</span>：执行更新操作INSERT、UPDATE、DELETE</span><br><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span>：执行查询操作SELECT</span><br></pre></td></tr></table></figure><ul><li><p>但是使用Statement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul></li><li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;‘a’ OR 1 &#x3D; ’ AND password &#x3D; ’ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p></li><li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p></li><li><p>代码演示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatementTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> get(sql, User.class);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222243357.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j4Enm68A-1601475477283)(尚硅谷_宋红康_JDBC.assets/1566569819744.png)]"></p><h2 id="PreparedStatement的使用"><a href="#PreparedStatement的使用" class="headerlink" title="PreparedStatement的使用"></a>PreparedStatement的使用</h2><h3 id="PreparedStatement介绍"><a href="#PreparedStatement介绍" class="headerlink" title="PreparedStatement介绍"></a>PreparedStatement介绍</h3><ul><li><p>可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象</p></li><li><p>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</p></li><li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p></li></ul><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li>代码的可读性和可维护性。</li></ul><ul><li>PreparedStatement 能最大可能提高性能：<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。</li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li><li>PreparedStatement 可以防止 SQL 注入</li></ul></li></ul><h4 id="Java与SQL对应数据类型转换表"><a href="#Java与SQL对应数据类型转换表" class="headerlink" title="Java与SQL对应数据类型转换表"></a>Java与SQL对应数据类型转换表</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte array</td><td>BINARY , VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h3 id="使用PreparedStatement实现增、删、改操作"><a href="#使用PreparedStatement实现增、删、改操作" class="headerlink" title="使用PreparedStatement实现增、删、改操作"></a>使用PreparedStatement实现增、删、改操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String sql,Object ... args)</span>&#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取数据库的连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用PreparedStatement实现查询操作"><a href="#使用PreparedStatement实现查询操作" class="headerlink" title="使用PreparedStatement实现查询操作"></a>使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p></blockquote><h3 id="ResultSet与ResultSetMetaData"><a href="#ResultSet与ResultSetMetaData" class="headerlink" title="ResultSet与ResultSetMetaData"></a>ResultSet与ResultSetMetaData</h3><h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><ul><li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p></li><li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p></li><li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p></li><li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p><ul><li>例如: getInt(1), getString(“name”)</li><li>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</li></ul></li><li><p>ResultSet 接口的常用方法：</p><ul><li>boolean next()</li><li>getString()</li><li>…</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222305105.png" alt="aaa"></p><h4 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData"></a>ResultSetMetaData</h4><ul><li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p></li><li><p>ResultSetMetaData meta &#x3D; rs.getMetaData();</p><ul><li>getColumnName(int column)：获取指定列的名称</li><li>getColumnLabel(int column)：获取指定列的别名</li><li>getColumnCount()：返回当前 ResultSet 对象中的列数。</li><li>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。</li><li>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。</li><li>isNullable(int column)：指示指定列中的值是否可以为 null。</li><li>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222318664.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UJxU6ECV-1601475477290)(尚硅谷_宋红康_JDBC.assets/1555579494691.png)]"></p></li></ul><p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p><p> 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p><p><strong>问题2：关于ResultSetMetaData</strong></p><ol><li>如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可</li><li>获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法</li><li>获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222333303.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UvkjnWE7-1601475477293)(尚硅谷_宋红康_JDBC.assets/1555579816884.png)]"></p><h3 id="资源的释放"><a href="#资源的释放" class="headerlink" title="资源的释放"></a>资源的释放</h3><ul><li>释放ResultSet, Statement,Connection。</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机</li><li>Connection的使用原则是尽量晚创建，尽量早的释放。</li><li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="JDBC-API小结"><a href="#JDBC-API小结" class="headerlink" title="JDBC API小结"></a>JDBC API小结</h3><ul><li>两种思想<ul><li>面向接口编程的思想</li><li>ORM思想(object relational mapping)<ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。 </p></blockquote><ul><li>两种技术<ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li></ul><h1 id="操作BLOB类型字段"><a href="#操作BLOB类型字段" class="headerlink" title="操作BLOB类型字段"></a>操作BLOB类型字段</h1><h3 id="MySQL-BLOB类型"><a href="#MySQL-BLOB类型" class="headerlink" title="MySQL BLOB类型"></a>MySQL BLOB类型</h3><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222439863.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zLrzXSMo-1601475477317)(尚硅谷_宋红康_JDBC.assets/1555581069798.png)]"></p></li><li><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p></li><li><p>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p></li><li><p>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</p></li></ul><h3 id="向数据表中插入大数据类型"><a href="#向数据表中插入大数据类型" class="headerlink" title="向数据表中插入大数据类型"></a>向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h3 id="修改数据表中的Blob类型字段"><a href="#修改数据表中的Blob类型字段" class="headerlink" title="修改数据表中的Blob类型字段"></a>修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h3 id="从数据表中读取大数据类型"><a href="#从数据表中读取大数据类型" class="headerlink" title="从数据表中读取大数据类型"></a>从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="number">4</span>);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line"><span class="type">Blob</span> <span class="variable">photo</span> <span class="operator">=</span> rs.getBlob(<span class="number">5</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> photo.getBinaryStream();</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line"><span class="type">byte</span> [] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(os !=  <span class="literal">null</span>)&#123;</span><br><span class="line">os.close();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h1><h3 id="批量执行SQL语句"><a href="#批量执行SQL语句" class="headerlink" title="批量执行SQL语句"></a>批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句；</li><li>clearBatch():清空缓存的数据</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h2 id="高效的批量插入"><a href="#高效的批量插入" class="headerlink" title="高效的批量插入"></a>高效的批量插入</h2><p>举例：向数据表中插入20000条数据</p><ul><li><p>数据库中提供一个goods表。创建如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="实现层次一：使用Statement"><a href="#实现层次一：使用Statement" class="headerlink" title="实现层次一：使用Statement"></a>实现层次一：使用Statement</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现层次二：使用PreparedStatement"><a href="#实现层次二：使用PreparedStatement" class="headerlink" title="实现层次二：使用PreparedStatement"></a>实现层次二：使用PreparedStatement</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h4 id="实现层次三"><a href="#实现层次三" class="headerlink" title="实现层次三"></a>实现层次三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> *  ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现层次四"><a href="#实现层次四" class="headerlink" title="实现层次四"></a>实现层次四</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="数据库事务介绍"><a href="#数据库事务介绍" class="headerlink" title="数据库事务介绍"></a>数据库事务介绍</h2><ul><li>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</li><li>事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。</li><li>为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</li></ul><h2 id="JDBC事务处理"><a href="#JDBC事务处理" class="headerlink" title="JDBC事务处理"></a>JDBC事务处理</h2><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li>当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</p><ul><li>调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</li><li>在出现异常时，调用 rollback(); 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><p>【案例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJDBCTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>, <span class="literal">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h2><ol><li>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li><li>隔离性（Isolation）<br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</li></ol><h4 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h4><ul><li>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:<ul><li>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。</li><li>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li></ul></li><li>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</li><li>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</li></ul><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><ul><li>数据库提供的4种事务隔离级别：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222520600.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oFEbbexm-1601475477320)(尚硅谷_宋红康_JDBC.assets/1555586275271.png)]"></p><ul><li>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</li><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li></ul><h4 id="在MySql中设置隔离级别"><a href="#在MySql中设置隔离级别" class="headerlink" title="在MySql中设置隔离级别"></a>在MySql中设置隔离级别</h4><ul><li>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</li><li>查看当前的隔离级别:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><ul><li>设置当前 mySQL 连接的隔离级别:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>  transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ul><li>设置数据库系统的全局的隔离级别:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ul><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p></li><li><p>&#96;&#96;&#96;sql<br>create user tom identified by ‘abc123’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 授予权限</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  #授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">  grant all privileges on *.* to tom@&#x27;%&#x27;  identified by &#x27;abc123&#x27;; </span><br><span class="line">  </span><br><span class="line">   #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">  grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="DAO及相关实现类"><a href="#DAO及相关实现类" class="headerlink" title="DAO及相关实现类"></a>DAO及相关实现类</h1><ul><li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li><li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li><li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222533733.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9HV2eqpU-1601475477323)(尚硅谷_宋红康_JDBC.assets/1566726681515.png)]"></p><ul><li>层次结构：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222549621.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VK9eIITx-1601475477331)(尚硅谷_宋红康_JDBC.assets/1566745811244.png)]"></p><h2 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"><span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BaseDao</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 获取子类的类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass();</span><br><span class="line"><span class="comment">// 获取父类的类型</span></span><br><span class="line"><span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line"><span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line"><span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line"><span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line"><span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line"><span class="built_in">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的增删改操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">count = queryRunner.update(conn, sql, params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t = queryRunner.query(conn, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;T&gt;(type), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line">List&lt;T&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">list = queryRunner.query(conn, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;T&gt;(type), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">count</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">count = queryRunner.query(conn, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>&lt;&gt;(), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Book&gt; <span class="title function_">getBooks</span><span class="params">(Connection conn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">saveBook</span><span class="params">(Connection conn,Book book)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteBookById</span><span class="params">(Connection conn,String bookId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Book <span class="title function_">getBookById</span><span class="params">(Connection conn,String bookId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Connection conn,Book book)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Page&lt;Book&gt; <span class="title function_">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Page&lt;Book&gt; <span class="title function_">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="type">double</span> minPrice, <span class="type">double</span> maxPrice)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line"></span><br><span class="line">import com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param user</span></span><br><span class="line"><span class="comment"> * @return User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">User</span> getUser(Connection conn,<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param user</span></span><br><span class="line"><span class="comment"> * @return true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> checkUsername(Connection conn,<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void saveUser(Connection conn,<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;Book&gt; <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getBooks</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">beanList = getBeanList(conn,sql);</span><br><span class="line"><span class="keyword">return</span> beanList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveBook</span><span class="params">(Connection conn,Book book)</span> &#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> &#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">update(conn,sql, bookId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">getBookById</span><span class="params">(Connection conn,String bookId)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">book = getBean(conn,sql, bookId);</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Connection conn,Book book)</span> &#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title function_">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> &#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">totalRecord</span> <span class="operator">=</span> (<span class="type">long</span>) getValue(conn,sql);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="type">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title function_">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="type">double</span> minPrice, <span class="type">double</span> maxPrice)</span> &#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">totalRecord</span> <span class="operator">=</span> (<span class="type">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="type">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;User&gt; <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Connection conn,User user)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line"><span class="type">User</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUsername</span><span class="params">(Connection conn,User user)</span> &#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line"><span class="type">User</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername());</span><br><span class="line"><span class="keyword">return</span> bean != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(Connection conn,User user)</span> &#123;</span><br><span class="line"><span class="comment">//写sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line"><span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> price; <span class="comment">// 价格</span></span><br><span class="line"><span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line"><span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">imgPath</span> <span class="operator">=</span> <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line"><span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="JDBC数据库连接池的必要性"><a href="#JDBC数据库连接池的必要性" class="headerlink" title="JDBC数据库连接池的必要性"></a>JDBC数据库连接池的必要性</h2><ul><li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：</p><ul><li>在主程序（如servlet、beans）中建立数据库连接</li><li>进行sql操作</li><li>断开数据库连接</li></ul></li><li><p>这种模式开发，存在的问题:</p></li><li><p>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</p></li><li><p><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</p></li><li><p>这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</p></li></ul><h2 id="数据库连接池技术"><a href="#数据库连接池技术" class="headerlink" title="数据库连接池技术"></a>数据库连接池技术</h2><ul><li>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</li><li>数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li><li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222625571.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZXVJvRBu-1601475477337)(尚硅谷_宋红康_JDBC.assets/1555593464033.png)]"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222642230.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uuhSpvNH-1601475477340)(尚硅谷_宋红康_JDBC.assets/1555593598606.png)]"></p><ul><li><strong>数据库连接池技术的优点</strong></li></ul><ol><li><p><strong>资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p></li><li><p><strong>更快的系统反应速度</strong></p></li></ol><p>   数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><ol start="3"><li><p><strong>新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p></li><li><p><strong>统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ol><h2 id="多种开源的数据库连接池"><a href="#多种开源的数据库连接池" class="headerlink" title="多种开源的数据库连接池"></a>多种开源的数据库连接池</h2><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用<br>Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集<strong>DBCP</strong> 、<strong>C3P0</strong> 、<strong>Proxool</strong> 优点于一身的数据库连接池，但是速度不确定是否有<strong>BoneCP</strong>快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="C3P0数据库连接池"><a href="#C3P0数据库连接池" class="headerlink" title="C3P0数据库连接池"></a>C3P0数据库连接池</h4><ul><li><p>获取连接方式一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">ComboPooledDataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpds.setMaxPoolSize(100);</span></span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取连接方式二</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中，src下的配置文件为：【c3p0-config.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a>】</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DBCP数据库连接池"><a href="#DBCP数据库连接池" class="headerlink" title="DBCP数据库连接池"></a>DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><p>属性默认值说明<br>initialSize0连接池启动时创建的初始化连接数量<br>maxActive8连接池中可同时连接的最大的连接数<br>maxIdle8连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制<br>minIdle0连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。<br>maxWait无限制最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待<br>poolPreparedStatementsfalse开启池的Statement是否prepared<br>maxOpenPreparedStatements无限制开启池的prepared 后的同时最大连接数<br>minEvictableIdleTimeMillis连接池中连接，在时间段内一直空闲， 被逐出连接池的时间<br>removeAbandonedTimeout300超过时间限制，回收没有用(废弃)的连接<br>removeAbandonedfalse超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</p><table><thead><tr><th><strong>属性</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li><p>获取连接方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">BasicDataSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line"></span><br><span class="line">source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">source.setInitialSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取连接方式二：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中，src下的配置文件为：【dbcp.properties】</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure><h4 id="Druid（德鲁伊）数据库连接池"><a href="#Druid（德鲁伊）数据库连接池" class="headerlink" title="Druid（德鲁伊）数据库连接池"></a>Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>其中，src下的配置文件为：【druid.properties】</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall</span></span><br></pre></td></tr></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th>配置</th><th>缺省</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/使用ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h1 id="Apache-DBUtils实现CRUD操作"><a href="#Apache-DBUtils实现CRUD操作" class="headerlink" title="Apache-DBUtils实现CRUD操作"></a>Apache-DBUtils实现CRUD操作</h1><h2 id="Apache-DBUtils简介"><a href="#Apache-DBUtils简介" class="headerlink" title="Apache-DBUtils简介"></a>Apache-DBUtils简介</h2><ul><li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p></li><li><p>API介绍：</p><ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils</li></ul></li><li><p>API包说明：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222748867.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-awTVWb0u-1601475477345)(尚硅谷_宋红康_JDBC.assets/1555595163263.png)]"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200930222800740.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nHXDUBTD-1601475477354)(尚硅谷_宋红康_JDBC.assets/1555595198644.png)]"></p><h2 id="主要API的使用"><a href="#主要API的使用" class="headerlink" title="主要API的使用"></a>主要API的使用</h2><h3 id="DbUtils"><a href="#DbUtils" class="headerlink" title="DbUtils"></a>DbUtils</h3><ul><li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li>public static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。</li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException<br>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><h3 id="QueryRunner类"><a href="#QueryRunner类" class="headerlink" title="QueryRunner类"></a>QueryRunner类</h3><ul><li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p></li><li><p>QueryRunner类提供了两个构造器：</p><ul><li>默认的构造器</li><li>需要一个 javax.sql.DataSource 来作参数的构造器</li></ul></li><li><p>QueryRunner类的主要方法：</p></li><li><p><strong>更新</strong></p><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>…</li></ul></li><li><p><strong>插入</strong></p><ul><li>public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值</li><li>…</li></ul></li><li><p><strong>批处理</strong></p><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句</li><li>…</li></ul></li><li><p><strong>查询</strong></p><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>…</li></ul></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> runner.update(conn, sql, <span class="string">&quot;何成飞&quot;</span>, <span class="string">&quot;he@qq.com&quot;</span>, <span class="string">&quot;1992-09-08&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ResultSetHandler接口及实现类"><a href="#ResultSetHandler接口及实现类" class="headerlink" title="ResultSetHandler接口及实现类"></a>ResultSetHandler接口及实现类</h3><ul><li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p></li><li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p></li><li><p>接口的主要实现类：</p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li><li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li><li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li><li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li><li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li><li><strong>ScalarHandler：</strong>查询单个值对象</li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">System.out.println(customer);</span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line">List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">ResultSetHandler</span>&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"><span class="comment">//return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(customer);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line"><span class="comment">//ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//System.out.println(count);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试二：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line"><span class="type">ScalarHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>();</span><br><span class="line"><span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> (Date) runner.query(conn, sql, handler);</span><br><span class="line">System.out.println(birth);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateWithTx</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取连接的操作（</span></span><br><span class="line"><span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line"><span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line"><span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line"><span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//回滚数据</span></span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//3.关闭连接等操作</span></span><br><span class="line"><span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC概述&quot;&gt;&lt;a href=&quot;#JDBC概述&quot; class=&quot;headerlink&quot; title=&quot;JDBC概述&quot;&gt;&lt;/a&gt;JDBC概述&lt;/h1&gt;&lt;h2 id=&quot;数据的持久化&quot;&gt;&lt;a href=&quot;#数据的持久化&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JDBC" scheme="https://lyotoc.github.io/tags/JDBC/"/>
    
    <category term="数据库" scheme="https://lyotoc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程</title>
    <link href="https://lyotoc.github.io/2022/06/30/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://lyotoc.github.io/2022/06/30/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-06-30T03:59:35.000Z</published>
    <updated>2022-07-12T09:07:45.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程是操作系统的最小可操作分配资源，Java的线程通过调用<code>Thread.start()</code>启动，本质上是在调用<code>native</code>方法<code>start0()</code>,该方法通过<code>JNI(Java Native Interface)</code>调用,通过C++实现计算机本地线程资源</p></blockquote><h1 id="并发大纲"><a href="#并发大纲" class="headerlink" title="并发大纲"></a>并发大纲</h1><p><strong>java.util.concurrent包涵以下三个模块内容</strong></p><ol><li>atomic</li><li>locks</li><li>其它</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1654244836651-52adc269-4bcd-49af-9fe1-b7794908f108.png" alt="image.png"></p><h1 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h1><p><em><strong>脑图</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/yuque_diagram.jpg" alt="并发编程脑图"></p><h2 id="Java多线程相关概念"><a href="#Java多线程相关概念" class="headerlink" title="Java多线程相关概念"></a>Java多线程相关概念</h2><ul><li><strong>并发(concurrent)</strong></li></ul><blockquote><ol><li>是在同一实体上的多个事件</li><li>是在一台处理器上“同时”处理多个任务</li><li>同一时刻，其实是只有一个事情在发生</li></ol></blockquote><ul><li><strong>并行（parallel）</strong></li></ul><blockquote><ol><li>是在不同实体上的多个事件</li><li>是在多台处理器上同时处理多个任务</li><li>同一时刻，大家真的都在做事情，你做你的，我做我的，但是我们都在做</li></ol></blockquote><ul><li><strong>进程</strong></li></ul><blockquote><p>简单的说，在系统中运行一个应用程序就是一个进程，每个进程都有自己的内存空间和系统资源。</p></blockquote><ul><li><strong>线程</strong></li></ul><blockquote><p>也被称为<code>轻量级进程</code>，在同一个进程内会有1个或多个线程，也是大多数操作系统进行时序调度的基本单元。</p></blockquote><ul><li><strong>管程(Monitor)</strong></li></ul><blockquote><p>监视器，即锁</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220630152657690.png" alt="image-20220630152657690"></p><h2 id="Java多线程是怎么开启的？"><a href="#Java多线程是怎么开启的？" class="headerlink" title="Java多线程是怎么开启的？"></a>Java多线程是怎么开启的？</h2><blockquote><p>查看源码就知道，多线程的开启调用了一个start0()的本地方法，该方法会调用C++底层源码执行调用硬件资源开启线程。Java运行于虚拟机上，无法操作硬件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">         * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 本地方法，底层的C++ ，Java运行于虚拟机之上 无法直接操作硬件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>可以通过以下方法开启线程</strong></p><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口+FutureTask(通过实现该接口可以拿到返回结果，并处理异常)</li><li>线程池</li></ol><p>方式1和方式2：主进程无法获取线程的运算结果。</p><p>方式3：主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。</p><p>方式4：通过如下两种方式初始化线程池</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631603318411-339177fe-d521-460b-8099-61509e882135.png" alt="img"></p><p>区别;<br>   1、2不能得到返回值。3可以获取返回值<br>   1、2、3都不能控制资源<br>   4、可以控制资源，性能稳定。</p><h2 id="开发中为什么使用线程池"><a href="#开发中为什么使用线程池" class="headerlink" title="开发中为什么使用线程池"></a>开发中为什么使用线程池</h2><ul><li><p>降低资源的消耗：通过重复利用已经创建好的线程降低线程的创建和销毁带来的损耗</p></li><li><p>提高响应速度：因为线程池中的线程数没有超过线程池的最大上限时，有的线程处于等待分配任务的状态，当任务来时无需创建新的线程就能执行</p></li><li><p>提高线程的可管理性：线程池会根据当前系统特点对池内的线程进行优化处理，减少创建和销毁线程带来的系统开销。无限的创建和销毁线程不仅消耗系统资源，还降低系统的稳定性，使用线程池进行统一分配</p></li></ul><h2 id="使用线程的基本方式"><a href="#使用线程的基本方式" class="headerlink" title="使用线程的基本方式"></a>使用线程的基本方式</h2><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）、继承Thread</span><br><span class="line">         <span class="type">Thread01</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line">         thread.start();<span class="comment">//启动线程</span></span><br><span class="line"><span class="comment">// 继承Thread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            System.out.println(<span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Thread的join方法</strong></p><p>join()方法的作用就是让主线程等待子线程执行结束之后再运行主线程。下面示例中t2 为主线程，需要等待子线程t1 执行完成再执行<br>使用场景：线程2依赖于线程1执行的返回结果。在线程2 中调用线程1的join方法，当线程调用了这个方法时，线程1会强占CPU资源，直到线程执行结果为止（谁调用join方法，谁就强占cpu资源，直至执行结束）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;线程1醒了&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1 i:&quot;</span>+i);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          t1.join();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;线程2 i:&quot;</span>+i);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">100</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t2.start();</span><br><span class="line">    t1.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">1</span>醒了</span><br><span class="line">线程<span class="number">1</span> i:<span class="number">0</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">2</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">3</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">4</span></span><br><span class="line">线程<span class="number">1</span> i:<span class="number">5</span></span><br><span class="line">……</span><br><span class="line">线程<span class="number">1</span> i:<span class="number">99</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">0</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">1</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">2</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">3</span></span><br><span class="line">线程<span class="number">2</span> i:<span class="number">4</span></span><br><span class="line">……</span><br><span class="line">线程<span class="number">2</span> i:<span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>实现Runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>）、实现Runnable接口</span><br><span class="line">        <span class="type">Runable01</span> <span class="variable">runable01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runable01</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runable01).start();</span><br><span class="line">   <span class="comment">// 实现Runnable接口</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">R1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">           System.out.println(<span class="string">&quot;R1&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>实现Callable&lt;T&gt;接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>）、实现Callable接口 + FutureTask （可以拿到返回结果，可以处理异常）</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="comment">//阻塞等待整个线程执行完成，获取返回结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> futureTask.get();    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实现Callable接口 （可以拿到返回结果，可以处理异常）</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">           System.out.println(<span class="string">&quot;C1&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">66</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>实现 Runnable 接口和 Callable 接口的区别</strong></p><p>Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。<br>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。</p><p><code>Runnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Callable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算返回的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池技术"><a href="#线程池技术" class="headerlink" title="线程池技术"></a>线程池技术</h2><blockquote><p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p></blockquote><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="Executors-创建线程池"><a href="#Executors-创建线程池" class="headerlink" title="Executors 创建线程池"></a><strong>Executors 创建线程池</strong></h3><p>通过 <strong>Executor</strong> 框架的工具类 <strong>Executors</strong> 来实现我们可以创建三种类型的<strong>ThreadPoolExecutor</strong>：</p><ul><li>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>ScheduledThreadPoolExecutor 主要用来在给定的延迟后运行任务，或者定期执行任务。 这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下它的思想即可。</li><li>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li></ul><p>对应 Executors 工具类中的方法如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692714-f8367307-610f-4b25-a8d8-de54edda759e.png" alt="img"></p><blockquote><p>Executors 返回线程池对象的弊端如下：<br>●CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程导致 OOM。<br>●FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</p></blockquote><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><h3 id="ThreadPoolExecutor-创建线程池"><a href="#ThreadPoolExecutor-创建线程池" class="headerlink" title="ThreadPoolExecutor 创建线程池"></a><strong>ThreadPoolExecutor 创建线程池</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692548-c26740fa-88f1-4d72-b223-8258719d2709.png" alt="img"></p><p>ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                      TimeUnit unit,</span></span><br><span class="line"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                      ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                      RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">ThreadPoolExecutor构造函数重要参数分析</span></span><br><span class="line"><span class="comment">ThreadPoolExecutor 3 个最重要的参数：</span></span><br><span class="line"><span class="comment">● corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</span></span><br><span class="line"><span class="comment">● maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</span></span><br><span class="line"><span class="comment">● workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</span></span><br><span class="line"><span class="comment">ThreadPoolExecutor其他常见参数:</span></span><br><span class="line"><span class="comment">● keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</span></span><br><span class="line"><span class="comment">● unit : keepAliveTime 参数的时间单位。</span></span><br><span class="line"><span class="comment">● threadFactory :executor 创建新线程的时候会用到。</span></span><br><span class="line"><span class="comment">● handler :饱和策略。关于饱和策略下面单独介绍一下。</span></span><br><span class="line"><span class="comment">例题举例1：</span></span><br><span class="line"><span class="comment">一个线程池 core 7； max 20 ，queue：50，100并发进来怎么分配的；</span></span><br><span class="line"><span class="comment">7个会立即得到执行，50个会进入队列，再开13个进行执行。剩下的30个就使用拒绝策略。</span></span><br><span class="line"><span class="comment">如果不想抛弃还要执行，拒绝策略采用CallerRunsPolicy；</span></span><br><span class="line"><span class="comment">例题举例2：</span></span><br><span class="line"><span class="comment">我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，</span></span><br><span class="line"><span class="comment">所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务执行完成后，才会执行剩下的 5 个任务。</span></span><br><span class="line"><span class="comment">等待队列装不满，所以用不到maximumPoolSize</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor 饱和策略<br>ThreadPoolExecutor 饱和策略定义:<br>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。[默认测策]</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。<br>对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p><h3 id="一个简单的线程池-Demo"><a href="#一个简单的线程池-Demo" class="headerlink" title="一个简单的线程池 Demo"></a><strong>一个简单的线程池 Demo</strong></h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。<br>首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）</p><p><code>MyRunnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p><p><code>ThreadPoolExecutorDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li>corePoolSize: 核心线程数为 5</li><li>maximumPoolSize ：最大线程数 10</li><li>keepAliveTime : 等待时间为 1L</li><li>unit: 等待时间的单位为 TimeUnit.SECONDS</li><li>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100</li><li>handler:饱和策略为 CallerRunsPolicy</li></ol><p><strong>Output：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程池对象执行-execute-方法和-submit-方法的区别是什么"><a href="#线程池对象执行-execute-方法和-submit-方法的区别是什么" class="headerlink" title="线程池对象执行 execute()方法和 submit()方法的区别是什么?"></a>线程池对象执行 execute()方法和 submit()方法的区别是什么?</h3><ol><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以AbstractExecutorService接口中的一个 submit 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>submit方法调用的 newTaskFor 方法得到了一个 FutureTask 对象，<br>调用execute(ftask);<br>最终返回了FutureTask </p></blockquote><h2 id="用户线程与守护线程"><a href="#用户线程与守护线程" class="headerlink" title="用户线程与守护线程"></a>用户线程与守护线程</h2><p><strong>用户线程</strong></p><blockquote><p>一般情况下不作说明均为用户线程</p><p>系统的工作线程，它会完成这个程序需要完成的业务操作</p></blockquote><p><strong>守护线程</strong></p><blockquote><ol><li>一种特殊的线程为其它线程服务的，在后台默默地完成一些系统性的，比如垃圾回收线程就是最典型的例子</li><li>守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，java虚拟机会自动退出。</li></ol></blockquote><h3 id="线程的deamon的属性"><a href="#线程的deamon的属性" class="headerlink" title="线程的deamon的属性"></a>线程的deamon的属性</h3><p> 涉及两个方法 <code>isDeamon()</code>,<code>setDeamon(Boolea  b)</code>，前者判断该线程为守护线程[true为守护线程，false为用户线程]，后者为设置当前线程[true为守护线程，false为用户线程]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 开始运行，&quot;</span>+(Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span>:<span class="string">&quot;用户线程&quot;</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----end 主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 开始运行，守护线程</span><br><span class="line">main -----end 主线程</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果用户线程全部结束意味着程序需要完成的业务操作已经全部结束了，守护线程随着JVM一同结束工作，setDeamon(true)方法必须在start()之前设置，否则报IllegalThreadStateException异常</p><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2><p><strong>Future</strong>接口(FutureTask实现类)定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><ul><li>例如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙其他事情或者先执行完，过了一会才去获取子任务的执行结果或变更的任务状态。</li></ul><p><strong>Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务</strong></p><p>Future是Java5新加的一个接口，它提供了一种异步并行计算的功能。如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。<br>代码说话：<br>Runnable接口<br>Callable接口<br>Future接口和FutureTask实现类</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>该实现类满足了异步执行任务的要求，即多线程、有返回、异步任务。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220630171049484.png" alt="FutureTask的继承实现关系"></p><p>FutureTask使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">futureTaskTest</span><span class="params">()</span>&#123;</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;come in call()&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello Callable&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Future编码及优缺点分析"><a href="#Future编码及优缺点分析" class="headerlink" title="Future编码及优缺点分析"></a>Future编码及优缺点分析</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>future线程池异步多线程任务配合，能显著提高程序的执行效率</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>get()方法容易导致阻塞</li></ul><blockquote><p>调用get()方法是直接主线程直接去访问子线程获取结果，此时如果子线程任务未结束就会导致主线程阻塞等待</p></blockquote><ul><li>isDone()论询</li></ul><blockquote><p>轮询的方式会耗费无谓的CPU资源而且也不见得能及时地得到计算结果，如果想要异步获取结果，通常都会以轮询地方式去获取结果，尽量不要阻塞</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureAPIDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-------------come in&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;task over&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;忙其它任务了&quot;</span>);</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line">        <span class="comment">// 1.设置指定时间，限定等待时间</span></span><br><span class="line">      <span class="comment">//System.out.println(futureTask.get(5,TimeUnit.SECONDS));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>希望能实现子线程完成后主动向主线程汇报的需求</li></ul><h4 id="FutureTask源码结构"><a href="#FutureTask源码结构" class="headerlink" title="FutureTask源码结构"></a>FutureTask源码结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220706162204093.png" alt="image-20220706162204093"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655705978070-830eea78-f873-4daa-a625-136d692fff00.png" alt="image.png"></p><ul><li>作为线程：实现了Runnable接口</li><li>异步处理：实现了Future接口</li><li>有返回值：构造注入了Callable&lt;T&gt;,提供了Callable功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p>在 JDK 1.7 ， ForkJoin，并行执行任务！提高效率。大数据量！  大数据：Map Reduce （把大任务拆分为小任务）</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632721661519-7e143e5f-ed05-40d8-823f-dcc76e57637c.png" alt="img"></p><p>就是在必要的情况下，将一个大任务，进行拆分（fork） 成若干个小任务（拆到给出的临界值为止），再将一个个的小任务运算的结果进行join汇总</p><h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><blockquote><p>工作窃取模式 （work-stealing）：当执行新的任务时它可以将其拆分成 更小的任务执行，并将小任务加到线程队列中，当没有任务执行时，再从一个随机线程的队列中偷一个并把它放在自己的队列中 相对于一般的线程池实现 ，fork&#x2F;join 框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行那么该线程会处于等待状态。而在fork&#x2F;join 框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题（窃取过来）来执行，这种方式减少了线程的等待时间，提高了性能</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632724412453-f817290f-d167-4281-bc6f-06c6dd273a3f.png" alt="img"></p><h3 id="ForkJoinTask实现类"><a href="#ForkJoinTask实现类" class="headerlink" title="ForkJoinTask实现类"></a>ForkJoinTask实现类</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1654151499135-73f8ea34-16d9-4d2f-af99-174a845ea562.png" alt="image.png"></p><ul><li>RecursiveTask&lt;V&gt;：有返回值的递归任务</li><li>RecursiveAction：无返回值得递归事件</li></ul><h4 id="实现类Demo"><a href="#实现类Demo" class="headerlink" title="实现类Demo"></a>实现类Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求和计算的任务！</span></span><br><span class="line"><span class="comment"> * 3000   6000（ForkJoin）  9000（Stream并行流）</span></span><br><span class="line"><span class="comment"> * // 如何使用 forkjoin</span></span><br><span class="line"><span class="comment"> * // 1、forkjoinPool 通过它来执行</span></span><br><span class="line"><span class="comment"> * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task)</span></span><br><span class="line"><span class="comment"> * // 3. 计算类要继承 ForkJoinTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> Long end;    <span class="comment">// 1990900000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end-start)&lt;temp)&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// forkjoin 递归</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            task1.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试类Demo"><a href="#测试类Demo" class="headerlink" title="测试类Demo"></a>测试类Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个任务，别人效率高你几十倍！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// test1(); // 12224</span></span><br><span class="line">        <span class="comment">// test2(); // 10038</span></span><br><span class="line">        <span class="comment">// test3(); // 153</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通程序员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会使用ForkJoin</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);<span class="comment">// 提交任务</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Stream并行流 ()  (]</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用过 CountDownLatch 么？什么场景下用的？<br>CountDownLatch 的作用就是 允许 count 个线程阻塞在一个地方，直至这count个线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 CountDownLatch 。具体场景是下面这样的：<br>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。<br>为此我们定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。<br>伪代码是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>有没有可以改进的地方呢？</strong><br>可以使用 CompletableFuture 类来改进！Java8 的 CompletableFuture 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的代码还可以接续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过集合来添加任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[fileFutures.size()])</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture-1"><a href="#CompletableFuture-1" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Bi函数式接口"><a href="#Bi函数式接口" class="headerlink" title="Bi函数式接口"></a>Bi函数式接口</h3><h4 id="BiConsumer"><a href="#BiConsumer" class="headerlink" title="BiConsumer"></a>BiConsumer</h4><p>函数式接口<code>BiConsumer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> BiConsumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> BiConsumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title function_">andThen</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    <span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与普通的消费者接口不同的是，BiConsumer可以传入两个参数</p></blockquote><h4 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; BiFunction&lt;T, U, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与普通的Function接口不同的是，BiFunction可以传入两个参数。</p></blockquote><h4 id="BiPredicate"><a href="#BiPredicate" class="headerlink" title="BiPredicate"></a>BiPredicate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiPredicate</span>&lt;T, U&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input arguments match the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title function_">and</span><span class="params">(BiPredicate&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; test(t, u) &amp;&amp; other.test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; !test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title function_">or</span><span class="params">(BiPredicate&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; test(t, u) || other.test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与普通的断言接口不同的是，BiPredicate可以传入两个参数。</p></blockquote><h3 id="CompletableFuture启动异步任务"><a href="#CompletableFuture启动异步任务" class="headerlink" title="CompletableFuture启动异步任务"></a>CompletableFuture启动异步任务</h3><h4 id="CompletableFuture创建方式"><a href="#CompletableFuture创建方式" class="headerlink" title="CompletableFuture创建方式"></a>CompletableFuture创建方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the &#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125; after</span></span><br><span class="line"><span class="comment"> * it runs the given action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the action to run before completing the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the given executor after it runs the given</span></span><br><span class="line"><span class="comment"> * action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the action to run before completing the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor the executor to use for asynchronous execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,</span></span><br><span class="line"><span class="params">                                               Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the &#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125; with</span></span><br><span class="line"><span class="comment"> * the value obtained by calling the given Supplier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function returning the value to be used</span></span><br><span class="line"><span class="comment"> * to complete the returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the function&#x27;s return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the given executor with the value obtained</span></span><br><span class="line"><span class="comment"> * by calling the given Supplier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function returning the value to be used</span></span><br><span class="line"><span class="comment"> * to complete the returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor the executor to use for asynchronous execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the function&#x27;s return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span><br><span class="line"><span class="params">                                                   Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runAsync方法不支持返回值。其中Executor指的是可以传入我们的线程池对象</li><li>supplyAsync可以支持返回值。其中Executor指的是可以传入我们的线程池对象</li></ul><h3 id="CompletableFuture回调方法"><a href="#CompletableFuture回调方法" class="headerlink" title="CompletableFuture回调方法"></a>CompletableFuture回调方法</h3><h4 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete"></a>whenComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>whenComplete可以处理正常的计算结果</p><blockquote><p>whenComplete和whenCompleteAsync的区别：<br>whenComplete：是当前线程执行当前任务，等待任务执行之后继续执行当前的whenComplete<br>whenCompleteAsync：是执行把whenCompleteAsync这个任务提交给线程池中的其他线程来进行执行。<br>方法不以Async结尾，意味着Action使用相同的线程执行<br>方法以Async结尾可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.cf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-16 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureUseDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----1秒钟后出结果：&quot;</span> + result);</span><br><span class="line">                <span class="keyword">if</span>(result &gt; <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;,threadPool).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----计算完成，更新系统UpdateValue：&quot;</span>+v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;异常情况：&quot;</span>+e.getCause()+<span class="string">&quot;\t&quot;</span>+e.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程先去忙其它任务&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">future1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----1秒钟后出结果：&quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程先去忙其它任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is completed when this</span></span><br><span class="line"><span class="comment"> * CompletableFuture completes, with the result of the given</span></span><br><span class="line"><span class="comment"> * function of the exception triggering this CompletableFuture&#x27;s</span></span><br><span class="line"><span class="comment"> * completion when it completes exceptionally; otherwise, if this</span></span><br><span class="line"><span class="comment"> * CompletableFuture completes normally, then the returned</span></span><br><span class="line"><span class="comment"> * CompletableFuture also completes normally with the same value.</span></span><br><span class="line"><span class="comment"> * Note: More flexible versions of this functionality are</span></span><br><span class="line"><span class="comment"> * available using methods &#123;<span class="doctag">@code</span> whenComplete&#125; and &#123;<span class="doctag">@code</span> handle&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn the function to use to compute the value of the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture if this CompletableFuture completed</span></span><br><span class="line"><span class="comment"> * exceptionally</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;Throwable, ? extends T&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniExceptionallyStage(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exceptionally处理异常情况。</p><h4 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h4><p>handle：whenComplete和exceptionally的结合版。方法执行后的处理，无论成功与失败都可处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法执行完成后的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">          System.out.println(<span class="string">&quot;CompletableFuture...&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">10</span>/<span class="number">1</span>;</span><br><span class="line">      &#125;, service).handle((t,u)-&gt;&#123; <span class="comment">// R apply(T t, U u);</span></span><br><span class="line">          System.out.println(<span class="string">&quot;handle:&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (t != <span class="literal">null</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;存在返回结果:&quot;</span> + t);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (u != <span class="literal">null</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;存在日常:&quot;</span> + u);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> completableFuture2.get();</span><br><span class="line">      System.out.println(integer);</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture异步任务场景"><a href="#CompletableFuture异步任务场景" class="headerlink" title="CompletableFuture异步任务场景"></a>CompletableFuture异步任务场景</h3><h4 id="线程串行化"><a href="#线程串行化" class="headerlink" title="线程串行化"></a>线程串行化</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608072243-885c7014-2a11-413a-bedc-915a8d6a4f49.png" alt="image.png"></p><ul><li>thenRun：不能获取到上一步的执行结果，无返回值</li><li>thenAcceptAsyne 能接受上—步结果，但是无返回值</li><li>thenApplyAsync 能接受上—步结果，有返回值</li></ul><p><strong>我们即要能感知到上一步的执行结果，也要能有自己线程执行成功的自己的返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">我是B</span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;CompletableFuture...&quot;);</span></span><br><span class="line"><span class="comment">//            return 10;//拿到A的返回值</span></span><br><span class="line"><span class="comment">//        &#125;, service).thenApplyAsync((u)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;返回值&quot; + u);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务2启动&quot;);</span></span><br><span class="line"><span class="comment">//            return 5;//自己的返回值再返回出去</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println(completableFuture2.get());</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        CompletableFuture...</span></span><br><span class="line"><span class="comment">        返回值10</span></span><br><span class="line"><span class="comment">        任务2启动</span></span><br><span class="line"><span class="comment">        5</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">                * */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双线程均完成才能后续"><a href="#双线程均完成才能后续" class="headerlink" title="双线程均完成才能后续"></a>双线程均完成才能后续</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608481956-26c05f7b-f884-40a5-ab82-29ae5e58948f.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608525031-b674bf15-05f0-4bad-9d83-cad4467054cf.png" alt="image.png"></p><ul><li>runAfterBothAsync 两人任务组合，不能得到前任务的结果和无返回值</li><li>thenAcceptBothAsync 两人任务组合，能得到前任务的结果和无返回值</li><li>thenCombineAsync 两人任务组合，能得到前任务的结果和有返回值</li></ul><p>传入的参数：CompletionStage是什么？其实还是我们的CompletableFuture</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1631608617737-c042b566-2caf-4b92-ada9-1e9aef21d02e.png" alt="image.png"></p><p>两个任务必须都完成，触发该Runnable参数指定的任务即当前lambda表达式的内容<br>thenCombine:组合两个 future,获取两个 future的返回结果,并返回当前任务的返回值<br>thenAcceptBoth:组合两个 future,获取两个 future任务的返回结果,然后处理任务,没有返回值。<br>runAfterBoth组合两个future，不需要获取future的结果,只需两个future处理完任务后处理该任务<br>tips：方法的参数源码<br>CompletionStage&lt;? extends U&gt; other,：合作线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; completableFuture3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;任务1...&quot;);</span></span><br><span class="line"><span class="comment">//                    return 111;</span></span><br><span class="line"><span class="comment">//                &#125;, service);</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; completableFuture4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务2...&quot;);</span></span><br><span class="line"><span class="comment">//            return 222;</span></span><br><span class="line"><span class="comment">//        &#125;, service);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        completableFuture3.runAfterBothAsync(completableFuture4,()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;任务3...&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;,service);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        任务1...</span></span><br><span class="line"><span class="comment">        当前线程：12</span></span><br><span class="line"><span class="comment">        任务2...</span></span><br><span class="line"><span class="comment">        任务3...</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        completableFuture3.thenAcceptBothAsync(completableFuture4, (f1,f2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务3...&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;f1:&quot; + f1 + &quot;.f2:&quot; + f2);</span></span><br><span class="line"><span class="comment">//        &#125;, service);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        任务1...</span></span><br><span class="line"><span class="comment">        当前线程：12</span></span><br><span class="line"><span class="comment">        任务2...</span></span><br><span class="line"><span class="comment">        任务3...</span></span><br><span class="line"><span class="comment">        f1:111.f2:222</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Integer&gt; integerCompletableFuture = completableFuture3.thenCombineAsync(completableFuture4, (f1, f2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;任务3...&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;f1:&quot; + f1 + &quot;.f2:&quot; + f2);</span></span><br><span class="line"><span class="comment">//            return 3;</span></span><br><span class="line"><span class="comment">//        &#125;, service);</span></span><br><span class="line"><span class="comment">//        System.out.println(integerCompletableFuture.get());</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * main....start....</span></span><br><span class="line"><span class="comment">        当前线程：11</span></span><br><span class="line"><span class="comment">        任务1...</span></span><br><span class="line"><span class="comment">        当前线程：12</span></span><br><span class="line"><span class="comment">        任务2...</span></span><br><span class="line"><span class="comment">        任务3...</span></span><br><span class="line"><span class="comment">        f1:111.f2:222</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        main....end....</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双线程完成其一就能后"><a href="#双线程完成其一就能后" class="headerlink" title="双线程完成其一就能后"></a>双线程完成其一就能后</h4><h5 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------- Arbitrary-arity constructions -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is completed when all of</span></span><br><span class="line"><span class="comment"> * the given CompletableFutures complete.  If any of the given</span></span><br><span class="line"><span class="comment"> * CompletableFutures complete exceptionally, then the returned</span></span><br><span class="line"><span class="comment"> * CompletableFuture also does so, with a CompletionException</span></span><br><span class="line"><span class="comment"> * holding this exception as its cause.  Otherwise, the results,</span></span><br><span class="line"><span class="comment"> * if any, of the given CompletableFutures are not reflected in</span></span><br><span class="line"><span class="comment"> * the returned CompletableFuture, but may be obtained by</span></span><br><span class="line"><span class="comment"> * inspecting them individually. If no CompletableFutures are</span></span><br><span class="line"><span class="comment"> * provided, returns a CompletableFuture completed with the value</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Among the applications of this method is to await completion</span></span><br><span class="line"><span class="comment"> * of a set of independent CompletableFutures before continuing a</span></span><br><span class="line"><span class="comment"> * program, as in: &#123;<span class="doctag">@code</span> CompletableFuture.allOf(c1, c2,</span></span><br><span class="line"><span class="comment"> * c3).join();&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs the CompletableFutures</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new CompletableFuture that is completed when all of the</span></span><br><span class="line"><span class="comment"> * given CompletableFutures complete</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the array or any of its elements are</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> andTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is completed when any of</span></span><br><span class="line"><span class="comment"> * the given CompletableFutures complete, with the same result.</span></span><br><span class="line"><span class="comment"> * Otherwise, if it completed exceptionally, the returned</span></span><br><span class="line"><span class="comment"> * CompletableFuture also does so, with a CompletionException</span></span><br><span class="line"><span class="comment"> * holding this exception as its cause.  If no CompletableFutures</span></span><br><span class="line"><span class="comment"> * are provided, returns an incomplete CompletableFuture.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs the CompletableFutures</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new CompletableFuture that is completed with the</span></span><br><span class="line"><span class="comment"> * result or exception of any of the given CompletableFutures when</span></span><br><span class="line"><span class="comment"> * one completes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the array or any of its elements are</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>allOf：等待所有任务完成</li><li>anyOf：只要有一个任务完成</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; img = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查询商品图片信息&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1.jpg&quot;</span>;</span><br><span class="line">&#125;,service);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; attr = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;查询商品属性&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;麒麟990 5G  钛空银&quot;</span>;</span><br><span class="line">&#125;,service);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; desc = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查询商品介绍&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">&#125;,service);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等这三个都做完</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(img, attr, desc);</span><br><span class="line">allOf.join();</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(&quot;main....end&quot;  + desc.get() + attr.get() + img.get());</span></span><br><span class="line"><span class="comment">//CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(img, attr, desc);</span></span><br><span class="line"><span class="comment">//anyOf.get();</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;main....end&quot;</span> + img.get()+attr.get()+desc.get());</span><br><span class="line"></span><br><span class="line">main....start</span><br><span class="line">查询商品图片信息</span><br><span class="line">查询商品介绍</span><br><span class="line">#这里卡2s</span><br><span class="line">查询商品属性</span><br><span class="line">main....end1.jpg麒麟<span class="number">990</span> 5G  钛空银华为</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture-自定义线程池"><a href="#CompletableFuture-自定义线程池" class="headerlink" title="CompletableFuture+自定义线程池"></a>CompletableFuture+自定义线程池</h3><h4 id="CompletableFuture-自定义线程池-1"><a href="#CompletableFuture-自定义线程池-1" class="headerlink" title="CompletableFuture+自定义线程池"></a>CompletableFuture+自定义线程池</h4><p>线程池配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: cx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span>: 2020-06-23 20:24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThreadPoolConfigProperties.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">(ThreadPoolConfigProperties pool)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                pool.getCoreSize(),</span><br><span class="line">                pool.getMaxSize(),</span><br><span class="line">                pool.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadPoolConfigProperties"><a href="#ThreadPoolConfigProperties" class="headerlink" title="ThreadPoolConfigProperties"></a>ThreadPoolConfigProperties</h3><p>将配置参数抽取出来到application.properties<br>加上@Component，或者MyThreadConfig导入ThreadPoolConfigProperties.class的时候加上@EnableConfigurationProperties注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;gulimall.thread&quot;)</span></span><br><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfigProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer keepAliveTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SkuItemVo <span class="title function_">item</span><span class="params">(Long skuId)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SkuItemVo</span> <span class="variable">skuItemVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuItemVo</span>();</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;SkuInfoEntity&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//1、sku基本信息的获取  pms_sku_info</span></span><br><span class="line">        <span class="type">SkuInfoEntity</span> <span class="variable">info</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(skuId);</span><br><span class="line">        skuItemVo.setInfo(info);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="comment">//3、获取spu的销售属性组合</span></span><br><span class="line">        List&lt;SkuItemSaleAttrVo&gt; saleAttrVos = skuSaleAttrValueService.getSaleAttrBySpuId(res.getSpuId());</span><br><span class="line">        skuItemVo.setSaleAttr(saleAttrVos);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; descFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="comment">//4、获取spu的介绍    pms_spu_info_desc</span></span><br><span class="line">        <span class="type">SpuInfoDescEntity</span> <span class="variable">spuInfoDescEntity</span> <span class="operator">=</span> spuInfoDescService.getById(res.getSpuId());</span><br><span class="line">        skuItemVo.setDesc(spuInfoDescEntity);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; baseAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="comment">//5、获取spu的规格参数信息</span></span><br><span class="line">        List&lt;SpuItemAttrGroupVo&gt; attrGroupVos = attrGroupService.getAttrGroupWithAttrsBySpuId(</span><br><span class="line">            res.getSpuId(), res.getCatalogId());</span><br><span class="line">        skuItemVo.setGroupAttrs(attrGroupVos);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Long spuId = info.getSpuId();</span></span><br><span class="line">    <span class="comment">// Long catalogId = info.getCatalogId();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、sku的图片信息    pms_sku_images</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; imageFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        List&lt;SkuImagesEntity&gt; imagesEntities = skuImagesService.getImagesBySkuId(skuId);</span><br><span class="line">        skuItemVo.setImages(imagesEntities);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; seckillFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//3、远程调用查询当前sku是否参与秒杀优惠活动</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">skuSeckilInfo</span> <span class="operator">=</span> seckillFeignService.getSkuSeckilInfo(skuId);</span><br><span class="line">        <span class="keyword">if</span> (skuSeckilInfo.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//查询成功</span></span><br><span class="line">            <span class="type">SeckillSkuVo</span> <span class="variable">seckilInfoData</span> <span class="operator">=</span> skuSeckilInfo.getData(<span class="string">&quot;data&quot;</span>, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;SeckillSkuVo&gt;() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            skuItemVo.setSeckillSkuVo(seckilInfoData);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (seckilInfoData != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt; seckilInfoData.getEndTime()) &#123;</span><br><span class="line">                    skuItemVo.setSeckillSkuVo(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等到所有任务都完成</span></span><br><span class="line">    CompletableFuture.allOf(saleAttrFuture,descFuture,baseAttrFuture,imageFuture,seckillFuture).get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skuItemVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-properties如下"><a href="#application-properties如下" class="headerlink" title="application.properties如下"></a>application.properties如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.type=redis</span><br><span class="line"></span><br><span class="line">#spring.cache.cache-names=qq,毫秒为单位</span><br><span class="line">spring.cache.redis.time-to-live=<span class="number">3600000</span></span><br><span class="line"></span><br><span class="line">#如果指定了前缀就用我们指定的前缀，如果没有就默认使用缓存的名字作为前缀</span><br><span class="line">#spring.cache.redis.key-prefix=CACHE_</span><br><span class="line">spring.cache.redis.use-key-prefix=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">#是否缓存空值，防止缓存穿透</span><br><span class="line">spring.cache.redis.cache-<span class="literal">null</span>-values=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">#配置线程池</span><br><span class="line">gulimall.thread.coreSize=<span class="number">20</span></span><br><span class="line">gulimall.thread.maxSize=<span class="number">200</span></span><br><span class="line">gulimall.thread.keepAliveTime=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">#开启debug日志</span><br><span class="line">logging.level.org.springframework.cloud.openfeign=debug</span><br><span class="line">logging.level.org.springframework.cloud.sleuth=debug</span><br><span class="line"></span><br><span class="line">#服务追踪</span><br><span class="line">spring.zipkin.base-url=http:<span class="comment">//192.168.18.80:9411/</span></span><br><span class="line">#关闭服务发现</span><br><span class="line">spring.zipkin.discovery-client-enabled=<span class="literal">false</span></span><br><span class="line">spring.zipkin.sender.type=web</span><br><span class="line">#配置采样器</span><br><span class="line">spring.sleuth.sampler.probability=<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="本地锁"><a href="#本地锁" class="headerlink" title="本地锁"></a>本地锁</h1><h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><h3 id="Synchronized关键字-1"><a href="#Synchronized关键字-1" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h3><p><strong>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。为什么呢？</strong></p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。<br>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。<br>所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 synchronized 关键字。</p><h3 id="synchronized-关键字使用方式"><a href="#synchronized-关键字使用方式" class="headerlink" title="synchronized 关键字使用方式"></a>synchronized 关键字使用方式</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p><ol><li><strong>修饰实例方法</strong>: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修饰代码块 ：指定加锁对象，对给定对象&#x2F;类加锁。<br>synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。<br>synchronized(类.class) 表示进入同步代码前要获得 当前 class 的锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。</li><li>synchronized 关键字加到实例方法上是给对象实例上锁。</li><li>尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！</li><li>构造方法可以使用 synchronized 关键字修饰么？先说结论：构造方法不能使用 synchronized 关键字修饰。构造方法本身就属于线程安全的，不存在同步的构造方法一说。</li></ul><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><h3 id="双重校验锁实现对象单例（线程安全）"><a href="#双重校验锁实现对象单例（线程安全）" class="headerlink" title="双重校验锁实现对象单例（线程安全）"></a>双重校验锁实现对象单例（线程安全）</h3><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p><h4 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><h4 id="同步版"><a href="#同步版" class="headerlink" title="同步版"></a>同步版</h4><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="comment">//封死了</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。</p><p>但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。</p><h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><p>这就引出了双重检验锁。双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance &#x3D;&#x3D; null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;<span class="comment">//Single Checked</span></span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;<span class="comment">//Double Checked</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检验锁-volatile"><a href="#双重检验锁-volatile" class="headerlink" title="双重检验锁+volatile"></a>双重检验锁+volatile</h4><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：<br>1为 uniqueInstance 分配内存空间<br>2初始化 uniqueInstance<br>3将 uniqueInstance 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h5 id="双重校验锁为什么要判断两次？"><a href="#双重校验锁为什么要判断两次？" class="headerlink" title="双重校验锁为什么要判断两次？"></a><strong>双重校验锁为什么要判断两次？</strong></h5><p>今天写synchronized用例的时候，两个线程共享一个对象数据，当操作i的时候，在同步代码块外面判断了一次i&lt;100,但是每一次跑，都会出现i&#x3D;100,的情况，此时我想起了单例模式的双重校验锁，为什么要判断两次呢？因为可能出现线程1和线程2，在i&#x3D;99的时候，同时判断了一次，都进到了for循环里面，此时线程1进入同步代码块，线程2进如阻塞队列，当线程1跑出代码块后，线程2进入同步代码块，线程1对i进行加一操作后，i变成了100，所以线程2就输出了100，所以要在同步代码块中再加一次判断，判断i的值<br>synchronized代码块使用起来比synchronized方法要灵活得多。因为也许一个方法中只有一部分代码只需要同步，如果此时对整个方法用synchronized进行同步，会影响程序执行效率。而使用synchronized代码块就可以避免这个问题，synchronized代码块可以实现只对需要同步的地方进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SychronizedTest2</span> <span class="variable">synchronized2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SychronizedTest2</span>();</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> synchronized2.<span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                data.insert();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                data.insert();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i ++)</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!arr.contains(i))&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 正在插入&quot;</span>+i);</span><br><span class="line">                            arr.add(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-关键字的底层原理"><a href="#synchronized-关键字的底层原理" class="headerlink" title="synchronized 关键字的底层原理"></a>synchronized 关键字的底层原理</h3><h4 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：<br>1首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件<br>2然后执行javap -c -s -v -l SynchronizedDemo.class。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692227-c460e796-19dd-48fe-a4c9-e89a71684d8a.png" alt="img"></p><p>从上面我们可以看出：<br><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中：</strong></p><ul><li><strong>monitorenter 指令指向同步代码块的开始位置</strong></li><li><strong>monitorexit 指令则指明同步代码块的结束位置。</strong></li></ul><p>当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。<br>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor</a>实现的。每个对象中都内置了一个 ObjectMonitor对象。<br>另外，wait&#x2F;notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。<br>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。<br>在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h4 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1645428692170-9fa06ca0-6bc4-49e3-9f04-2434718e51c9.png" alt="img"></p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，<br>该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h4 id="synchronized原理总结"><a href="#synchronized原理总结" class="headerlink" title="synchronized原理总结"></a>synchronized原理总结</h4><ol><li>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</li><li>修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</li><li>不过两者的本质都是对对象监视器 monitor 的获取。</li></ol><h3 id="synchronized的阻塞通知方法"><a href="#synchronized的阻塞通知方法" class="headerlink" title="synchronized的阻塞通知方法"></a>synchronized的阻塞通知方法</h3><h4 id="Object的wait方法"><a href="#Object的wait方法" class="headerlink" title="Object的wait方法"></a>Object的wait方法</h4><h4 id="Object的notify方法"><a href="#Object的notify方法" class="headerlink" title="Object的notify方法"></a>Object的notify方法</h4><h3 id="Synchronized-版生产消费问题【等待，业务，通知】"><a href="#Synchronized-版生产消费问题【等待，业务，通知】" class="headerlink" title="Synchronized 版生产消费问题【等待，业务，通知】"></a>Synchronized 版生产消费问题【等待，业务，通知】</h3><p>加锁口诀：三个单词</p><ul><li>判断（等待）</li><li>业务</li><li>通知</li></ul><h4 id="四线程Demo"><a href="#四线程Demo" class="headerlink" title="四线程Demo"></a>四线程Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们同步代码块当中的等待方法用的是wait，那wait&#x2F;sleep 有什么区别呢？</p><blockquote><p><strong>来自不同的类</strong><br>sleep 是 Thread 的静态方法，<br>wait 是 Object 的方法，任何对象实例都能调用。<br><strong>关于锁的释放</strong><br>sleep 不会释放锁，它也不需要占用锁。<br>wait 会释放锁，但调用它的前提 是当前线程占有锁，即代码要在 synchronized 中。  </p></blockquote><h4 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h4><p>上面的输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">D:\java8u211\jdk\bin\java.exe <span class="string">&quot;-javaagent:D:\idea\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=57232:D:\idea\IntelliJ IDEA 2019.1.4\bin&quot;</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath D:\java8u211\jdk\jre\lib\charsets.jar;D:\java8u211\jdk\jre\lib\deploy.jar;D:\java8u211\jdk\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\java8u211\jdk\jre\lib\ext\cldrdata.jar;D:\java8u211\jdk\jre\lib\ext\dnsns.jar;D:\java8u211\jdk\jre\lib\ext\jaccess.jar;D:\java8u211\jdk\jre\lib\ext\jfxrt.jar;D:\java8u211\jdk\jre\lib\ext\localedata.jar;D:\java8u211\jdk\jre\lib\ext\nashorn.jar;D:\java8u211\jdk\jre\lib\ext\sunec.jar;D:\java8u211\jdk\jre\lib\ext\sunjce_provider.jar;D:\java8u211\jdk\jre\lib\ext\sunmscapi.jar;D:\java8u211\jdk\jre\lib\ext\sunpkcs11.jar;D:\java8u211\jdk\jre\lib\ext\zipfs.jar;D:\java8u211\jdk\jre\lib\javaws.jar;D:\java8u211\jdk\jre\lib\jce.jar;D:\java8u211\jdk\jre\lib\jfr.jar;D:\java8u211\jdk\jre\lib\jfxswt.jar;D:\java8u211\jdk\jre\lib\jsse.jar;D:\java8u211\jdk\jre\lib\management-agent.jar;D:\java8u211\jdk\jre\lib\plugin.jar;D:\java8u211\jdk\jre\lib\resources.jar;D:\java8u211\jdk\jre\lib\rt.jar;E:\_九阴真经\juc2\kuang_livenote\【遇见狂神说】JUC视频笔记\代码\target\classes;E:\dev_dir_temp\apache-maven-<span class="number">3.3</span><span class="number">.9</span>\respository\org\projectlombok\lombok\<span class="number">1.18</span><span class="number">.8</span>\lombok-<span class="number">1.18</span><span class="number">.8</span>.jar com.kuang.pc.A</span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">A=&gt;<span class="number">2</span></span><br><span class="line">C=&gt;<span class="number">3</span></span><br><span class="line">B=&gt;<span class="number">2</span></span><br><span class="line">B=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">A=&gt;<span class="number">2</span></span><br><span class="line">C=&gt;<span class="number">3</span></span><br><span class="line">D=&gt;<span class="number">2</span></span><br><span class="line">D=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">B=&gt;-<span class="number">1</span></span><br><span class="line">B=&gt;-<span class="number">2</span></span><br><span class="line">B=&gt;-<span class="number">3</span></span><br><span class="line">D=&gt;-<span class="number">4</span></span><br><span class="line">D=&gt;-<span class="number">5</span></span><br><span class="line">D=&gt;-<span class="number">6</span></span><br><span class="line">D=&gt;-<span class="number">7</span></span><br><span class="line">D=&gt;-<span class="number">8</span></span><br><span class="line">D=&gt;-<span class="number">9</span></span><br><span class="line">D=&gt;-<span class="number">10</span></span><br><span class="line">C=&gt;-<span class="number">9</span></span><br><span class="line">A=&gt;-<span class="number">8</span></span><br><span class="line">C=&gt;-<span class="number">7</span></span><br><span class="line">A=&gt;-<span class="number">6</span></span><br><span class="line">C=&gt;-<span class="number">5</span></span><br><span class="line">A=&gt;-<span class="number">4</span></span><br><span class="line">C=&gt;-<span class="number">3</span></span><br><span class="line">A=&gt;-<span class="number">2</span></span><br><span class="line">C=&gt;-<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632577122892-fbf287e5-ece7-49c0-b518-a2ffec7050fc.png" alt="image.png"></p><p>拿两个加法线程A、B来说，比如A先执行，执行时调用了wait方法，那它会等待，此时会释放锁，那么线程B获得锁并且也会执行wait方法，<strong>两个加线程一起等待被唤醒</strong>。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，<strong>那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后B再执行。</strong></p><p>所以如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1632577725001-175d394b-fca9-4fdf-ac47-066794fad3cb.png" alt="image.png"></p><h4 id="虚假唤醒修复"><a href="#虚假唤醒修复" class="headerlink" title="虚假唤醒修复"></a>虚假唤醒修复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">D:\java8u211\jdk\bin\java.exe <span class="string">&quot;-javaagent:D:\idea\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=56573:D:\idea\IntelliJ IDEA 2019.1.4\bin&quot;</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath D:\java8u211\jdk\jre\lib\charsets.jar;D:\java8u211\jdk\jre\lib\deploy.jar;D:\java8u211\jdk\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\java8u211\jdk\jre\lib\ext\cldrdata.jar;D:\java8u211\jdk\jre\lib\ext\dnsns.jar;D:\java8u211\jdk\jre\lib\ext\jaccess.jar;D:\java8u211\jdk\jre\lib\ext\jfxrt.jar;D:\java8u211\jdk\jre\lib\ext\localedata.jar;D:\java8u211\jdk\jre\lib\ext\nashorn.jar;D:\java8u211\jdk\jre\lib\ext\sunec.jar;D:\java8u211\jdk\jre\lib\ext\sunjce_provider.jar;D:\java8u211\jdk\jre\lib\ext\sunmscapi.jar;D:\java8u211\jdk\jre\lib\ext\sunpkcs11.jar;D:\java8u211\jdk\jre\lib\ext\zipfs.jar;D:\java8u211\jdk\jre\lib\javaws.jar;D:\java8u211\jdk\jre\lib\jce.jar;D:\java8u211\jdk\jre\lib\jfr.jar;D:\java8u211\jdk\jre\lib\jfxswt.jar;D:\java8u211\jdk\jre\lib\jsse.jar;D:\java8u211\jdk\jre\lib\management-agent.jar;D:\java8u211\jdk\jre\lib\plugin.jar;D:\java8u211\jdk\jre\lib\resources.jar;D:\java8u211\jdk\jre\lib\rt.jar;E:\_九阴真经\juc2\kuang_livenote\【遇见狂神说】JUC视频笔记\代码\target\classes;E:\dev_dir_temp\apache-maven-<span class="number">3.3</span><span class="number">.9</span>\respository\org\projectlombok\lombok\<span class="number">1.18</span><span class="number">.8</span>\lombok-<span class="number">1.18</span><span class="number">.8</span>.jar com.kuang.pc.A</span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">D=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">A=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line">C=&gt;<span class="number">1</span></span><br><span class="line">B=&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线程是操作系统的最小可操作分配资源，Java的线程通过调用&lt;code&gt;Thread.start()&lt;/code&gt;启动，本质上是在调用&lt;code&gt;native&lt;/code&gt;方法&lt;code&gt;start0()&lt;/code&gt;,该方法通过&lt;code&gt;JNI(</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JUC" scheme="https://lyotoc.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://lyotoc.github.io/2022/06/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://lyotoc.github.io/2022/06/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-06-20T02:40:16.000Z</published>
    <updated>2022-06-22T07:13:20.273Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是<a href="https://so.csdn.net/so/search?q=Lambda&spm=1001.2101.3001.7020">Lambda</a>表达式</h2><blockquote><p>Lambda是一个匿名函数，可以把<code>lambda表达式</code>理解为一段可以传递的代码</p></blockquote><h2 id="初见Lambda表达式"><a href="#初见Lambda表达式" class="headerlink" title="初见Lambda表达式"></a>初见Lambda表达式</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001163917413.png" alt="img"></p><p>r1是一个Runnable接口的匿名实现类的对象，r2是使用Lambda表达式来创建对象，两个对象的效果一样，但是r2的代码明显更加简洁。这就是Lambda表达式。</p><p>化简为Lambda表达式的原则：能省就省。上图中Runnable接口只有一个需要实现的方法（即run方法），所以我们不需要写方法名就可以确定方法名（这其实就是函数式接口），由于r2是Runnable接口的对象，所以我们也可以确定类名。所以就化简为了( )→System.out.print(“xxx”);</p><p>再看个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001163952338.png" alt="img"></p><p>我们如何把上面的代码化简为Lambda表达式呢？可以看到这里仅仅多了两个参数，所以我们把两个参数加上即可：</p><p>  <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164011376.png" alt="img"></p><p>我们还有一个更加简洁的版本：方法引用</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164029882.png" alt="img"></p><p>方法引用我们后面会讲，先介绍Lambda表达式：</p><h3 id="Lambda表达式写法"><a href="#Lambda表达式写法" class="headerlink" title="Lambda表达式写法"></a>Lambda表达式写法</h3><p>( xx,xx ) - &gt; 方法体</p><p>左边：接口中抽象方法的形参列表</p><p>右边：重写接口中抽象方法的方法体</p><p>Lambda表达式的本质：作为接口的一个实例（对象）</p><p>表达式共有六种使用情况</p><h4 id="1-无参，无返回值"><a href="#1-无参，无返回值" class="headerlink" title="1. 无参，无返回值"></a>1. 无参，无返回值</h4><p>这是我们前面的Runnable接口的例子。</p><h4 id="2-一个参数，无返回值"><a href="#2-一个参数，无返回值" class="headerlink" title="2. 一个参数，无返回值"></a>2. 一个参数，无返回值</h4><p>不使用Lambda表达式：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164050287.png" alt="img"></p><p>使用Lambda表达式：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116410432.png" alt="img"></p><p>Lambda表达式的方法体中，如果只有一条语句，那么大括号写不写都行。</p><h4 id="3-数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”"><a href="#3-数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”" class="headerlink" title="3. 数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”"></a>3. 数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”</h4><p>还是上面Consumer的例子，由于Consumer中的泛型为<String>，编译器可以推断出参数类型为String，所以我们不需要在Lambda表达式的形参列表中声明String，</p><p>类型推断的另一个例子：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164137508.png" alt="img"></p><p>由于泛型中已经声明了String，我们就不需要在后面的&lt;&gt;中声明String了。</p><h4 id="4-Lambda表达式如果只有一个参数，那么参数的小括号可以省略"><a href="#4-Lambda表达式如果只有一个参数，那么参数的小括号可以省略" class="headerlink" title="4. Lambda表达式如果只有一个参数，那么参数的小括号可以省略"></a>4. Lambda表达式如果只有一个参数，那么参数的小括号可以省略</h4><p>还是Cosnumer的例子，省略小括号后：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164220606.png" alt="img"></p><h4 id="5-Lambda有多个参数，有返回值"><a href="#5-Lambda有多个参数，有返回值" class="headerlink" title="5. Lambda有多个参数，有返回值"></a>5. Lambda有多个参数，有返回值</h4><p><strong>不使用Lambda表达式：</strong><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116422960.png" alt="img"></p><p><strong>使用Lambda表达式：</strong><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164238120.png" alt="img"></p><p>由于类型推断，我们可以把o1和o2的类型省略。</p><p>如果实现的compare方法中有多个语句，那么我们不能省略方法体的大括号和return关键字：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164253242.png" alt="img"></p><h4 id="6-当Lambda方法体只有一条语句，那么return和大括号都可以省略"><a href="#6-当Lambda方法体只有一条语句，那么return和大括号都可以省略" class="headerlink" title="6. 当Lambda方法体只有一条语句，那么return和大括号都可以省略"></a>6. 当Lambda方法体只有一条语句，那么return和大括号都可以省略</h4><p>这就是上面的comparator例子：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164305622.png" alt="img"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Lambda表达式：(形参列表) - &gt; { 方法体 }</p><p>本质：接口的实例对象。</p><p><strong>对于接口的要求：要求此接口必须只声明了一个抽象方法（这就是函数式接口）。</strong>上面的例子中的接口，我们看源码的话会发现接口上都有一个注解*@FunctionalInterface*，表明这是一个函数式接口。这个注解仅仅是为了检验此接口是否为函数式接口，不加也行。</p><p>形参列表：参数类型可以省略；如果参数列表只有一个参数，那么小括号也可以省略，没有参数或者有一个以上的参数就不能省略小括号。</p><p>方法体：如果方法体只有一条执行语句，则可以省略大括号和return关键字。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>只声明了一个抽象方法的接口。java不仅支持面向对象编程（OOP）也可以面向函数编程（OOF）</p><p>Lambda表达式就是一个函数式接口的对象。</p><p>以前用匿名实现类表示的现在都可以用Lambda表达式来写。</p><h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><p>四大函数式接口指的是<code>Consumer</code>、<code>Function</code>、<code>Predicate</code>、<code>Supplier</code>，位于<code>java.util.function</code>包下</p><p>第一种：<strong>Consumer&lt;T&gt;</strong>:消费型接口      void accept(T t);</p><p>第二种：<strong>Supplier&lt;T&gt;</strong>:供给型接口      T get();</p><p>第三种：<strong>Function&lt;T,R&gt;</strong>:函数型接口 ，T为自变量，R为因变量     R apply(T t);</p><p>第四种：<strong>Predicate&lt;T&gt;</strong>:断言型接口 boolean test(T t)</p><p>消费型接口示例：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164346440.png" alt="img"></p><p>断言型接口示例：</p><p>定义一个方法，第二个参数为断言型接口，想要实现的功能为：基于某种规则pre，来筛选list中符合规则的字符串。<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164354200.png" alt="img"></p><p>筛选规则我们可以通过Lambda表达式来实现：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164400502.png" alt="img"></p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="使用情形"><a href="#使用情形" class="headerlink" title="使用情形"></a>使用情形</h3><p>当要传递给Lambda表达式方法体的操作，已经有实现的方法了，此时可以使用方法引用。</p><p>方法引用本质上就是Lambda表达式，即方法引用也是函数式接口的实例。</p><h3 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h3><p>类(或对象) : : 方法名</p><p>参数列表都不用写了</p><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><p>对于下面的情况1和情况2：<strong>要求接口中的抽象方法的形参列表和返回值，与方法引用的方法的形参列表和返回值都相同。而且本来我们Lambda表达式的方法体代码中正好用到了方法引用的方法，我们就可以使用方法引用来替换Lambda表达式。</strong></p><p>对于情况3，可以不满足上面的描述，具体往下看。</p><p>方法引用一共分为如下三种情况</p><h4 id="1-对象-非静态方法"><a href="#1-对象-非静态方法" class="headerlink" title="1. 对象 : : 非静态方法"></a>1. 对象 : : 非静态方法</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164411857.png" alt="img"></p><p>分析：Lambda表达式中的方法体为System.out.println(str)，然后调用con1的accept方法。我们发现PrintStream类中的println方法和accept方法参数列表和返回值都一样，我们可以理解为println方法已经实现了accept方法（传递给Lambda表达式方法体的操作，已经有实现的方法了），所以我们可以使用方法引用</p><p>再来看一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164417289.png" alt="img"></p><p>觉得难以理解没关系，这只是一种新的语法，逻辑上确实难以理解，用多了就懂了。</p><h4 id="2-类-静态方法"><a href="#2-类-静态方法" class="headerlink" title="2. 类 : : 静态方法"></a>2. 类 : : 静态方法</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164424105.png" alt="img"></p><p>再来一个示例：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164428981.png" alt="img"></p><h4 id="3-类-非静态方法（有难度）"><a href="#3-类-非静态方法（有难度）" class="headerlink" title="3. 类 : : 非静态方法（有难度）"></a>3. 类 : : 非静态方法（有难度）</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164437918.png" alt="img"></p><p>我们发现compare的两个参数，第一个参数可以当做调用者调用String类的compareTo方法，第二个参数仍然作为参数。这时就可以使用类：：非静态方法的形式。注意我们仍然不写compareTo的参数列表。</p><p>再看个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164443372.png" alt="img"></p><p>只有一个参数的时候，也可以用类：：非静态方法，apply方法唯一的一个参数当做getName方法的调用者。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><h3 id="1-无参构造器"><a href="#1-无参构造器" class="headerlink" title="1. 无参构造器"></a>1. 无参构造器</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164448820.png" alt="img"></p><p>可以看到Employee类的无参构造方法，和get方法一样没有参数，当new 无参构造方法( )的时候会返回一个Employee对象。当我们Lambda表达式的方法体中调用了new Employee( )的时候，就可以使用方法引用Employee : : new 。</p><h3 id="2-有参构造器"><a href="#2-有参构造器" class="headerlink" title="2. 有参构造器"></a>2. 有参构造器</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164454488.png" alt="img"></p><p>我们同样不能在方法引用上加参数，因为参数可以通过apply传递。</p><p>再来看一个两个参数的构造器：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164501688.png" alt="img"></p><h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116450739.png" alt="img"></p><p>返回值为一个数组对象，其他的和构造器引用类似。</p><p>把数组看做一个特殊的类，则写法与构造器引用一致。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>可以不会写，但是要能看懂，因为很多源码使用了Lambda表达式或者方法引用。</p><h1 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h1><h2 id="创建Stream的方式"><a href="#创建Stream的方式" class="headerlink" title="创建Stream的方式"></a>创建Stream的方式</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; stream();  返回一个顺序流</span></span><br><span class="line">Stream&lt;Employee&gt; stream0 = employees.stream();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; parallelStream(); 返回一个并行流</span></span><br><span class="line">Stream&lt;Employee&gt; stream1 = employees.parallelStream();</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java8中的Arrays的静态方法stream()可以获取数组流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Arrays.stream(arr);</span><br></pre></td></tr></table></figure><h3 id="Stream本身的of"><a href="#Stream本身的of" class="headerlink" title="Stream本身的of()"></a>Stream本身的of()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; intStream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="comment">//  public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line"><span class="comment">//遍历前10个偶数</span></span><br><span class="line"></span><br><span class="line">Stream.iterate(<span class="number">0</span>,t -&gt; t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成</span></span><br><span class="line"><span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h2><p>多个中间操作可以连接起来形成一个<strong>流水线</strong>，除非流水线线上触发终止操作，否则<strong>中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</strong></p><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filter()</td><td>接受Lambda，从流中排除某些元素</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成的hashCode()和equals()去除重复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前N个元素的流，若流中元素不足N个，则返回一个空流，与limit(n)互补</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line">list.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//distinct 去除重复元素</span></span><br><span class="line">list.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//limit 取集合中的前10个元素</span></span><br><span class="line">list.stream().limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//skip 跳过前10个元素并打印集合剩下的其它的元素</span></span><br><span class="line">list.stream().skip(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>map(Function f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td>mapToDouble(ToDoubleFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的DouleStream</td></tr><tr><td>mapToInt(ToIntFuction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的IntStream</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的LongStream</td></tr><tr><td>flatMap(Function f)</td><td>接收一个函数作为参数，将流中的每一个值都换成另一个流，然后把所有流都连接成一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map</span></span><br><span class="line">List&lt;String&gt; strs = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">strs.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"><span class="comment">//flatMap</span></span><br><span class="line"><span class="comment">//此时得到的是多个Stream组成的Stream</span></span><br><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream().map(API::formStringToStream);</span><br><span class="line">stream.forEach(item -&gt; item.forEach(System.out::println));</span><br><span class="line"><span class="comment">//若使用flatMap则会自动拆箱，对元素进行操作，得到的是一个内含元素的stream</span></span><br><span class="line">Stream&lt;Character&gt; stream1 = list.stream().flatMap(API::formStringToStream);</span><br><span class="line">stream1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">formStirngToStream</span><span class="params">(Stirng str)</span>&#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">for</span>(Character c : str.toCharArray())&#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sorted() 自然排序</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">10</span>,<span class="number">43</span>,<span class="number">65</span>,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">list.stream().sorted().froEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于未实现Comparable接口的类使用sorted会抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sorted(Comparator com) 定制排序</span></span><br><span class="line">List&lt;Employee&gt; employees = Employee.getEmployees();</span><br><span class="line">employees.stream.sorted((e1,e2) -&gt; Integer.compare(e1.getAge,e2.getAge)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="Stream的终止操作"><a href="#Stream的终止操作" class="headerlink" title="Stream的终止操作"></a>Stream的终止操作</h2><blockquote><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List,Integer,甚至是void。</p><p>流进行了终止操作后，不能再次使用。</p></blockquote><h3 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中的元素的总个数</td></tr><tr><td>max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>min(Comparator c)</td><td>返回流中的最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allMatch(Predicate p) 检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">// 是否所有的员工的年龄都大于18岁</span></span><br><span class="line"><span class="type">blooean</span> <span class="variable">allMatch</span> <span class="operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//anyMatch(Predicate p)  检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">//是否存在员工的工资大于 10000</span></span><br><span class="line"><span class="type">blooean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> employees.stream().anyMatch(e-&gt;e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//noneMatch(Predicate p)检查是否没有匹配所有元素</span></span><br><span class="line"><span class="comment">//是否存在员工姓“雷”</span></span><br><span class="line"><span class="type">boolean</span> employees.stream().noneMatch(e -&gt; e.getName().startWith(“雷”));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//findFirst()返回第一个元素</span></span><br><span class="line">Optional&lt;Employee&gt; employee = employees.stream().findFrist();</span><br><span class="line"><span class="comment">//findAny()返回当前流中的任意一个元素</span></span><br><span class="line">Optional&lt;Employee&gt; employee = employees.parallelStream().findAny();</span><br><span class="line"><span class="comment">//count()返回流中的元素的总个数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line"><span class="comment">//max(Comparator c)返回流中最大值</span></span><br><span class="line"><span class="comment">//返回最高的工资</span></span><br><span class="line">Optional&lt;Double&gt; maxSalary = employees.stream().map(Employee::getSalary).max(Double::compare);</span><br><span class="line"><span class="comment">//min(Comparator c)返回流中的最小值</span></span><br><span class="line"><span class="comment">//返回最低工资员工</span></span><br><span class="line">Optional&lt;Double&gt; minSalaryEmp = employees.stream().min((e1,e2) -&gt;Double.compare(e1.getSalary(),e2.getSalary()));</span><br><span class="line"><span class="comment">//forEach(Consumer c) 内部迭代</span></span><br><span class="line">employees.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">//使用集合的遍历操作</span></span><br><span class="line">employees.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduce(T iden, BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回T</span></span><br><span class="line"><span class="comment">//计算自然数的和</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>,Integer::sum);</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce(BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span></span><br><span class="line">Optional&lt;Double&gt; sumMoney = employees.stream().map(Employee::getSalary).reduce(Double::sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220622144546304.png" alt="image-20220622144546304"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220622144706835.png" alt="image-20220622144706835"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">List&lt;Employee&gt; emps = employees.stream().filter(e-&gt;e.getSalary()&gt;<span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><blockquote><p>到目前为止，臭名昭著的空指针异常是导致Jva应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式米防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java8类库的一部分。Optional&lt;T&gt;类(Gava.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null,表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</p><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true,调用get()方法会返回该对象。</p></blockquote><p>● Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><ul><li><p><strong>创建Optional类对象的方法</strong></p><ul><li>Optional.of(Tt):创建一个Optional实例，t必须非空；</li><li>Optional.empty):创建一个空的Optional实例</li><li>Optional.ofNullable(T t):t可以为null</li></ul></li><li><p><strong>判断Optional容器中是否包含对象：</strong></p><ul><li>boolean isPresent():判断是否包含对象</li><li>void ifPresent(Consumer&lt;?super T&gt;consumer):如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ul></li><li><p><strong>获取Optional容器的对象：</strong></p><ul><li><p>Tget():如果调用对象包含值，返回该值，否则抛异常</p></li><li><p>T orElse(T other):如果有值则将其返回，否则返回指定的other对象。</p></li><li><p>T orElseGet( Supplier&lt;?extends T下other)：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</p></li><li><p>T orElseThrow(Supplier&lt;?extends X&gt;exceptionSupplier):如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</p></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;h2 id=&quot;什么是Lambda表达式&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>k8s使用及理解</title>
    <link href="https://lyotoc.github.io/2022/06/15/k8s%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%90%86%E8%A7%A3/"/>
    <id>https://lyotoc.github.io/2022/06/15/k8s%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%90%86%E8%A7%A3/</id>
    <published>2022-06-15T09:26:29.000Z</published>
    <updated>2022-06-27T06:58:26.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PART1-概念"><a href="#PART1-概念" class="headerlink" title="PART1 概念"></a>PART1 概念</h1><h2 id="K8S概述和特性"><a href="#K8S概述和特性" class="headerlink" title="K8S概述和特性"></a>K8S概述和特性</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>容器化集群管理系统</p></li><li><p>部署应用容器化</p></li><li><p>利于应用扩展</p></li><li><p>让部署容器化应用更加简洁和高效</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>自动装箱</p><ul><li>基于容器对应用运行环境的资源配置要求自动部署应用容器</li></ul></li><li><p>自我修复<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928101336750.png" alt="image-20200928101336750"></p><ul><li>容器失败时，会重启该容器</li><li>运行Node节点出现问题时，会重新调度、部署<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122112241092.png" alt="image-20201122112241092"></li><li>当容器未通过监控检查时，会关闭该容器直到正常运行，才会对外提供服务</li></ul></li><li><p>水平扩展</p><ul><li>通过简单的命令、用户UI界面或基于CPU等资源的使用情况，对应用容器扩容或剪裁<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122112301750.png" alt="image-20201122112301750"></li></ul></li><li><p>服务发现</p><ul><li>用户不需使用额外的服务发现机制，就能够基于Kubernetes自身能力实现服务发现和负载均衡<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928101711968.png" alt="image-20200928101711968"></li></ul></li><li><p>滚动更新</p><ul><li><p>可以根据应用的变化，对应用容器运行的应用进行一次或批量式更新</p><blockquote><p>添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用</p></blockquote></li></ul></li><li><p>版本回退</p><ul><li>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li></ul></li><li><p>密钥和配置管理</p><ul><li>在不需要重新构建镜像的情况下，可以部署和更新密钥及应用配置，类似热部署</li></ul></li><li><p>存储编排</p><ul><li>提供一次性任务、定时任务，满足批量数据处理和分析的场景</li></ul></li></ul><h2 id="K8S架构组件"><a href="#K8S架构组件" class="headerlink" title="K8S架构组件"></a>K8S架构组件</h2><h3 id="完整架构图"><a href="#完整架构图" class="headerlink" title="完整架构图"></a><strong>完整架构图</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928103059652.png" alt="完整的架构图"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110124821.png" alt="image-20200928110124821"></p><h3 id="架构细节"><a href="#架构细节" class="headerlink" title="架构细节"></a>架构细节</h3><p>K8S架构主要包含两部分：<code>Master</code>（<strong>主控节点</strong>）和 <code>node</code>（<strong>工作节点</strong>）</p><p><strong>master节点架构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122113057343.png" alt="master节点架构图"></p><p><strong>Node节点架构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122155629990.png" alt="image-20201122155629990"></p><p>k8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；</p><ul><li><strong>master</strong>：主控节点<ul><li>API Server：集群统一入口，以restful风格进行操作，同时交给etcd存储<ul><li>提供认证、授权、访问控制、API注册和发现等机制</li></ul></li><li>scheduler：节点的调度，选择node节点应用部署</li><li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li><li>etcd：存储系统，用于保存集群中的相关数据</li></ul></li><li><strong>Work node</strong>：工作节点<ul><li>Kubelet：master派到node节点代表，管理本机容器<ul><li>一个集群中每个节点上运行的代理，它保证容器都运行在Pod中</li><li>负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理</li></ul></li><li>kube-proxy：提供网络代理，负载均衡等操作</li></ul></li><li>容器运行环境【<strong>Container Runtime</strong>】<ul><li>容器运行环境是负责运行容器的软件</li><li>Kubernetes支持多个容器运行环境：Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。</li></ul></li><li>fluentd：是一个守护进程，它有助于提升 集群层面日志</li></ul><h2 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul><li><p>Pod是K8s中最小的单元</p></li><li><p>一组容器的集合</p></li><li><p>共享网络【一个Pod中的所有容器共享同一网络】</p></li><li><p>生命周期是短暂的（服务器重启后，就找不到了）</p></li></ul><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><ul><li>声明在Pod容器中可访问的文件目录</li><li>可以被挂载到Pod中一个或多个容器指定路径下</li><li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>确保预期的pod副本数量【ReplicaSet】</li><li>无状态应用部署【Deployment】<ul><li>无状态就是指，不需要依赖于网络或者ip</li></ul></li><li>有状态应用部署【StatefulSet】<ul><li>有状态需要特定的条件</li></ul></li><li>确保所有的node运行同一个pod 【DaemonSet】</li><li>一次性任务和定时任务【Job和CronJob】</li></ul><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><ul><li>定义一组Pod副本数目，版本等</li><li>通过控制器【Controller】维持Pod数目【自动回复失败的Pod】</li><li>通过控制器以指定的策略控制版本【滚动升级、回滚等】<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161601349.png" alt="image-20201122161601349"></li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul><li>定义一组pod的访问规则</li><li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li><li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161132055.png" alt="image-20201122161132055"></p><p>可以用来组合pod，同时对外提供服务</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>label：标签，用于对象资源查询，筛选</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161713638.png" alt="image-20201122161713638"></p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制【鉴权、资源】</li><li>每个资源都属于一个namespace</li><li>同一个namespace所有资源不能重复</li><li>不同namespace可以资源名重复</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>我们通过Kubernetes的API来操作整个集群</p><p>同时我们可以通过 kubectl 、ui、curl 最终发送 http + json&#x2F;yaml 方式的请求给API Server，然后控制整个K8S集群，K8S中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述</p><p>如下：使用yaml部署一个nginx的pod</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122162612448.png" alt="image-20201122162612448"></p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122163512535.png" alt="image-20201122163512535"></p><ul><li>通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APlserver写入etcd</li><li>此时Controller Manager通过API Server的监听资源变化的接口监听到此RC事件</li><li>分析之后，发现当前集群中还没有它所对应的Pod实例</li><li>于是根据RC里的Pod模板定义一个生成Pod对象，通过APIServer写入etcd</li><li>此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，然后通过API Server讲这一结果写入etcd中</li><li>目标Node上运行的Kubelet进程通过APiserver监测到这个”新生的Pod.并按照它的定义，启动该Pod并任劳任怨地负责它的下半生，直到Pod的生命结束</li><li>随后，我们通过Kubectl提交一个新的映射到该Pod的Service的创建请求</li><li>ControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的Endpoints信息，并通过APIServer写入到etod中，</li><li>接下来，所有Node上运行的Proxy进程通过APIServer查询并监听Service对象与其对应的Endponts信息，建立一个软件方式的负载均衡器来实现Service访问到后端Pod的流量转发功能</li></ul><h1 id="PART2-搭建K8S集群"><a href="#PART2-搭建K8S集群" class="headerlink" title="PART2  搭建K8S集群"></a>PART2  搭建K8S集群</h1><h2 id="搭建k8s环境平台规划"><a href="#搭建k8s环境平台规划" class="headerlink" title="搭建k8s环境平台规划"></a>搭建k8s环境平台规划</h2><h3 id="单master集群"><a href="#单master集群" class="headerlink" title="单master集群"></a>单master集群</h3><p>单个<code>master</code>节点，然后管理多个<code>node</code>节点</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110456495.png" alt="image-20200928110456495"></p><p><strong>该模型下存在较为明显且致命的缺点</strong></p><ul><li>由于是只有一个master节点做node节点的集群管理，在此模型下如果master节点发生故障宕机时，则无法对node节点做管理</li></ul><h3 id="多master集群"><a href="#多master集群" class="headerlink" title="多master集群"></a>多master集群</h3><p>多个master节点，管理多个node节点，同时中间多了一个负载均衡的过程</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110543829.png" alt="image-20200928110543829"></p><h3 id="服务器硬件配置要求"><a href="#服务器硬件配置要求" class="headerlink" title="服务器硬件配置要求"></a>服务器硬件配置要求</h3><h4 id="最低要求"><a href="#最低要求" class="headerlink" title="最低要求"></a>最低要求</h4><table><thead><tr><th>节点</th><th>要求</th></tr></thead><tbody><tr><td>master</td><td>2核 4G 20G</td></tr><tr><td>node</td><td>4核 8G 40G</td></tr></tbody></table><h3 id="部署Kubernetes集群主要的两种方式"><a href="#部署Kubernetes集群主要的两种方式" class="headerlink" title="部署Kubernetes集群主要的两种方式"></a>部署Kubernetes集群主要的两种方式</h3><h4 id="Kubeadm"><a href="#Kubeadm" class="headerlink" title="Kubeadm"></a>Kubeadm</h4><ol><li><p>介绍kubeadm是一个K8S部署工具，提供kubeadm init 和 kubeadm join，用于快速部署Kubernetes集群</p><p>官网地址：<a href="https://gitee.com/link?target=https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">点我传送</a></p></li></ol><h4 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h4><p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p><p>Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p><h3 id="Kubeadm部署集群"><a href="#Kubeadm部署集群" class="headerlink" title="Kubeadm部署集群"></a>Kubeadm部署集群</h3><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p><ul><li>创建一个Master 节点kubeadm init</li><li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li></ul><h3 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h3><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p><ul><li>一台或多台机器，操作系统为Centos7.X</li><li>硬件配置：2GB或更多GAM，2个CPU或更多CPU，硬盘30G</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>192.168.177.130</td></tr><tr><td>node1</td><td>192.168.177.131</td></tr><tr><td>node2</td><td>192.168.177.132</td></tr></tbody></table><p>然后开始在每台机器上执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭selinux</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久关闭</span></span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭swap</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时</span></span><br><span class="line">swapoff -a </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久关闭</span></span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据规划设置主机名【master节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8smaster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据规划设置主机名【node1节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8snode1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据规划设置主机名【node2节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8snode2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在master添加hosts</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.177.130 k8smaster</span><br><span class="line">192.168.177.131 k8snode1</span><br><span class="line">192.168.177.132 k8snode2</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将桥接的IPv4流量传递到iptables的链</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效</span></span><br><span class="line">sysctl --system  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间同步</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装Docker-x2F-kubeadm-x2F-kubelet"><a href="#安装Docker-x2F-kubeadm-x2F-kubelet" class="headerlink" title="安装Docker&#x2F;kubeadm&#x2F;kubelet"></a>安装Docker&#x2F;kubeadm&#x2F;kubelet</h3><p>所有节点安装Docker&#x2F;kubeadm&#x2F;kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>首先配置一下Docker的阿里yum源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name=Docker CE Edge - \$basearch</span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后yum方式安装docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># yum安装</span><br><span class="line">yum -y install docker-ce</span><br><span class="line"></span><br><span class="line"># 查看docker版本</span><br><span class="line">docker --version  </span><br><span class="line"></span><br><span class="line"># 启动docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>配置docker的镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后重启docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="添加kubernetes软件源"><a href="#添加kubernetes软件源" class="headerlink" title="添加kubernetes软件源"></a>添加kubernetes软件源</h3><p>然后我们还需要配置一下yum的k8s软件源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="安装kubeadm，kubelet和kubectl"><a href="#安装kubeadm，kubelet和kubectl" class="headerlink" title="安装kubeadm，kubelet和kubectl"></a>安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装kubelet、kubeadm、kubectl，同时指定版本</span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"># 设置开机启动</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><h3 id="部署Kubernetes-Master【master节点】"><a href="#部署Kubernetes-Master【master节点】" class="headerlink" title="部署Kubernetes Master【master节点】"></a>部署Kubernetes Master【master节点】</h3><p>在 192.168.177.130 执行，也就是master节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094302491.png" alt="image-20200929094302491"></p><p>当我们出现下面的情况时，表示kubernetes的镜像已经安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094620145.png" alt="image-20200929094620145"></p><p>使用kubectl工具 【master节点操作】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>执行完成后，我们使用下面命令，查看我们正在运行的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094933142.png" alt="2"></p><p>能够看到，目前有一个master节点已经运行了，但是还处于未准备状态</p><p>下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上</p><h3 id="加入Kubernetes-Node【Slave节点】"><a href="#加入Kubernetes-Node【Slave节点】" class="headerlink" title="加入Kubernetes Node【Slave节点】"></a>加入Kubernetes Node【Slave节点】</h3><p>下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点</p><p>执行在kubeadm init输出的kubeadm join命令：</p><blockquote><p>注意，以下的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</span><br></pre></td></tr></table></figure><p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><p>当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113165358663.png" alt="image-20201113165358663"></p><h3 id="部署CNI网络插件"><a href="#部署CNI网络插件" class="headerlink" title="部署CNI网络插件"></a>部署CNI网络插件</h3><p>上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载网络插件配置</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">##①首先下载v0.13.1-rc2-amd64 镜像</span><br><span class="line">##参考博客：https://www.cnblogs.com/pyxuexi/p/14288591.html</span><br><span class="line">##② 导入镜像，命令，，特别提示，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，重要的事情说3遍。不然抱错。如果没有操作，报错后，需要删除节点，重置，在导入镜像，重新加入才行。本地就是这样操作成功的！</span><br><span class="line">docker load &lt; flanneld-v0.13.1-rc2-amd64.docker</span><br><span class="line">#####下载本地，替换将image: quay.io/coreos/flannel:v0.13.1-rc2 替换为 image: quay.io/coreos/flannel:v0.13.1-rc2-amd64</span><br><span class="line"></span><br><span class="line"># 查看状态 【kube-system是k8s中的最小单元】</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure><p>运行后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113165929510.png" alt="image-20201113165929510"></p><p>运行完成后，我们查看状态可以发现，已经变成了Ready状态了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113194557147.png" alt="image-20201113194557147"></p><p>如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> master节点将该节点删除</span><br><span class="line"></span><br><span class="line">##20210223 yan 查阅资料添加###kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line"></span><br><span class="line">kubectl delete node k8snode1</span><br><span class="line"> </span><br><span class="line"># 然后到k8snode1节点进行重置</span><br><span class="line"> kubeadm reset</span><br><span class="line"># 重置完后在加入</span><br><span class="line">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</span><br></pre></td></tr></table></figure><h3 id="测试kubernetes集群"><a href="#测试kubernetes集群" class="headerlink" title="测试kubernetes集群"></a>测试kubernetes集群</h3><p>我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动</p><p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载nginx 【会联网拉取nginx镜像】</span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"># 查看状态</span><br><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p>如果我们出现Running状态的时候，表示已经成功运行了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113203537028.png" alt="image-20201113203537028"></p><p>下面我们就需要将端口暴露出去，让其它外界能够访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 暴露端口</span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line"># 查看一下对外的端口</span><br><span class="line">kubectl get pod,svc</span><br></pre></td></tr></table></figure><p>能够看到，我们已经成功暴露了 80端口 到 30529上</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113203840915.png" alt="image-20201113203840915"></p><p>我们到我们的宿主机浏览器上，访问如下地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.177.130:30529/</span><br></pre></td></tr></table></figure><p>发现我们的nginx已经成功启动了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113204056851.png" alt="image-20201113204056851"></p><p>到这里为止，我们就搭建了一个单master的k8s集群</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113204158884.png" alt="image-20201113204158884"></p><h3 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h3><h4 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h4><p>在执行Kubernetes init方法的时候，出现这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</span><br></pre></td></tr></table></figure><p>是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可</p><h4 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h4><p>我们在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR Swap]: running with swap on is not supported. Please disable swap</span><br></pre></td></tr></table></figure><p>错误原因是我们需要关闭swap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 关闭swap</span><br><span class="line"># 临时</span><br><span class="line">swapoff -a </span><br><span class="line"># 临时</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h4 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h4><p>在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused</span><br></pre></td></tr></table></figure><p>解决方法，首先需要到 master 节点，创建一个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件夹</span><br><span class="line">mkdir /etc/systemd/system/kubelet.service.d</span><br><span class="line"></span><br><span class="line"># 创建文件</span><br><span class="line">vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line"># 添加如下内容</span><br><span class="line">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;</span><br><span class="line"></span><br><span class="line"># 重置</span><br><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><p>然后删除刚刚创建的配置目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.kube</span><br></pre></td></tr></table></figure><p>然后 在master重新初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5</span><br></pre></td></tr></table></figure><p>添加完成后，我们使用下面命令，查看节点是否成功添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h4 id="错误四"><a href="#错误四" class="headerlink" title="错误四"></a>错误四</h4><p>我们再执行查看节点的时候， kubectl get nodes 会出现问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;)</span><br></pre></td></tr></table></figure><p>这是因为我们之前创建的配置文件还存在，也就是这些配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>我们需要做的就是把配置文件删除，然后重新执行一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.kube</span><br></pre></td></tr></table></figure><p>然后再次创建一下即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME&#x2F;.kube 给移除掉，再次创建时就会出现问题了</p><h4 id="错误五"><a href="#错误五" class="headerlink" title="错误五"></a>错误五</h4><p>安装的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Another app is currently holding the yum lock; waiting for it to exit...</span><br></pre></td></tr></table></figure><p>是因为yum上锁占用，解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><h4 id="错误六"><a href="#错误六" class="headerlink" title="错误六"></a>错误六</h4><p>在使用下面命令，添加node节点到集群上的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb  --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span><br></pre></td></tr></table></figure><p>然后出现了这个错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8smaster ~]# kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb     --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span><br><span class="line">W1117 06:55:11.220907   11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p>出于安全考虑，Linux系统<strong>默认是禁止数据包转发</strong>的。所谓<strong>转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包</strong>。这通常就是路由器所要实现的功能。也就是说 <strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</strong> 文件的值不支持转发</p><ul><li>0：禁止</li><li>1：转发</li></ul><p>所以我们需要将值修改成1即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>修改完成后，重新执行命令即可</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PART1-概念&quot;&gt;&lt;a href=&quot;#PART1-概念&quot; class=&quot;headerlink&quot; title=&quot;PART1 概念&quot;&gt;&lt;/a&gt;PART1 概念&lt;/h1&gt;&lt;h2 id=&quot;K8S概述和特性&quot;&gt;&lt;a href=&quot;#K8S概述和特性&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="k8s" scheme="https://lyotoc.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>JVM原理</title>
    <link href="https://lyotoc.github.io/2022/06/14/JVM%E5%8E%9F%E7%90%86/"/>
    <id>https://lyotoc.github.io/2022/06/14/JVM%E5%8E%9F%E7%90%86/</id>
    <published>2022-06-14T07:08:37.000Z</published>
    <updated>2022-07-15T01:51:20.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM原理"><a href="#JVM原理" class="headerlink" title="JVM原理"></a>JVM原理</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220715095030245.png" alt="image-20220715095030245"></p><h3 id="Java内存区域的分配"><a href="#Java内存区域的分配" class="headerlink" title="Java内存区域的分配"></a>Java内存区域的分配</h3><p>JVM虚拟机内存模型实现规范：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/JVM1.8.png"></p><p>按线程是否共享分为以下区域：</p><p>所有线程共享的数据区：</p><ul><li><p>方法区（JVM规范中的一部分，不是实际的实现）: 存储每一个类的结构信息（运行时常量池、静态变量、方法数据、构造函数和普通方法的字节码、JIT编译后的代码)，没有要求使用垃圾回收因为回收效率太低。（运行时常量池：存放编译器生成的各种字面量和符号引用，在类加载后放到运行时常量池中）</p></li><li><p>堆区: 最大的一块区域，是大部分类实例、对象、数组分配内存的区域，没有限制只能将对象分配在堆，所以出现逃逸分析的技术</p></li></ul><p>每个线程都会有一块私有的数据区： </p><ul><li><p>虚拟机栈: 虚拟机栈与线程同时创建，每个方法在执行时在其中创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法返回地址。正常调用完成后恢复调用者的局部变量表、操作数栈、递增程序计数器来跳过刚才执行的指令，或抛出异常不将返回值返回给调用者</p></li><li><p>本地方法栈: 功能与虚拟机栈相同，为native方法服务</p></li><li><p>pc寄存器: 任意时刻线程只会执行一个方法的代码，如果不是native的，就存放当前正在执行的字节码指令的地址，如果是native，则是undefined</p></li></ul><p>以HotSpot虚拟机实现为例，Java8中内存区域如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655346980098.jpg"></p><p>与规范中的区别：</p><ul><li><p>直接内存：非Java标准，是JVM以外的本地内存，在Java4出现的NIO中，为了防止Java堆和Native堆之间往复的数据复制带来的性能损耗，此后NIO可以使用Native的方式直接在Native堆分配内存。JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。</p></li><li><p>元数据区（方法区的实现）：Java7以及之前是使用的永久代来实现方法区，大小是在启动时固定的。Java8中用元空间替代了永久代，元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性。元空间存储JIT即时编译后的native代码，可能还存在短指针数据区CCS</p></li><li><p>堆区: Java7之后运行时常量池从方法区移到这里，为Java8移除永久带的做好准备</p></li></ul><h3 id="Java对象不都是分配在堆上"><a href="#Java对象不都是分配在堆上" class="headerlink" title="Java对象不都是分配在堆上"></a>Java对象不都是分配在堆上</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸是指在某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收。由于其被其它变量引用，由于无法回收，即称为逃逸。</p><p>逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁。</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><ul><li><p>加载（获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象）</p></li><li><p>验证（验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全）</p></li><li><p>准备（为类变量分配内存并设置初始值）</p></li><li><p>解析（将常量池的符号引用替换为直接引用，符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针）</p></li><li><p>初始化（执行类构造器、类变量赋值、静态语句块）</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>启动类加载器：用C++语言实现，是虚拟机自身的一部分，它负责将 <JAVA_HOME>&#x2F;lib路径下的核心类库，无法被Java程序直接引用<br>扩展类加载器：用Java语言实现，它负责加载<JAVA_HOME>&#x2F;lib&#x2F;ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用<br>系统类加载器：用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用</p><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>定义：如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是<strong>双亲委派模式</strong>。</p><p>优点：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次防止恶意覆盖Java核心API。</p><p>三次大型破坏双亲委派模式的事件：</p><ul><li><p>在双亲委派模式出来之前，用户继承ClassLoader就是为了重写loadClass方法，但双亲委派模式需要这个方法，所以1.2之后添加了findClass供以后的用户重写</p></li><li><p>如果基础类要调回用户的代码，如JNDI&#x2F;JDBC需要调用ClassPath下的自己的代码来进行资源管理，Java团队添加了一个线程上下文加载器，如果该加载器没有被设置过，那么就默认是应用程序类加载器</p></li><li><p>为了实现代码热替换，OSGi是为了实现自己的类加载逻辑，用平级查找的逻辑替换掉了向下传递的逻辑。但其实可以不破坏双亲委派逻辑而是自定义类加载器来达到代码热替换。比如<a href="https://www.cnblogs.com/pfxiong/p/4070462.html">这篇文章</a></p></li></ul><h3 id="内存分配（堆上的内存分配）"><a href="#内存分配（堆上的内存分配）" class="headerlink" title="内存分配（堆上的内存分配）"></a>内存分配（堆上的内存分配）</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655346667997.jpg"></p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><h5 id="进入条件"><a href="#进入条件" class="headerlink" title="进入条件"></a>进入条件</h5><p>优先选择在新生代的Eden区被分配。</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h5 id="进入条件-1"><a href="#进入条件-1" class="headerlink" title="进入条件"></a>进入条件</h5><ul><li><p>大对象，-XX:PretenureSizeThreshold 大于这个参数的对象直接在老年代分配，来避免新生代GC以及分配担保机制和Eden与Survivor之间的复制</p></li><li><p>经过第一次Minor GC仍然存在，能被Survivor容纳，就会被移动到Survivor中，此时年龄为1，当年龄大于预设值就进入老年代  </p></li><li><p>如果Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象进入老年代  </p></li><li><p>如果Survivor空间无法容纳新生代中Minor GC之后还存活的对象</p></li></ul><h3 id="GC回收机制"><a href="#GC回收机制" class="headerlink" title="GC回收机制"></a>GC回收机制</h3><h4 id="回收对象"><a href="#回收对象" class="headerlink" title="回收对象"></a>回收对象</h4><p>不可达对象：通过一系列的GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时则此对象是不可用的。<br>GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。</p><p>彻底死亡条件：<br>条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。<br>条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。</p><h4 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h4><p>新生代因为每次GC都有大批对象死去，只需要付出少量存活对象的复制成本且无碎片所以使用“复制算法”<br>老年代因为存活率高、没有分配担保空间，所以使用“标记-清理”或者“标记-整理”算法</p><p>复制算法：将可用内存按容量划分为Eden、from survivor、to survivor，分配的时候使用Eden和一个survivor，Minor GC后将存活的对象复制到另一个survivor，然后将原来已使用的内存一次清理掉。这样没有内存碎片。<br>标记-清除：首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象。会产生大量碎片，导致无法分配大对象从而导致频繁GC。<br>标记-整理：首先标记出所有需要回收的对象，让所有存活的对象向一端移动。</p><h4 id="Minor-GC条件"><a href="#Minor-GC条件" class="headerlink" title="Minor GC条件"></a>Minor GC条件</h4><p>当Eden区空间不足以继续分配对象，发起Minor GC。</p><h4 id="Full-GC条件"><a href="#Full-GC条件" class="headerlink" title="Full GC条件"></a>Full GC条件</h4><ul><li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行</p></li><li><p>老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）</p></li><li><p>方法区空间不足</p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>串行收集器Serial是最古老的收集器，只使用一个线程去回收，可能会产生较长的停顿</p><p>新生代使用Serial收集器<code>复制</code>算法、老年代使用Serial Old<code>标记-整理</code>算法</p><p>参数：<code>-XX:+UseSerialGC</code>，默认开启<code>-XX:+UseSerialOldGC</code></p><h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><p>并行收集器Parallel关注<strong>可控的吞吐量</strong>，能精确地控制吞吐量与最大停顿时间是该收集器最大的特点，也是1.8的Server模式的默认收集器，使用多线程收集。ParNew垃圾收集器是Serial收集器的多线程版本。</p><p>新生代<code>复制</code>算法、老年代<code>标记-整理</code>算法</p><p>参数：<code>-XX:+UseParallelGC</code>，默认开启<code>-XX:+UseParallelOldGC</code></p><h3 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h3><p>并发收集器CMS是以<strong>最短停顿时间</strong>为目标的收集器。G1关注能在大内存的前提下精确控制<strong>停顿时间</strong>且垃圾回收效率高。</p><p>CMS针对老年代，有初始标记、并发标记、重新标记、并发清除四个过程，标记阶段会Stop The World，使用<code>标记-清除</code>算法，所以会产生内存碎片。</p><p>参数：<code>-XX:+UseConcMarkSweepGC</code>，默认开启<code>-XX:+UseParNewGC</code></p><p>G1将堆划分为多个大小固定的独立区域，根据每次允许的收集时间优先回收垃圾最多的区域，使用<code>标记-整理</code>算法，是1.9的Server模式的默认收集器</p><p>参数：<code>-XX:+UseG1GC</code></p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互</p><p>STW总会发生，不管是新生代还是老年代，比如CMS在初始标记和重复标记阶段会停顿，G1在初始标记阶段也会停顿，所以并不是选择了一款停顿时间低的垃圾收集器就可以避免STW的，我们只能尽量去减少STW的时间。</p><p>那么为什么一定要STW？因为在定位堆中的对象时JVM会记录下对所有对象的引用，如果在定位对象过程中，有新的对象被分配或者刚记录下的对象突然变得无法访问，就会导致一些问题，比如部分对象无法被回收，更严重的是如果GC期间分配的一个GC Root对象引用了准备被回收的对象，那么该对象就会被错误地回收。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a><a href="https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ">Java内存模型</a></h2><p>定义：JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性</p><p>实现：volatile、synchronized、final、concurrent包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字</p><p>主内存：所有变量都保存在主内存中<br>工作内存：每个线程的独立内存，保存了该线程使用到的变量的主内存副本拷贝，线程对变量的操作必须在工作内存中进行</p><p>每个线程都有自己的本地内存共享副本，如果A线程要更新主内存还要让B线程获取更新后的变量，那么需要：</p><ul><li><p>将本地内存A中更新共享变量</p></li><li><p>将更新的共享变量刷新到主内存中</p></li><li><p>线程B从主内存更新最新的共享变量</p></li></ul><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a><a href="https://www.cnblogs.com/chenssy/p/6393321.html">happens-before</a></h2><p>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before。特别关注在多线程之间的内存可见性。</p><p>它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。</p><ul><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p></li><li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</p></li><li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p></li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>前提：在进行GC优化之前，需要确认项目的架构和代码等已经没有优化空间</p><p>目的：优化JVM垃圾收集性能从而增大吞吐量或减少停顿时间，让应用在某个业务场景上发挥最大的价值。吞吐量是指应用程序线程用时占程序总用时的比例。暂停时间是应用程序线程让与GC线程执行而完全暂停的时间段</p><p>对于交互性web应用来说，一般都是减少停顿时间，所以有以下方法：</p><ul><li><p>如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大</p></li><li><p>让大对象进入年老代。可以使用参数-XX:PetenureSizeThreshold 设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配</p></li><li><p>设置对象进入年老代的年龄。如果对象每经过一次 GC 依然存活，则年龄再加 1。当对象年龄达到阈值时，就移入年老代，成为老年对象</p></li><li><p>使用关注系统停顿的 CMS 回收器</p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM原理&quot;&gt;&lt;a href=&quot;#JVM原理&quot; class=&quot;headerlink&quot; title=&quot;JVM原理&quot;&gt;&lt;/a&gt;JVM原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer</title>
    <link href="https://lyotoc.github.io/2022/06/07/%E5%89%91%E6%8C%87Offer/"/>
    <id>https://lyotoc.github.io/2022/06/07/%E5%89%91%E6%8C%87Offer/</id>
    <published>2022-06-07T07:08:37.000Z</published>
    <updated>2022-06-30T02:40:27.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h3><p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/"><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></a></p><blockquote><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><p>方法一：新建一个数组并利用index记录每个元素出现的次数，大于1则返回该数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">     <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">         arr[num]++;</span><br><span class="line">         <span class="keyword">if</span>(arr[num] &gt; <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用散列表的特征，hashset.add()元素重复时返回fasle,此时返回该元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></p><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。</p><p>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p></blockquote><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] nums : matrix) &#123;</span><br><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(nums, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：获得当前下标位置的元素 num<br>如果 num 和 target 相等，返回 true<br>如果 num 大于 target，列下标减 1<br>如果 num 小于 target，行下标加 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, column = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> matrix[row][column];</span><br><span class="line">            <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                column--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h3><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p><blockquote><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> a : s.toCharArray())&#123;</span><br><span class="line">           <span class="keyword">if</span>(a == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">               sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               sb.append(a);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></p><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"> 输入：head = [1,3,2]</span><br><span class="line"> 输出：[2,3,1]</span><br></pre></td></tr></table></figure></blockquote><p>方法一：递归回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[--size];</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="type">int</span>[] nums = reversePrint(head.next);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - size--;</span><br><span class="line">        nums[index] = head.val;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用栈的特性输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line"><span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h3><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></p><p><strong>方法一</strong></p><script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script> <video id="video" controls loop="false" width="100%"></video> <script>   var video = document.getElementById('video');   if(Hls.isSupported()) {   var hls = new Hls();   hls.loadSource('https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/2022_06_0812_37_16/index.m3u8');   hls.attachMedia(video);   hls.on(Hls.Events.MANIFEST_PARSED,function() {   video.pause(); }); } else if (video.canPlayType('application/vnd.apple.mpegurl')) {   video.src = 'https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/2022_06_0812_37_16/index.m3u8';   video.addEventListener('loadedmetadata',function() {   video.pause(); }); } </script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; inOrderindexMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        inOrderindexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            inOrderindexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, </span></span><br><span class="line"><span class="params">                                    <span class="type">int</span>[] inorder, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preorder[preLeft];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> inOrderindexMap.get(rootValue);</span><br><span class="line"></span><br><span class="line">        root.left = buildTree(preorder, preLeft + <span class="number">1</span>, preLeft + pIndex - inLeft, inorder, inLeft, pIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, preLeft + pIndex - inLeft + <span class="number">1</span>, preRight, inorder, pIndex + <span class="number">1</span>, inRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>这道题是一道典型的递归解法的算法题，我们可以：</p><blockquote><p>先按照前序遍历和中序遍历的特点，来模拟重建二叉树<br>在模拟的过程中，看看是否符合递归的三个特点：</p><ol><li>这个问题能不能拆分成若干个子问题，子问题解决了，那么这个问题就解决了</li><li>所有子问题的求解方法是不是和大问题的求解方法是一样的</li><li>是不是存在知道结果的最小子问题</li></ol><p>在符合上面的递归特点后，我们就专门看一个子问题的解法，根据一个子问题的解法 来实现递归的代码</p></blockquote><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h3><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></p><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inStack ;</span><br><span class="line">    Stack&lt;Integer&gt; outStack ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="built_in">this</span>.outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">     inStack.push(value);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">if</span>(inStack.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          in2Out();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in2Out</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用两个栈实现入列及出列，分别对两个栈做不同分工。</p></blockquote><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h3><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></p><blockquote><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一 动态规划</strong></p><blockquote><p>斐波那契数的边界条件是 F(0)&#x3D;0F(0)&#x3D;0F(0)&#x3D;0 和 F(1)&#x3D;1F(1)&#x3D;1F(1)&#x3D;1。当 n&gt;1n&gt;1n&gt;1 时，每一项的和都等于前两项的和，因此有如下递推关系：</p><p>F(n)&#x3D;F(n−1)+F(n−2)F(n)&#x3D;F(n-1)+F(n-2) F(n)&#x3D;F(n−1)+F(n−2)</p><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0)F(0)F(0) 和 F(1)F(1)F(1)。</p><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)O(n)O(n) 的实现。由于 F(n)F(n)F(n) 只和 F(n−1)F(n-1)F(n−1) 与 F(n−2)F(n-2)F(n−2) 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 O(1)O(1)O(1)。如下的代码中给出的就是这种实现。</p><p>计算过程中，答案需要取模 1e9+7。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/10_I_fig1.gif" alt="实现思想"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = (p + q) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：矩阵快速幂</strong></p><p>方法一的时间复杂度是 O(n)O(n)O(n)。使用矩阵快速幂的方法可以降低时间复杂度。</p><p>首先我们可以构建这样一个递推关系：<br>$$<br>\begin{bmatrix}1&amp;1\\1&amp;0 \end{bmatrix}​\begin{bmatrix}F(n)\\F(n−1) \end{bmatrix}​&#x3D;\begin{bmatrix}F(n)+F(n−1)\\F(n)\end{bmatrix}&#x3D;\begin{bmatrix}F(n+1)\\F(n)\end{bmatrix}​<br>$$<br>因此：<br>$$<br>\begin{bmatrix}F(n+1)\\F(n)\end{bmatrix} &#x3D; \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^n &#x3D; \begin{bmatrix} F(1)\\F(0)\end{bmatrix}<br>$$<br>令：<br>$$<br>M&#x3D;\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}<br>$$<br>因此只要我们能快速计算矩阵 M 的 n 次幂，就可以得到 F(n) 的值。如果直接求取<code>M^n</code>，时间复杂度是 O(n)，可以定义矩阵乘法，然后用快速幂算法来加速这里 <code>M^n</code> 的求取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span>[][] res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] pow(<span class="type">int</span>[][] a, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] multiply(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = (<span class="type">int</span>) (((<span class="type">long</span>) a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + (<span class="type">long</span>) a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]) % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h3><p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p><code>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一 动态规划</strong></p><blockquote><p>该题和上题一致，属于是斐波那契数列的变种。不过起始值是从1开始的</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/108249e4d62d429f9cd6cab5bbd6afca581ee61c7d762a4c8ea0c62e08e10762-Picture13.png" alt="青蛙跳台阶"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % mod;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;剑指-Offer-03-数组中重复的数字&quot;&gt;&lt;a href=&quot;#剑指-Offer-03-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 03. 数组中重复的数字&quot;&gt;&lt;/a&gt;剑指 Offer 03. 数组中重复的数字&lt;/h3</summary>
      
    
    
    
    <category term="面试" scheme="https://lyotoc.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="算法" scheme="https://lyotoc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git的用法</title>
    <link href="https://lyotoc.github.io/2022/06/02/git%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://lyotoc.github.io/2022/06/02/git%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-06-02T06:38:21.000Z</published>
    <updated>2022-06-02T06:38:58.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git的用法"><a href="#Git的用法" class="headerlink" title="Git的用法"></a>Git的用法</h2><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><h4 id="仓库创建"><a href="#仓库创建" class="headerlink" title="仓库创建"></a>仓库创建</h4><p>​      打开需创路径，<code>mkdir &lt;file name&gt;</code>创建文件夹<br>​      <code>pwd</code> 查看目前所在路径<br>​      <code>git init </code>使用当前路径作为仓库的master</p><h4 id="提交-amp-查看"><a href="#提交-amp-查看" class="headerlink" title="提交&amp;查看"></a>提交&amp;查看</h4><p>​      <code>git add &lt;file name&gt;</code> 添加至暂存区<br>​      <code>git commit -m &quot;描述&quot;</code> 提交至版本库<br>​      <code>git status</code>查看暂存区状态<br>​     <code> git diff</code> 比对工作区与暂存区的文件修改处在哪<br>​      <code>git log</code> 查看版本库修改日志</p><h4 id="版本回退-amp-退回"><a href="#版本回退-amp-退回" class="headerlink" title="版本回退&amp;退回"></a>版本回退&amp;退回</h4><p>​      <code>git reset --hard ^HEAD</code> 退回上一版本<br>​      <code>git reset --hard ~num</code> 退回前num版本（num&#x3D;前~版本）<br>​      <code>git reset --hard &lt;版本号&gt;</code>回退到该版本<br>​      <code>git rflog</code> 提交版本库的日志</p><h4 id="工作区-amp-暂存区修改撤销及删除"><a href="#工作区-amp-暂存区修改撤销及删除" class="headerlink" title="工作区&amp;暂存区修改撤销及删除"></a>工作区&amp;暂存区修改撤销及删除</h4><p>​      <code>git checkout --&lt;file name&gt; </code>撤回工作区修改<br>​      <code>git reset HEAD&lt;file name &gt; </code>撤销暂存区修改，退回至工作区<br>​     <code> git restore &lt;file name &gt;</code> 撤销修改<br>​      <code>rm &lt;file name&gt;</code>删除文件 记得提交</p><h3 id="远程版本库的创建-amp-克隆"><a href="#远程版本库的创建-amp-克隆" class="headerlink" title="远程版本库的创建&amp;克隆"></a>远程版本库的创建&amp;克隆</h3><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><h5 id="首次连接远程库准备"><a href="#首次连接远程库准备" class="headerlink" title="首次连接远程库准备"></a>首次连接远程库准备</h5><p>​        创建 SSH key<br>​          <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><br>​        <code>add sshkey</code><br>​          用户主目录里找到.ssh目录，在Github SSHkey页面粘贴id_rsa.pub内容<br>​        该过程在github中进行</p><h5 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h5><p>​        在<code>github</code>新建一个仓库<br>​        本地<code>bash</code>使用<code>command：git remote add origin https://github.com/username/repositories.git </code></p><blockquote><p>username为用户的github用户名，repositories为新建的仓库名称 </p></blockquote><h5 id="本地库推送至远程库"><a href="#本地库推送至远程库" class="headerlink" title="本地库推送至远程库"></a>本地库推送至远程库</h5><p>​        首次推送：<code>git push -u origin master</code>(master会把本地库的master分支与远程库中的master分支关联在一起)<br>​        以后推送：<code>git push origin</code></p><h5 id="远程库的克隆"><a href="#远程库的克隆" class="headerlink" title="远程库的克隆"></a>远程库的克隆</h5><h6 id="克隆远端库"><a href="#克隆远端库" class="headerlink" title="克隆远端库"></a>克隆远端库</h6><p>​          <code>git clone git@httpadress.git  </code><em>使用http协议多</em><br>​          <strong>有几种git的clone方式，ssh最快</strong></p><p>​ <strong>远程仓库的版本回退</strong></p><p><code>git checkout &lt;commitID&gt;</code></p><h5 id="私人服务器远程仓库"><a href="#私人服务器远程仓库" class="headerlink" title="私人服务器远程仓库"></a>私人服务器远程仓库</h5><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git的用法&quot;&gt;&lt;a href=&quot;#Git的用法&quot; class=&quot;headerlink&quot; title=&quot;Git的用法&quot;&gt;&lt;/a&gt;Git的用法&lt;/h2&gt;&lt;h3 id=&quot;本地仓库&quot;&gt;&lt;a href=&quot;#本地仓库&quot; class=&quot;headerlink&quot; title=&quot;本</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="git" scheme="https://lyotoc.github.io/tags/git/"/>
    
    <category term="工具" scheme="https://lyotoc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>SSM整合</title>
    <link href="https://lyotoc.github.io/2022/06/02/SSM%E6%95%B4%E5%90%88/"/>
    <id>https://lyotoc.github.io/2022/06/02/SSM%E6%95%B4%E5%90%88/</id>
    <published>2022-06-02T06:30:12.000Z</published>
    <updated>2022-06-02T06:36:04.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring中各个jar包的用途和他们之间的关系"><a href="#spring中各个jar包的用途和他们之间的关系" class="headerlink" title="spring中各个jar包的用途和他们之间的关系"></a>spring中各个jar包的用途和他们之间的关系</h1><p> 除了spring.jar文件，Spring还包括有其它13个独立的jar包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar包，而不必引入整个spring.jar的所有类文件。</p><p>(1) spring-core.jar</p><p>这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。</p><p>(2) spring-beans.jar</p><p>这个jar文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control &#x2F; Dependency Injection（IoC&#x2F;DI）操作相关的所有类。如果应用只需基本的IoC&#x2F;DI支持，引入spring-core.jar及spring-beans.jar文件就可以了。</p><p>(3) spring-aop.jar</p><p>这个jar文件包含在应用中使用Spring的AOP特性时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。</p><p>(4) spring-context.jar</p><p>　　这个jar文件为Spring核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如Velocity、FreeMarker、JasperReports集成的类，以及校验Validation方面的相关类。</p><p>(5) spring-dao.jar</p><p>　　这个jar文件包含Spring DAO、Spring Transaction进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。</p><p>(6) spring-hibernate.jar</p><p>　　这个jar文件包含Spring对Hibernate 2及Hibernate 3进行封装的所有类。</p><p>(7) spring-jdbc.jar</p><p>　　这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。</p><p>(8) spring-orm.jar</p><p>　　这个jar文件包含Spring对DAO特性集进行了扩展，使其支持 iBATIS、JDO、OJB、TopLink，因为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包。</p><p>(9) spring-remoting.jar</p><p>　　这个jar文件包含支持EJB、JMS、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。</p><p>(10) spring-support.jar</p><p>　　这个jar文件包含支持缓存Cache（ehcache）、JCA、JMX、邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类。</p><p>(11) spring-web.jar</p><p>　　这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。</p><p>(12) spring-webmvc.jar</p><p>　　这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。</p><p>(13) spring-mock.jar</p><p>　　这个jar文件包含Spring一整套mock类来辅助应用的测试。Spring测试套件使用了其中大量mock类，这样测试就更加简单。模拟HttpServletRequest和HttpServletResponse类在Web应用单元测试是很方便的。</p><p>如何选择这些发布包，决定选用哪些发布包其实相当简单。</p><p> 如果你正在构建Web应用并将全程使用Spring，那么最好就使用单个全部的spring.jar文件；</p><p> 如果你的应用仅仅用到简单的Inversion of Control &#x2F; Dependency Injection（IoC&#x2F;DI）容器，那么只需spring-core.jar与spring-beans.jar即可；</p><p> 如果你对发布的大小要求很高，那么就得精挑细选了，只取包含自己所需特性的jar文件了。</p><p>采用独立的发布包你可以避免包含自己的应用不需要的全部类。当然你可以采用其它的一些工具来设法令整个应用包变小，节省空间的重点在于准确地找出自己所需的Spring依赖类，然后合并所需的类与包就可以了。</p><p> Eclispe有个插件叫ClassPath Helper可以帮你找找所依赖的类。</p><p>Spring包依赖说明:</p><ol><li><p>spring-core.jar需commons-collections.jar，spring-core.jar是以下其它各个的基本。</p></li><li><p>spring-beans.jar需spring-core.jar，cglib-nodep-2.1_3.jar</p></li><li><p>spring-aop.jar需spring-core.jar，spring-beans.jar，cglib-nodep-2.1_3.jar，aopalliance.jar</p></li><li><p>spring-context.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，commons-collections.jar，aopalliance.jar</p></li><li><p>spring-dao.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-context.jar</p></li><li><p>spring-jdbc.jar需spring-core.jar，spring-beans.jar，spring-dao.jar</p></li><li><p>spring-web.jar需spring-core.jar，spring-beans.jar，spring-context.jar</p></li><li><p>spring-webmvc.jar需spring-core.jar&#x2F;spring-beans.jar&#x2F;spring-context.jar&#x2F;spring-web.jar</p></li><li><p>spring-hibernate.jar需spring-core.jar，spring- beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring- orm.jar，spring-web.jar，spring-webmvc.jar</p></li><li><p>spring-orm.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring-web.jar，spring-webmvc.jar</p></li><li><p>spring-remoting.jar需spring-core.jar，spring-beans.jar，spring- aop.jar，spring-dao.jar，spring-context.jar，spring-web.jar，spring- webmvc.jar</p></li><li><p>spring-support.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar</p></li><li><p>spring-mock.jar需spring-core.jar，spring-beans.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar</p></li></ol><h4 id="主流连接池"><a href="#主流连接池" class="headerlink" title="主流连接池"></a>主流连接池</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20210221090446427.png" alt="image-20210221090446427"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20210221090510773.png" alt="image-20210221090510773"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring中各个jar包的用途和他们之间的关系&quot;&gt;&lt;a href=&quot;#spring中各个jar包的用途和他们之间的关系&quot; class=&quot;headerlink&quot; title=&quot;spring中各个jar包的用途和他们之间的关系&quot;&gt;&lt;/a&gt;spring中各个jar包的</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Spring" scheme="https://lyotoc.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC注解及其它</title>
    <link href="https://lyotoc.github.io/2022/06/02/SpringMVC%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%AE%83/"/>
    <id>https://lyotoc.github.io/2022/06/02/SpringMVC%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%AE%83/</id>
    <published>2022-06-02T06:29:20.000Z</published>
    <updated>2022-06-02T06:29:47.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC注解及其他"><a href="#SpringMVC注解及其他" class="headerlink" title="SpringMVC注解及其他"></a>SpringMVC注解及其他</h2><h5 id="Controller注解的实现"><a href="#Controller注解的实现" class="headerlink" title="@Controller注解的实现"></a><code>@Controller</code>注解的实现</h5><blockquote><p> Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现该接口的类获得控制器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">   <span class="comment">//处理请求且返回一个模型与视图对象</span></span><br><span class="line">   ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h4><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><h4 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h4><p><strong>概念</strong></p><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>功能</strong></p><p>资源：互联网所有的事物都可以被抽象为资源</p><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p><p>分别对应 添加、 删除、修改、查询。</p><p><strong>传统方式操作资源</strong>  ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p><p>​<a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p><p>​<a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p><p>​<a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p><p>​<a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p><p><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p><p>​<a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p><p>​<a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p><p>​<a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p><p>​<a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestFulController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//映射访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> p1, <span class="meta">@PathVariable</span> <span class="type">int</span> p2, Model model)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> p1+p2;</span><br><span class="line">        <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果：&quot;</span>+result);</span><br><span class="line">        <span class="comment">//返回视图位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用method属性指定请求类型</strong></p><p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p><p><a href="https://mp.weixin.qq.com/s/1d_PAk2IIp-WWX2eBbU3a">数据处理及跳转 </a></p><h4 id="post提交数据再返回乱码问题"><a href="#post提交数据再返回乱码问题" class="headerlink" title="post提交数据再返回乱码问题"></a>post提交数据再返回乱码问题</h4><p><strong>可以自定义编码过滤器</strong></p><p>编写Filter类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter</span> <span class="keyword">implements</span> <span class="title class_">javax</span>.servlet.Filter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        servletResponse.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);<span class="comment">//继续传递数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在web.xml文件中注册并配置映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.coder.Filter.Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SpringMVC提供的编码过滤器</strong></p><p>在web.xml中配置即可（修改了xml文件需要重启服务器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p><p>处理方法 :</p><p>1、修改tomcat配置文件 ：设置编码！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">           connectionTimeout=&quot;20000&quot;</span><br><span class="line">           redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>2、自定义过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//处理response的字符编码</span></span><br><span class="line">        HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">        myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 对request包装增强</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">myrequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequest</span>(httpServletRequest);</span><br><span class="line">        chain.doFilter(myrequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="comment">//是否编码的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> hasEncode;</span><br><span class="line">    <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">getParameterMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先获得请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// post请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理post乱码</span></span><br><span class="line">                request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// get请求</span></span><br><span class="line">            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">                <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                    String[] values = parameterMap.get(parameterName);</span><br><span class="line">                    <span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 处理get乱码</span></span><br><span class="line">                                values[i] = <span class="keyword">new</span> <span class="title class_">String</span>(values[i]</span><br><span class="line">                                        .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hasEncode = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取一个值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取所有值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展：小黄鸭调试法"><a href="#扩展：小黄鸭调试法" class="headerlink" title="扩展：小黄鸭调试法"></a>扩展：小黄鸭调试法</h3><p>场景一：<em>我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。</em></p><p>场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。</p><p>其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JOmNdhqNbrRK9XaseXIDsu4MibRVpZicicSVRRjb0lAblXjlHHppY3gSBn8iaTsa2oLEMO9S3bPCDHoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringMVC注解及其他&quot;&gt;&lt;a href=&quot;#SpringMVC注解及其他&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC注解及其他&quot;&gt;&lt;/a&gt;SpringMVC注解及其他&lt;/h2&gt;&lt;h5 id=&quot;Controller注解的实现&quot;&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Spring" scheme="https://lyotoc.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC原理</title>
    <link href="https://lyotoc.github.io/2022/06/02/SpringMVC%E5%8E%9F%E7%90%86/"/>
    <id>https://lyotoc.github.io/2022/06/02/SpringMVC%E5%8E%9F%E7%90%86/</id>
    <published>2022-06-02T06:28:03.000Z</published>
    <updated>2022-06-02T06:28:50.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring-MVC"></a>Spring-MVC</h1><blockquote><p><code>MVC</code>即是**模型(Model)<strong>、</strong>视图(View)<strong>、</strong>控制器(Controller)**的简写，是一种软件设计规范。</p></blockquote><p>之前最典型的就是JSP+servlet+javabean的模式</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIXW7Wmm9KVEV1FXUfJMD0KzuYZ7ic5UHggsZDAzyYyrd4pLvnBIVM5zA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="MVC闭环"></p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>用pom项目依赖导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Springmvc json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>建立一个Moudle</strong></p><p>​PS：Project中创建modle项目可以删除<strong>scr</strong>并重建<code>moudle</code>，选择可以原生的Maven项目生成取消勾选<code>Create from archetype</code>,创建一个原生的Java普通项目，创建后看架构有无问题，再右键该<code>moudle</code>选择<code>add framwork support  </code> 选择 web工程即可，之后再右键该<code>moudle</code>–&gt;<code>open moudle setting</code> –&gt;<code>artifacts</code>在<code>WEB-INF</code>下创建<code>lib</code>目录并将依赖的jar包全部导入。</p><p><strong>编写一个Servlet类，用来处理用户的请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Controller;</span><br><span class="line"><span class="comment">//实现Servlet接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//取得参数</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (method.equals(<span class="string">&quot;add&quot;</span>))&#123;</span><br><span class="line">           req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了add方法&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">if</span> (method.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">           req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了delete方法&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//业务逻辑</span></span><br><span class="line">       <span class="comment">//视图跳转</span></span><br><span class="line">       req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/hello.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       doGet(req,resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>在web.xml中注册Servlet</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.coder.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置Tomcat，并启动</strong></p><p>在IDEA中，点击<code>run</code>选择<code>Edit configurations</code>添加Tomcat并添加项目部署包</p><ul><li>localhost:8080&#x2F;user?method&#x3D;add</li><li>localhost:8080&#x2F;user?method&#x3D;delete</li></ul><p><strong>MVC框架要做哪些事情</strong></p><ol><li>将url映射到java类或java类的方法 .</li><li>封装用户提交的数据 .</li><li>处理请求–调用相关的业务处理–封装响应数据 .</li><li>将响应的数据进行渲染 . jsp &#x2F; html 等表示层数据 .</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIRQkoR3WJaVZzicPAx3NumuY40RXSQOPzIbEicYsT0ySCPQ8cvQc2ic1Aw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><ul><li><p>它减轻了开发人员的工作负担，使得开发人员可以专注于业务逻辑层。</p><p><a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web">官方文档</a></p></li></ul><p><strong>Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。</strong></p><p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p><p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjI7ENu0jNibPiaiaiaBhyx6o9UUyU82Mddg4DjwzniaczmTLRbAtI9pKJq1tQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><p><strong>SpringMVC的原理如下图所示：</strong></p><p>​当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIaosVziclWLEJQkzobxHrpHcmtu2yTeVWPmEI4Yq5PaicS52VaJt8dYfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><h3 id="SpringMVC执行原理"><a href="#SpringMVC执行原理" class="headerlink" title="SpringMVC执行原理"></a>SpringMVC执行原理</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIbmPOkY8TxF6qvGAGXxC7dArYcr8uJlWoVC4aF4bfxgCGCD8sHg8mgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p><p><strong>简要分析执行流程</strong></p><ol><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p><p>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p><p><strong>如上url拆分成三部分：</strong></p><p><a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></p><p>SpringMVC部署在服务器上的web站点</p><p>hello表示控制器</p><p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p></li><li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p></li><li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p></li><li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p></li><li><p>Handler让具体的Controller执行。</p></li><li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p></li><li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p></li><li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p></li><li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p></li><li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p></li><li><p>最终视图呈现给用户。</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-MVC&quot;&gt;&lt;a href=&quot;#Spring-MVC&quot; class=&quot;headerlink&quot; title=&quot;Spring-MVC&quot;&gt;&lt;/a&gt;Spring-MVC&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;MVC&lt;/code&gt;即是**模型(Mo</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Spring" scheme="https://lyotoc.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC的配置</title>
    <link href="https://lyotoc.github.io/2022/06/02/SpringMVC%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://lyotoc.github.io/2022/06/02/SpringMVC%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2022-06-02T06:26:23.000Z</published>
    <updated>2022-06-02T06:27:14.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC的配置"><a href="#SpringMVC的配置" class="headerlink" title="SpringMVC的配置"></a>SpringMVC的配置</h2><p>在web.xml中注册<code>DispactherServlet</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--DispactherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">Servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Servlet-class</span>&gt;</span>org.springframework.web.servlet.DispachterServlet<span class="tag">&lt;/<span class="name">Servlet-class</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--关联一个springmvc的配置文件:servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数字越低启动级别越高--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--匹配映射路径（/为匹配所有路径）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">web-app</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&#x2F; 和 &#x2F;* 的区别：</strong>&lt; url-pattern &gt; &#x2F; &lt;&#x2F; url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp  不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; &#x2F;* &lt;&#x2F;  url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet  类，导致找不到对应的controller所以报404错。</p><ul><li><p>注意web.xml版本问题，要最新版！</p></li><li><p>注册DispatcherServlet</p></li><li><p>关联SpringMVC的配置文件</p></li><li><p>启动级别为1</p></li><li><p>映射路径为 &#x2F; 【不要用&#x2F;*，会404】</p></li></ul><p>**编写SpringMVC 的 配置文件！名称：servlet.xml **</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加处理映射器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加处理适配器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span>,<span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span>,<span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        return new ModelAndView(&quot;hello&quot;).addObject(&quot;msg&quot;,&quot;helloSpringMVC!&quot;);</span></span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">            mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello!Spring-MVC&quot;</span>);</span><br><span class="line">            mv.setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> mv;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在springmvc的配置文件中将自己的类交给SpringIOC容器，注册bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.coder.Controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>编写前端界面，显示ModelAndView中存放的数据</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: MR.L</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">2</span>/<span class="number">13</span></span><br><span class="line">  Time: <span class="number">20</span>:<span class="number">19</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;SpirngMVC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;&lt;--这是配置版&lt;br/&gt;</span><br><span class="line">$&#123;id&#125;&lt;--这是注解版</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p><ol><li>查看控制台输出，看一下是不是缺少了什么jar包。</li><li>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！</li><li>重启Tomcat 即可解决！</li></ol><p><strong>开发中用的方法—-注解版</strong></p><h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><p><strong>Spring MVC配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描bean给SpringIOC容器处理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.coder.Controller&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   支持mvc注解驱动</span></span><br><span class="line"><span class="comment">       在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">       要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">       必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">       和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">       这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">       而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    视图解析器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</p><ul><li>让IOC的注解生效</li><li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..</li><li>MVC的注解驱动</li><li>配置视图解析器</li></ul><p><strong>创建Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.coder.Dao.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/Atest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jsp/helo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ModelAttribute(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">userTs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Login</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jsp/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login/&#123;id&#125;&quot;,method = &#123;RequestMethod.POST&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Logined</span> <span class="params">(<span class="meta">@PathVariable</span> String id, User user,Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jsp/userLogin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建视图层</strong></p><p>在WEB-INF&#x2F; jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；</p><p>可以通过EL表示取出Model中存放的值，或者对象；</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: MR.L</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">2</span>/<span class="number">19</span></span><br><span class="line">  Time: <span class="number">13</span>:<span class="number">28</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录！！&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span>document.getElementById(name);</span><br><span class="line">    consloe.log(name.innerText);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/Atest/login/1&quot;</span>&gt;</span><br><span class="line">    &lt;table &gt;&lt;thead&gt;注册&lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;名字&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> name=<span class="string">&quot;username&quot;</span> placeholder=<span class="string">&quot;请输入名字&quot;</span>/&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;label <span class="keyword">for</span>=<span class="string">&quot;pwd&quot;</span>&gt;密码&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;pwd&quot;</span> name=<span class="string">&quot;password&quot;</span> placeholder=<span class="string">&quot;请输入密码&quot;</span>/&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;&lt;td colspan=<span class="string">&quot;2&quot;</span>&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">        &lt;/tbody&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实现步骤其实非常的简单：</p><ol><li>新建一个web项目</li><li>导入相关jar包</li><li>编写web.xml , 注册DispatcherServlet</li><li>编写springmvc配置文件</li><li>接下来就是去创建对应的控制类 , controller</li><li>最后完善前端视图和controller之间的对应</li><li>测试运行调试.</li></ol><p>使用springMVC必须配置的三大件：</p><p><strong>处理器映射器、处理器适配器、视图解析器</strong></p><p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringMVC的配置&quot;&gt;&lt;a href=&quot;#SpringMVC的配置&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC的配置&quot;&gt;&lt;/a&gt;SpringMVC的配置&lt;/h2&gt;&lt;p&gt;在web.xml中注册&lt;code&gt;DispactherSer</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Spring" scheme="https://lyotoc.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>springCloud</title>
    <link href="https://lyotoc.github.io/2022/06/02/springCloud/"/>
    <id>https://lyotoc.github.io/2022/06/02/springCloud/</id>
    <published>2022-06-02T06:23:59.000Z</published>
    <updated>2022-06-02T06:25:14.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-SOA与微服务的关系"><a href="#1-1-SOA与微服务的关系" class="headerlink" title="1.1 SOA与微服务的关系"></a>1.1 SOA与微服务的关系</h1><p><strong>SOA</strong>面向服务架构，他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。各个服务之间通过网络调用。</p><p><strong>微服务架构</strong>:其实和SOA类似，微服务是在SOA上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。</p><table><thead><tr><th>功能</th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>组件大小</td><td>大块业务逻辑</td><td>单独任务或小块业务逻辑</td></tr><tr><td>耦合</td><td>通常松耦合</td><td>总是松耦合</td></tr><tr><td>公司架构</td><td>任何类型</td><td>小型、专注于功能交叉团队</td></tr><tr><td>管理</td><td>着重中央管理</td><td>着重分散管理</td></tr><tr><td>目标</td><td>确保应用能够交互操作</td><td>执行新功能、快速拓展开发团队</td></tr></tbody></table><h1 id="1-2-远程调用技术"><a href="#1-2-远程调用技术" class="headerlink" title="1.2 远程调用技术"></a>1.2 远程调用技术</h1><p><strong>RPC:</strong></p><p>PC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务，直接使用TCP或UDP协议进行服务间的通信</p><p><strong>http</strong></p><p>RESTful</p><table><thead><tr><th>比较</th><th>RESTful</th><th>RPC</th></tr></thead><tbody><tr><td>通讯协议</td><td>HTTP</td><td>一般使用TCP</td></tr><tr><td>性能</td><td>略低</td><td>较高</td></tr><tr><td>灵活度</td><td>高</td><td>低</td></tr><tr><td>应用</td><td>微服务架构</td><td>SOA架构</td></tr></tbody></table><h1 id="1-3-Spring-Cloud"><a href="#1-3-Spring-Cloud" class="headerlink" title="1.3 Spring Cloud"></a>1.3 Spring Cloud</h1><p><strong>Spring Cloud Netflix组件</strong></p><table><thead><tr><th>组件名称</th><th>作用</th></tr></thead><tbody><tr><td>Eureka</td><td>服务注册中心</td></tr><tr><td>Ribbon</td><td>客户端负载均衡</td></tr><tr><td>Feign</td><td>声明式服务调用</td></tr><tr><td>Hystrix</td><td>客户端容错保护</td></tr><tr><td>Zuul</td><td>API服务网关</td></tr></tbody></table><h1 id="2-服务注册Eureka"><a href="#2-服务注册Eureka" class="headerlink" title="2 服务注册Eureka"></a>2 服务注册Eureka</h1><h2 id="2-1-微服务的注册中心"><a href="#2-1-微服务的注册中心" class="headerlink" title="2.1 微服务的注册中心"></a>2.1 微服务的注册中心</h2><p>注册中心可以说是微服务架构中的“通讯录”，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就在这里找到服务地址，进行调用。</p><h2 id="2-1-1-注册中心的主要作用"><a href="#2-1-1-注册中心的主要作用" class="headerlink" title="2.1.1 注册中心的主要作用"></a>2.1.1 注册中心的主要作用</h2><p>注册中心在微服务架构中主要起到了协调者的一个作用。注册中心一般包含如下几个功能：</p><ol><li><p>服务发现：服务注册&#x2F;反注册 服务订阅&#x2F;取消订阅 服务路由</p></li><li><p>服务配置：配置订阅 配置下发</p></li><li><p>服务健康检测</p></li></ol><h2 id="2-1-2-常见的注册中心"><a href="#2-1-2-常见的注册中心" class="headerlink" title="2.1.2 常见的注册中心"></a>2.1.2 常见的注册中心</h2><ul><li><p>zookeeper</p></li><li><p>eureka</p></li><li><p>consul</p></li><li><p>nacos</p></li></ul><h3 id="使用Eureka"><a href="#使用Eureka" class="headerlink" title="使用Eureka"></a>使用Eureka</h3><ol><li><p>搭建eureka server</p><ol><li><p>创建工程</p><p>在项目的project下新建module子模块</p></li><li><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册中心坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置<code>application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">instance:</span></span><br><span class="line">   <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">registerWithEureka:</span> <span class="literal">false</span>  </span><br><span class="line">   <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">   <span class="attr">serviceUrl:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>registerWithEureka: 是否将自己注册到Eureka服务中，本身就是所以无需注册 </p><p>fetchRegistry : 是否从Eureka中获取注册信息 </p><p>serviceUrlEureka: 客户端与Eureka服务端进行交互的地址</p></blockquote></li><li><p>配置启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//激活eureka服务</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>将服务提供者注册到eureka server上</p><ol><li><p>引入eureka相应的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入rureka客户端坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>application.yml</code>添加eureka server的信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">serviceUrl:</span> <span class="comment"># eureka server的路径</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">   <span class="comment">#非必要  </span></span><br><span class="line"> <span class="attr">instance:</span></span><br><span class="line">   <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#使用ip注册</span></span><br></pre></td></tr></table></figure></li><li><p>修改启动类 添加服务发现的支持</p></li></ol></li><li><p>服务消费者通过注册中心获取服务列表，并调用</p></li></ol><p>​eureka中的元数据：服务的主机名，IP地址等信息，可以通过eureka server进行获取，用于服务之间调用</p><h3 id="eureka集群、高可用的引入"><a href="#eureka集群、高可用的引入" class="headerlink" title="eureka集群、高可用的引入"></a>eureka集群、高可用的引入</h3><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210817165148.png"></p><p>1、准备2个eureka server，需要相互注册</p><p>​1 号server：9000</p><p>​2 号server：8000</p><p>2、需要将微服务注册到两个eureka server上</p><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><h4 id="在控制台显示服务IP"><a href="#在控制台显示服务IP" class="headerlink" title="在控制台显示服务IP"></a>在控制台显示服务IP</h4><p>在服务提供者，通过eureka.instance.instance-id配置控制台显示服务IP</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9000/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 使用ip地址注册</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span> <span class="comment">#想注册中心中注册服务id</span></span><br></pre></td></tr></table></figure><h4 id="eureka的服务剔除问题"><a href="#eureka的服务剔除问题" class="headerlink" title="eureka的服务剔除问题"></a>eureka的服务剔除问题</h4><p>默认每隔30s发送心跳，如果90s内没有发送心跳代表宕机</p><p>在服务的提供者，设置心跳间隔，设置续约到期时间</p><h4 id="eureka的自我保护机制"><a href="#eureka的自我保护机制" class="headerlink" title="eureka的自我保护机制"></a>eureka的自我保护机制</h4><p>在eureka中配置关闭自我保护和剔除服务间隔</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将自己注册到注册中心</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#是否要从eureka中获取注册信息</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment">#配置暴露给Eureka Client的请求地址</span></span><br><span class="line">      <span class="attr">defalutZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护机制</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">4000</span> <span class="comment"># 设置剔除服务间隔</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="2-2-eureka源码解析"><a href="#2-2-eureka源码解析" class="headerlink" title="2.2 eureka源码解析"></a>2.2 eureka源码解析</h2><h3 id="2-2-1-SpringBoot中的自动装载"><a href="#2-2-1-SpringBoot中的自动装载" class="headerlink" title="2.2.1 SpringBoot中的自动装载"></a>2.2.1 SpringBoot中的自动装载</h3><h4 id="1-ImportSelector"><a href="#1-ImportSelector" class="headerlink" title="(1) ImportSelector"></a>(1) ImportSelector</h4><p>ImportSelector接口是Spring导入外部配置的核心接口，在SpringBoot的自动化配置和@EnableXXX(功能性注解)中起到了决定性作用。当在@Configuration标注的Class上使用@Import引入了一个ImportSelector实现类后，会把实现类中返回的Class名称都定义为Bean。</p><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210820162313.png" alt="企业微信20210820162313"></p><h4 id="2-EnableEurekaServer"><a href="#2-EnableEurekaServer" class="headerlink" title="(2) EnableEurekaServer"></a>(2) EnableEurekaServer</h4><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210823094837.png" alt="企业微信20210823094837"></p><h1 id="3-服务调用Ribbon"><a href="#3-服务调用Ribbon" class="headerlink" title="3. 服务调用Ribbon"></a>3. 服务调用Ribbon</h1><p>经过以上的学习，已经实现了服务的注册和服务发现，当启动某个服务时，可以通过HTTP的形式将信息注册到注册中心，并且可以通过SpringCloud提供的工具获取注册中心的服务列表。但是服务之间的调用还存在很多的问题，如何更加方便的调用微服务，多个微服务的提供者如何选择，如何均衡负载等。</p><h2 id="3-1-Ribbon概述"><a href="#3-1-Ribbon概述" class="headerlink" title="3.1 Ribbon概述"></a>3.1 Ribbon概述</h2><h3 id="3-1-1-什么是Ribbon"><a href="#3-1-1-什么是Ribbon" class="headerlink" title="3.1.1 什么是Ribbon"></a>3.1.1 什么是Ribbon</h3><p>是netflix发布的一个负载均衡器，有助于控制HTTP和TCP客户端行为。在SpringCloud中，Eureka一般配合Ribbon进行使用，Ribbon提供了客户端负载均衡的功能，Ribbon利用从Eureka中读取到的服务信息，在调用服务节点提供的服务时，会合理的进行负载。</p><p>在SpringCloud中可以将注册中心和Ribbon配合使用，Ribbon自动的从注册中心获取服务提供者的列表信息，并基于内置的负载均衡算法，请求服务。</p><h3 id="3-1-2-Ribbon的主要作用"><a href="#3-1-2-Ribbon的主要作用" class="headerlink" title="3.1.2 Ribbon的主要作用"></a>3.1.2 Ribbon的主要作用</h3><h4 id="1-服务调用"><a href="#1-服务调用" class="headerlink" title="(1) 服务调用"></a>(1) 服务调用</h4><p>基于Ribbon实现服务调用，是通过拉取到的所用服务列表组成(服务名-请求路径的)映射关系。借助RestTemplate最终进行调用。</p><h4 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="(2) 负载均衡"></a>(2) 负载均衡</h4><p>当有多个服务提供者时，Ribbon可以根据负载均衡的算法自动的选择需要调用的服务地址。</p><p>Ribbon是一个典型的客户端负载均衡器。Ribbon会获取服务的所有地址，根据内部的负载均衡算法，获取本次请求的有效地址。</p><p>准备两个商品微服务(9001),(9011)</p><p>在订单系统中远程以负载均衡的形式调用商品服务</p><h4 id="3-负载均衡策略"><a href="#3-负载均衡策略" class="headerlink" title="(3) 负载均衡策略"></a>(3) 负载均衡策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.loadbalancer.RoudRobinRule  <span class="comment">//以轮询的方式进行负载均衡</span></span><br><span class="line">com.netflix.loadbalancer.RandomRule <span class="comment">//随机策略</span></span><br><span class="line">com.netflix.loadbalancer.RetryRule <span class="comment">//重试策略</span></span><br><span class="line">com.netflix.loadbalancer.weightedResponseTimeRule <span class="comment">//权重策略，会计算每个服务的权重，越高的调用的可能性越大</span></span><br><span class="line">com.netflix.loadbalancer.BestAvailableRule <span class="comment">//最佳策略，遍历所有的服务实例，过滤掉故障实例，并返回请求数最小的实例返回</span></span><br><span class="line">com.netflix.loadbalancer.AvailabilityFilteringRule <span class="comment">//可用过滤策略。过滤掉故障和请求数超过阈值的服务实例，再从剩下的实例中轮询调用</span></span><br></pre></td></tr></table></figure><p>在服务消费者的application.yml配置文件中修改负载均衡策略</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改ribbon的负载均衡策略  服务名 - ribbon - NFLoadBalancerRuleClassName : 策略</span></span><br><span class="line"><span class="attr">product-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><h4 id="4-重试机制"><a href="#4-重试机制" class="headerlink" title="(4) 重试机制"></a>(4) 重试机制</h4><p>引入spring的重试组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对ribbon进行重试配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">product-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># Ribbon的连接超时时间</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">1000</span> <span class="comment"># Ribbon的数据读取超时时间</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperation:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作都进行重试</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment"># 切换实例的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 对当前实例的重试次数</span></span><br></pre></td></tr></table></figure><h4 id="5-Ribbon源码解析"><a href="#5-Ribbon源码解析" class="headerlink" title="(5) Ribbon源码解析"></a>(5) Ribbon源码解析</h4><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210826114004.png" alt="企业微信20210826114004"></p><h1 id="4-Consul"><a href="#4-Consul" class="headerlink" title="4.Consul"></a>4.Consul</h1><p>特性：</p><p>服务发现</p><p>健康检查</p><p>K&#x2F;V存储</p><p>多数据中心</p><h3 id="4-1-1-consul和eureka区别"><a href="#4-1-1-consul和eureka区别" class="headerlink" title="4.1.1 consul和eureka区别"></a>4.1.1 consul和eureka区别</h3><h4 id="1-一致性"><a href="#1-一致性" class="headerlink" title="(1) 一致性"></a>(1) 一致性</h4><p>consul强一致性(CP)</p><p>​服务注册相比eureka会稍慢一些。因为consul的raft协议要求必须过半数的结点都写入成功才认为注册成功</p><p>​leader挂掉时，重选期间整个consul不可用，保证了强一致性但牺牲了可用性</p><p>eureka保证高可用和最终一致性(AP)</p><p>​服务注册相对较快</p><p>​当数据出现不一致时，虽然A,B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到，保证了可用性但牺牲了一致性</p><h4 id="2-开发语言和使用"><a href="#2-开发语言和使用" class="headerlink" title="(2) 开发语言和使用"></a>(2) 开发语言和使用</h4><p>eureka就是个servlet程序，跑在servlet容器中</p><p>consul则是go编写而成，安装启动即可</p><h1 id="5-服务调用Feign"><a href="#5-服务调用Feign" class="headerlink" title="5.服务调用Feign"></a>5.服务调用Feign</h1><h2 id="5-1-Feign简介"><a href="#5-1-Feign简介" class="headerlink" title="5.1 Feign简介"></a>5.1 Feign简介</h2><p>Feign是netfilx开发的声明式，模板化的HTTP客户端，其灵感来自Retrofit, JAXR-2.0以及WebSocket</p><p>​Feign可以帮助我们更加便捷，优雅的调用HTTP</p><p>​在SpringCloud中，使用Feign非常简单–创建一个接口，并在接口上添加一些注解，代码就完成了。</p><p>​Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等</p><p>​SpringCloud对Feign进行了增强，使Feign支持了SprimgMVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便</p><p>​Feign是在Ribbon的基础上进行了一次改进，是一个使用起来更加方便的HTTP客户端。采用接口的方式，只需要创建一个接口，在上面添加注解即可，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建HTTP请求，然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写客户端变得非常容易</p><h2 id="5-2-基于Feign的服务调用"><a href="#5-2-基于Feign的服务调用" class="headerlink" title="5.2 基于Feign的服务调用"></a>5.2 基于Feign的服务调用</h2><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="(1) 引入依赖"></a>(1) 引入依赖</h4><p>在服务消费者shop_order-service添加Feign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-配置调用接口"><a href="#2-配置调用接口" class="headerlink" title="(2) 配置调用接口"></a>(2) 配置调用接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明需要调用的微服务名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FeignClient</span></span></span><br><span class="line"><span class="comment"> *      * name: 服务提供者的名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;product-sercvice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductFeignClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置需要调用的微服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/product/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在启动类激活Feign"><a href="#3-在启动类激活Feign" class="headerlink" title="(3) 在启动类激活Feign"></a>(3) 在启动类激活Feign</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EntityScan(&quot;cn.itcast.order.entity&quot;)</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//激活feign</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span></span><br></pre></td></tr></table></figure><h4 id="4-通过自动的接口调用远程服务"><a href="#4-通过自动的接口调用远程服务" class="headerlink" title="(4) 通过自动的接口调用远程服务"></a>(4) 通过自动的接口调用远程服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductFeignClient productFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/buy/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    product = productFeignClient.findById(id);</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-负载均衡"><a href="#5-3-负载均衡" class="headerlink" title="5.3 负载均衡"></a>5.3 负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。</p><h1 id="6-服务调用Feign高级"><a href="#6-服务调用Feign高级" class="headerlink" title="6 服务调用Feign高级"></a>6 服务调用Feign高级</h1><h2 id="6-1-Feign的配置"><a href="#6-1-Feign的配置" class="headerlink" title="6.1 Feign的配置"></a>6.1 Feign的配置</h2><p>从SpringCloud Edgware开始，Feign支持使用属性自定义Feign。对于一个指定名称的FeignClient，Feign支持如下配置</p><p>​feignName: FeignClient的名称</p><p>​connectTimeout：建立链接的超时时长</p><p>​readTimeout：读取超时时长</p><p>​loggerLevel：Feign的日志级别</p><p>​errorDecoder：Feign的错误解码器</p><p>​retryer: 配置重试</p><p>​requestInterceptors：添加请求拦截器</p><p>​decoder404：配置熔断不处理404异常</p><h2 id="6-2-请求压缩"><a href="#6-2-请求压缩" class="headerlink" title="6.2 请求压缩"></a>6.2 请求压缩</h2><p>SpringCloud Feign支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗，通过下面的参数即可开启请求与响应的压缩功能：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">compression:</span></span><br><span class="line"><span class="attr">request:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启请求压缩</span></span><br><span class="line"><span class="attr">response:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启响应压缩</span></span><br></pre></td></tr></table></figure><h2 id="6-3-日志级别"><a href="#6-3-日志级别" class="headerlink" title="6.3 日志级别"></a>6.3 日志级别</h2><p>在开发或者运行阶段往往希望看到Feign请求过程的日志记录，默认情况下Feign的日志是没有开启的。要想用属性配置方式来达到日志效果，只需在application.yml中添加如下内容即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">shop-product-service:</span></span><br><span class="line"><span class="attr">loggerLevel:</span> <span class="string">FULL</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">level:</span></span><br><span class="line"><span class="attr">cn.itcast.order.feign.ProductFeignClient:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h2 id="6-4-Feign和Ribbon的区别"><a href="#6-4-Feign和Ribbon的区别" class="headerlink" title="6.4 Feign和Ribbon的区别"></a>6.4 Feign和Ribbon的区别</h2><p>Ribbon是一个客户端的负载均衡器</p><p>Feign是在Ribbon的基础上进行了封装</p><h2 id="6-5-组件的使用方式"><a href="#6-5-组件的使用方式" class="headerlink" title="6.5 组件的使用方式"></a>6.5 组件的使用方式</h2><h3 id="6-5-1-注册中心"><a href="#6-5-1-注册中心" class="headerlink" title="6.5.1 注册中心"></a>6.5.1 注册中心</h3><h4 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="(1) Eureka"></a>(1) Eureka</h4><p>​搭建注册中心</p><p>​引入依赖 spring-cloud-starter-netflix-eureka-server</p><p>​配置EurekaServer</p><p>​通过@EnableEurekaServer激活Eureka Server端配置</p><p>​服务注册</p><p>​服务提供者引入 spring-cloud-starter-netflix-eureka-client依赖</p><p>​通过eureka.client.serviceUrl.defaultZone 配置注册中心地址</p><h4 id="2-consul"><a href="#2-consul" class="headerlink" title="(2) consul"></a>(2) consul</h4><p>​搭建注册中心</p><p>​下载安装consul</p><p>​启动consul consul agent -dev</p><p>​服务注册</p><p>​服务提供者引入spring-cloud-starter-consul-discovery</p><p>​通过spring.cloud.consul.host和spring.cloud.consul.port指定Consul Server的请求地址</p><h3 id="6-5-2-服务调用"><a href="#6-5-2-服务调用" class="headerlink" title="6.5.2 服务调用"></a>6.5.2 服务调用</h3><h4 id="1-Ribbon"><a href="#1-Ribbon" class="headerlink" title="(1) Ribbon"></a>(1) Ribbon</h4><p>​通过Ribbon结合RestTemplate方式进行服务调用只需要在声明RestTemplate的方法上添加注解@LoadBalanced 即可</p><p>​可以通过{服务名称}.ribbon.NFLoadBalancerRuleClassName配置负载均衡策略</p><h4 id="2-Feign"><a href="#2-Feign" class="headerlink" title="(2) Feign"></a>(2) Feign</h4><p>​服务消费者引入spring-cloud-starter-openfeign依赖</p><p>​通过@FeignClient声明一个调用远程微服务接口</p><p>​启动类上通过@EnableFeignClient激活Feign</p><h2 id="6-1-微服务架构的高并发问题"><a href="#6-1-微服务架构的高并发问题" class="headerlink" title="6.1 微服务架构的高并发问题"></a>6.1 微服务架构的高并发问题</h2><p>通过注册中心已经实现了微服务的服务注册和服务发现,并且通过Ribbon实现了负载均衡，已经借助Feign可以优雅的进行微服务调用。那么我们编写的微服务的性能怎么样呢？是否存在问题？</p><h3 id="6-1-1-性能测试工具Jmeter"><a href="#6-1-1-性能测试工具Jmeter" class="headerlink" title="6.1.1 性能测试工具Jmeter"></a>6.1.1 性能测试工具Jmeter</h3><p>用来进行压力测试</p><h2 id="6-2-系统负载过高存在的问题"><a href="#6-2-系统负载过高存在的问题" class="headerlink" title="6.2 系统负载过高存在的问题"></a>6.2 系统负载过高存在的问题</h2><h3 id="6-2-1-问题分析"><a href="#6-2-1-问题分析" class="headerlink" title="6.2.1 问题分析"></a>6.2.1 问题分析</h3><p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪。</p><p>在SpringBoot程序中，默认使用内置tomcat作为web服务器。单tomcat支持最大的并发请求是有限的，如果某一接口阻塞，待执行的任务积压越来越多，那么势必会影响其他接口的调用。</p><h3 id="6-2-2-线程池的形式实现服务隔离"><a href="#6-2-2-线程池的形式实现服务隔离" class="headerlink" title="6.2.2 线程池的形式实现服务隔离"></a>6.2.2 线程池的形式实现服务隔离</h3><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210830111824.png" alt="企业微信20210830111824"></p><h1 id="7-服务熔断Hystrix入门"><a href="#7-服务熔断Hystrix入门" class="headerlink" title="7.服务熔断Hystrix入门"></a>7.服务熔断Hystrix入门</h1><h2 id="7-1-服务容错的核心知识"><a href="#7-1-服务容错的核心知识" class="headerlink" title="7.1 服务容错的核心知识"></a>7.1 服务容错的核心知识</h2><h3 id="7-1-1-雪崩效应"><a href="#7-1-1-雪崩效应" class="headerlink" title="7.1.1 雪崩效应"></a>7.1.1 雪崩效应</h3><p>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问A服务，而A服务需要调用B服务，B服务需要调用C服务，由于网络原因或者自身的原因，如果B服务或者C服务不能及时响应，A服务将处于阻塞状态，直到B服务C服务响应。此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务于服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><p>雪崩是系统中的蝴蝶效应导致其发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="zuul网关"><a href="#zuul网关" class="headerlink" title="zuul网关"></a>zuul网关</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>ZUUL是Netﬂix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用，Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：</p></blockquote><ul><li><strong>动态路由</strong>：动态将请求路由到不同后端集群</li><li><strong>压力测试</strong>：逐渐增加指向集群的流量，以了解性能 </li><li><strong>负载分配</strong>：为每一种负载类型分配对应容量，并弃用超出限定值的请求 </li><li><strong>静态响应处理</strong>：边缘位置进行响应，避免转发到内部集群 </li><li><strong>身份认证和安全</strong>: 识别每一个资源的验证要求，并拒绝那些不符的请求。Spring Cloud对Zuul进行了整合和增强。</li></ul><h3 id="搭建zuul网关服务器"><a href="#搭建zuul网关服务器" class="headerlink" title="搭建zuul网关服务器"></a>搭建zuul网关服务器</h3><ol><li>创建工程导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>配置启动类，开启网关服务器功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootAplication</span></span><br><span class="line"><span class="comment">//开启zuul网关功能</span></span><br><span class="line"><span class="meta">@EnableZuulproxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulServerApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="string">port:8080</span> <span class="comment">#端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="string">name:api-zuul-server</span> <span class="comment">#服务名称</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由：根据请求的URL，将请求分配到对应的微服务中进行处理</p><ol><li><h4 id="基础路由配置"><a href="#基础路由配置" class="headerlink" title="基础路由配置"></a>基础路由配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#路由配置</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="comment">#商品微服务</span></span><br><span class="line"><span class="attr">product-service:</span> <span class="comment">#路由id，随便写</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/product-service/**</span>    <span class="comment"># 输入的映射路径 localhost:8080/product-service/xxxx</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://127.0.0.1:9001</span>  <span class="comment">#映射路径对应的微服务的url地址</span></span><br></pre></td></tr></table></figure></li><li><h4 id="面向服务的路由"><a href="#面向服务的路由" class="headerlink" title="面向服务的路由"></a>面向服务的路由</h4><blockquote><p>微服务一般是由几十、上百个服务组成，对于一个URL请求，最终会确认一个服务实例进行处理。如果对每个服务实例手动指定一个唯一访问地址，然后根据URL去手动实现请求匹配，这样做显然就不合理。 Zuul支持与Eureka整合开发，根据ServiceID自动的从注册中心中获取服务地址并转发请求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而且在添加或移除服务实例的时候不用修改Zuul的路由配置。</p></blockquote><ol><li><p>添加eureka-client依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启eureka的客户端服务发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能 @EnableDiscoveryClient public class ZuulServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulServerApplication.class, args); &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在zuul网关服务中心配置eureka的注册中心相关信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka: client: serviceUrl: defaultZone: http://127.0.0.1:8761/eureka/ registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s instance: preferIpAddress: true ip-address: 127.0.0.1</span></span><br></pre></td></tr></table></figure></li><li><p>修改路由中的映射配置</p><blockquote><p>通过服务名称获取，因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而</p><p>是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置路由规则 </span></span><br><span class="line"><span class="attr">zuul: routes: product-service:</span> <span class="comment"># 这里是路由id，随意写 </span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/product-service/**</span> <span class="comment"># 这里是映射路径 </span></span><br><span class="line"><span class="attr">serviceId:</span> <span class="string">shop-service-product</span> <span class="comment">#配置转发的微服务名称</span></span><br></pre></td></tr></table></figure><ul><li><strong>serviceId</strong>: 指定需要转发的微服务实例名称</li></ul></li></ol></li><li><p><strong>简化的路由配置</strong></p><p>在刚才的配置中，我们的规则是这样的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zuul.routes.&lt;route&gt;.path=/xxx/**</span> <span class="string">：</span> <span class="string">来指定映射路径。</span> <span class="string">&lt;route&gt;</span> <span class="string">是自定义的路由名</span></span><br><span class="line"></span><br><span class="line"><span class="string">zuul.routes.&lt;route&gt;.serviceId=/product-service</span> <span class="string">：来指定服务名。</span></span><br></pre></td></tr></table></figure><p>而大多数情况下，我们的 <code>&lt;route&gt;</code> 路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul routes.&lt;serviceId&gt;=&lt;path&gt;</code></p><p>上面的配置可以简化为一条：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul: routes: shop-service-product:</span> <span class="string">/product-service/**</span></span><br></pre></td></tr></table></figure></li><li><p><strong>默认的路由规则</strong></p><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁</p><p>琐的。</p><p>因此Zuul就指定了默认的路由规则：</p><p>默认情况下，一切服务的<strong>映射路径</strong>就是服务名<strong>本身</strong>。</p><p>例如服务名为： shop-service-product ，则默认的映射路径就是： &#x2F;shop-service- </p><p>product&#x2F;**</p></li></ol><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="ZuulFilter"><a href="#ZuulFilter" class="headerlink" title="ZuulFilter"></a>ZuulFilter</h4><ul><li><p><strong>简介</strong></p><p>Zuul 中的过滤器跟我们之前使用的 <code>javax.servlet.Filter</code> 不一样，<code>javax.servlet.Filter</code> 只有一种类型，可</p><p>以通过配置 <code>urlPatterns </code>来拦截对应的请求。而 Zuul 中的过滤器总共有 4 种类型，且每种类型都有对</p><p>应的使用场景。 </p><ol><li><strong>PRE</strong>：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请</li></ol><p>求的微服务、记录调试信息等。</p><ol start="2"><li><strong>ROUTING</strong>：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用</li></ol><p><code>Apache HttpClient</code>或<code>Netfifilx Ribbon</code>请求微服务。</p><ol start="3"><li><strong>POST</strong>：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP</li></ol><p>Header、收集统计信息和指标、将响应从微服务发送给客户端等。</p><ol start="4"><li><strong>ERROR</strong>：在其他阶段发生错误时执行该过滤器。</li></ol></li></ul><p>Zuul提供了自定义过滤器的功能实现起来也十分简单，只需要编写一个类去实现zuul提供的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ZuulFilter <span class="keyword">implements</span> <span class="title class_">IZuulFilter</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span>;<span class="comment">// 来自IZuulFilter </span></span><br><span class="line">    Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException;<span class="comment">// IZuulFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.niupic.com/images/2021/09/06/9uyQ.jpg"></p><h5 id="内部源码"><a href="#内部源码" class="headerlink" title="内部源码"></a>内部源码</h5><p><strong>自定义过滤器</strong></p><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 登录校验，肯定是在前置拦截 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 顺序设置为1 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 返回true，代表过滤器生效。 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123; </span><br><span class="line">        <span class="comment">// 登录校验逻辑。</span></span><br><span class="line">        <span class="comment">// 1）获取Zuul提供的请求上下文对象</span></span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">ctx</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">    <span class="comment">// 2) 从上下文中获取request对象 </span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> ctx.getRequest(); </span><br><span class="line">   <span class="comment">// 3) 从请求中获取</span></span><br><span class="line">        token <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;access-token&quot;</span>); </span><br><span class="line">        <span class="comment">// 4) 判断 </span></span><br><span class="line">        <span class="keyword">if</span>(token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token.trim()))&#123;</span><br><span class="line">            <span class="comment">// 没有token，登录校验失败，拦截 </span></span><br><span class="line">            ctx.setSendZuulResponse(<span class="literal">false</span>); </span><br><span class="line">            <span class="comment">// 返回401状态码。也可以考虑重定向到登录页。</span></span><br><span class="line">            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); &#125;<span class="comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>RequestContext</code>：用于在过滤器之间传递消息。它的数据保存在每个请求的<code>ThreadLocal</code>中。它</p><p>用于存储请求路由到哪里、错误、<code>HttpServletRequest</code>、<code>HttpServletResponse</code>都存储在</p><p><code>RequestContext</code>中。<code>RequestContext</code>扩展了<code>ConcurrentHashMap</code>，所以，任何数据都可以存储</p><p>在上下文中</p></li></ul><h2 id="springcloud-gateway网关"><a href="#springcloud-gateway网关" class="headerlink" title="springcloud gateway网关"></a>springcloud gateway网关</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-1-SOA与微服务的关系&quot;&gt;&lt;a href=&quot;#1-1-SOA与微服务的关系&quot; class=&quot;headerlink&quot; title=&quot;1.1 SOA与微服务的关系&quot;&gt;&lt;/a&gt;1.1 SOA与微服务的关系&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;SOA&lt;/strong&gt;面向</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Spring Cloud" scheme="https://lyotoc.github.io/tags/Spring-Cloud/"/>
    
    <category term="微服务" scheme="https://lyotoc.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Docker命令详解（run篇）</title>
    <link href="https://lyotoc.github.io/2022/06/02/Docker%E4%B8%ADrun%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lyotoc.github.io/2022/06/02/Docker%E4%B8%ADrun%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-06-02T06:21:00.000Z</published>
    <updated>2022-06-10T07:22:50.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker命令详解（run篇）"><a href="#Docker命令详解（run篇）" class="headerlink" title="Docker命令详解（run篇）"></a><a href="https://www.cnblogs.com/yfalcon/p/9044246.html">Docker命令详解（run篇）</a></h1><p>命令格式：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><br>Usage: Run a command in a new container<br>中文意思为：通过run命令创建一个新的容器（container）</p><ul><li><p>常用选项说明</p><ul><li><p><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</p></li><li><p><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</p></li><li><p><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</p></li><li><p><code>-u, --user=&quot;&quot;</code>， 指定容器的用户</p></li><li><p><code>-a, --attach=[]</code>， 登录容器（必须是以docker run -d启动的容器）</p></li><li><p><code>-w, --workdir=&quot;&quot;</code>， 指定容器的工作目录</p></li><li><p><code>-c, --cpu-shares=0</code>， 设置容器CPU权重，在CPU共享场景使用</p></li><li><p><code>-e, --env=[]</code>， 指定环境变量，容器中可以使用该环境变量</p></li><li><p><code>-m, --memory=&quot;&quot;</code>， 指定容器的内存上限</p></li><li><p><code>-P, --publish-all=false</code>， 指定容器暴露的端口</p></li><li><p><code>-p, --publish=[]</code>， 指定容器暴露的端口</p></li><li><p><code>-h, --hostname=&quot;&quot;</code>， 指定容器的主机名</p></li><li><p><code>-v, --volume=[]</code>， 给容器挂载存储卷，挂载到容器的某个目录</p></li><li><p><code>--volumes-from=[]</code>， 给容器挂载其他容器上的卷，挂载到容器的某个目录</p></li><li><p><code>--cap-add=[]</code>， 添加权限，<a href="http://linux.die.net/man/7/capabilities">权限清单详见</a></p></li><li><p><code>--cap-drop=[]</code>， 删除权限，<a href="http://linux.die.net/man/7/capabilities">权限清单详见</a></p></li><li><p><code>--cidfile=&quot;&quot;</code>， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</p></li><li><p><code>--cpuset=&quot;&quot;</code>， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</p></li><li><p><code>--device=[]</code>， 添加主机设备给容器，相当于设备直通</p></li><li><p><code>--dns=[]</code>， 指定容器的dns服务器</p></li><li><p><code>--dns-search=[]</code>， 指定容器的dns搜索域名，写入到容器的&#x2F;etc&#x2F;resolv.conf文件</p></li><li><p><code>--entrypoint=&quot;&quot;</code>， 覆盖image的入口点</p></li><li><p><code>--env-file=[]</code>， 指定环境变量文件，文件格式为每行一个环境变量</p></li><li><p><code>--expose=[]</code>， 指定容器暴露的端口，即修改镜像的暴露端口</p></li><li><p><code>--link=[]</code>， 指定容器间的关联，使用其他容器的IP、env等信息</p></li><li><p><code>--lxc-conf=[]</code>， 指定容器的配置文件，只有在指定–exec-driver&#x3D;lxc时使用</p></li><li><p><code>--name=&quot;&quot;</code>， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</p></li><li><pre><code>--net=&quot;bridge&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ， 容器网络设置:</span><br><span class="line"></span><br><span class="line">  - bridge 使用docker daemon指定的网桥</span><br><span class="line">  - host //容器使用主机的网络</span><br><span class="line">  - container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源</span><br><span class="line">  - none 容器使用自己的网络（类似--net=bridge），但是不进行配置</span><br><span class="line"></span><br><span class="line">- `--privileged=false`， 指定容器是否为特权容器，特权容器拥有所有的capabilities</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  --restart=&quot;no&quot;</span><br></pre></td></tr></table></figure>， 指定容器停止后的重启策略:- no：容器退出时不重启- on-failure：容器故障退出（返回值非零）时重启- always：容器退出时总是重启</code></pre></li><li><p><code>--rm=false</code>， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</p></li><li><p><code>--sig-proxy=true</code>， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</p></li></ul></li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul><li>运行一个在后台执行的容器，同时，还能用控制台管理：<code>docker run -i -t -d ubuntu:latest</code></li><li>运行一个带命令在后台不断执行的容器，不直接展示容器内部信息：<code>docker run -d ubuntu:latest ping www.docker.com</code></li><li>运行一个在后台不断执行的容器，同时带有命令，程序被终止后还能重启继续跑，还能用控制台管理，<code>docker run -d --restart=always ubuntu:latest ping www.docker.com</code></li><li>为容器指定一个名字，<code>docker run -d --name=ubuntu_server ubuntu:latest</code></li><li>容器暴露80端口，并指定宿主机80端口与其通信(<strong>:</strong> 之前是宿主机端口，之后是容器需暴露的端口)，<code>docker run -d --name=ubuntu_server -p 80:80 ubuntu:latest</code></li><li>指定容器内目录与宿主机目录共享(<strong>:</strong> 之前是宿主机文件夹，之后是容器需共享的文件夹)，<code>docker run -d --name=ubuntu_server -v /etc/www:/var/www ubuntu:latest</code></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker命令详解（run篇）&quot;&gt;&lt;a href=&quot;#Docker命令详解（run篇）&quot; class=&quot;headerlink&quot; title=&quot;Docker命令详解（run篇）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/yfalc</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://lyotoc.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MySql的使用</title>
    <link href="https://lyotoc.github.io/2022/06/02/MySql%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://lyotoc.github.io/2022/06/02/MySql%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-06-02T06:01:15.000Z</published>
    <updated>2022-06-02T06:02:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql及SQL语句的使用"><a href="#Mysql及SQL语句的使用" class="headerlink" title="Mysql及SQL语句的使用"></a>Mysql及SQL语句的使用</h2><h3 id="mysql登录相关"><a href="#mysql登录相关" class="headerlink" title="mysql登录相关"></a>mysql登录相关</h3><ul><li><p><strong>命令登录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hyourip -uusername -ppassword -Pport (本地连接可以不许需要 -h与-P)</span><br></pre></td></tr></table></figure></li><li><p><strong>用户添加及授权</strong></p><blockquote><p><strong>以root用户登录Mysql</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure><blockquote><p><strong>切换到mysql数据库</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure><blockquote><p><strong>添加用户</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>只允许指定ip连接</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许所有ip连接（用通配符<span class="operator">%</span>表示）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为新用户授权</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//基本格式如下</span><br><span class="line">grant all privileges on 数据库名.表名 to &#x27;新用户名&#x27;@&#x27;指定ip&#x27; identified by &#x27;新用户密码&#x27; ;</span><br><span class="line">//示例</span><br><span class="line">//允许访问所有数据库下的所有表</span><br><span class="line">grant all privileges on *.* to &#x27;新用户名&#x27;@&#x27;指定ip&#x27; identified by &#x27;新用户密码&#x27; ;</span><br><span class="line">//指定数据库下的指定表</span><br><span class="line">grant all privileges on test.test to &#x27;新用户名&#x27;@&#x27;指定ip&#x27; identified by &#x27;新用户密码&#x27; ;</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置用户操作权限</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>设置用户拥有所有权限也就是管理员</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>拥有查询权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>其它操作权限说明,<span class="keyword">select</span>查询 <span class="keyword">insert</span>插入 <span class="keyword">delete</span>删除 <span class="keyword">update</span>修改</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置用户拥有查询插入的权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>取消用户查询的查询权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">select</span> <span class="keyword">ON</span> what <span class="keyword">FROM</span> <span class="string">&#x27;新用户名&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改用户</strong></p></blockquote><ul><li><p><strong>方法1： 用SET PASSWORD命令</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：mysql<span class="operator">&gt;</span> <span class="keyword">set</span> password <span class="keyword">for</span> 用户名<span class="variable">@localhost</span> <span class="operator">=</span> password(<span class="string">&#x27;新密码&#x27;</span>); </span><br><span class="line">例子：mysql<span class="operator">&gt;</span> <span class="keyword">set</span> password <span class="keyword">for</span> root<span class="variable">@localhost</span> <span class="operator">=</span> password(<span class="string">&#x27;123&#x27;</span>); </span><br></pre></td></tr></table></figure></li><li><p><strong>方法2：用mysqladmin</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：mysqladmin <span class="operator">-</span>u用户名 <span class="operator">-</span>p旧密码 password 新密码 </span><br><span class="line">例子：mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 password <span class="number">123</span> </span><br></pre></td></tr></table></figure></li><li><p><strong>方法3：用UPDATE直接编辑user表</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use mysql; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;123&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges; </span><br></pre></td></tr></table></figure></li><li><p><strong>方法4：在忘记root密码的时候，可以这样</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">以windows为例： </span><br><span class="line"><span class="number">1.</span> 关闭正在运行的MySQL服务。 </span><br><span class="line"><span class="number">2.</span> 打开DOS窗口，转到mysql\bin目录。 </span><br><span class="line"><span class="number">3.</span> 输入mysqld <span class="comment">--skip-grant-tables 回车。--skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。 </span></span><br><span class="line"><span class="number">4.</span> 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\bin目录。 </span><br><span class="line"><span class="number">5.</span> 输入mysql回车，如果成功，将出现MySQL提示符 <span class="operator">&gt;</span>。 </span><br><span class="line"><span class="number">6.</span> 连接权限数据库： use mysql; 。 </span><br><span class="line"><span class="number">6.</span> 改密码：<span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(&quot;123&quot;) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span>&quot;root&quot;;（别忘了最后加分号） 。 </span><br><span class="line"><span class="number">7.</span> 刷新权限（必须步骤）：flush privileges;　。 </span><br><span class="line"><span class="number">8.</span> 退出 quit。 </span><br><span class="line"><span class="number">9.</span> 注销系统，再进入，使用用户名root和刚才设置的新密码<span class="number">123</span>登录。</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>删除用户</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> username<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改后刷新权限</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><blockquote></blockquote></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mysql及SQL语句的使用&quot;&gt;&lt;a href=&quot;#Mysql及SQL语句的使用&quot; class=&quot;headerlink&quot; title=&quot;Mysql及SQL语句的使用&quot;&gt;&lt;/a&gt;Mysql及SQL语句的使用&lt;/h2&gt;&lt;h3 id=&quot;mysql登录相关&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="SQL" scheme="https://lyotoc.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>学习redis总结</title>
    <link href="https://lyotoc.github.io/2022/06/01/%E5%AD%A6%E4%B9%A0redis%E6%80%BB%E7%BB%93/"/>
    <id>https://lyotoc.github.io/2022/06/01/%E5%AD%A6%E4%B9%A0redis%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-01T09:39:00.000Z</published>
    <updated>2022-06-02T05:54:50.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><p>它是一个用C写的单线程的非关系型的内存数据库</p><p><strong>特点</strong>：</p><ol><li><strong>速度快</strong> </li><li>持久化</li><li>多种数据结构</li><li>支持多种编程语言</li><li>功能丰富</li><li>简单</li><li>高可用、分布式</li><li>主从复制</li></ol><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/9BJE.jpg"></p><h3 id="Redis可执行文件的说明"><a href="#Redis可执行文件的说明" class="headerlink" title="Redis可执行文件的说明"></a>Redis可执行文件的说明</h3><table><thead><tr><th>redis-server</th><th>Redis服务器</th></tr></thead><tbody><tr><td>redis-cli</td><td>Redis命令行客户端</td></tr><tr><td>redis-benchmark</td><td>Redis性能测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF文件修复</td></tr><tr><td>redis-check-dump</td><td>RDB文件检查</td></tr><tr><td>redis-Sentinel</td><td>Sentinel服务器（2.8以后）</td></tr></tbody></table><h3 id="Redis的启动方法"><a href="#Redis的启动方法" class="headerlink" title="Redis的启动方法"></a><strong>Redis的启动方法</strong></h3><p><strong>Linux下载redis</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install redis</span><br></pre></td></tr></table></figure><ul><li><p>最简启动</p><p><code>redis-server</code></p><ul><li>验证Redis是否启动的方法<ul><li><code>ps -ef|grep redis</code>   –进程是否启动</li><li><code>netstat -antpl|grep redis</code> –端口是否被监听</li><li><code>redis-cli -h ip -p port ping</code></li></ul></li></ul></li><li><p>动态参数启动</p><ul><li><p>端口配置更改</p><p>redis默认使用6379端口提供服务，使用<code>redis-server --port &lt;port&gt;</code>自定义端口。<code>&lt;prot&gt;</code> 为自定义的端口号。</p></li></ul></li><li><p>配置文件启动</p><p><code>redis-server configPath</code> 将需配置的参数在配置文件中定义好，让后使用该命令启动Redis。<code>configPath</code> 是配置文件所在路径。</p></li></ul><h3 id="Redis客户端连接"><a href="#Redis客户端连接" class="headerlink" title="Redis客户端连接"></a>Redis客户端连接</h3><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210236935.png" alt="image-20210916210236935"></p><p><strong>Redis客户端返回值</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210537206.png"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210635450.png" alt="image-20210916210635450"></p><p><strong>Redis常用配置</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210959948.png" alt="image-20210916210959948"></p><h3 id="Redis的通用命令和数据结构"><a href="#Redis的通用命令和数据结构" class="headerlink" title="Redis的通用命令和数据结构"></a>Redis的通用命令和数据结构</h3><h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><ul><li><p><code>keys</code><br><strong>拿出匹配的键</strong></p><p><strong>PS：一般不在生产环境中使用</strong></p><p><strong>示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111045353.png" alt="image-20210917111045353"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111153218.png" alt="image-20210917111153218"></p></li><li><p><code>dbsize</code> –计算KEY的总数<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111613093.png" alt="image-20210917111613093"></p></li><li><p><code>exists key</code> –检查key是否存在<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111747874.png" alt="image-20210917111747874"></p></li><li><p><code>del key [key ...]</code> – 删除指定的k-v<br><img src="C:%5CUsers%5C17102%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210917111926818.png" alt="image-20210917111926818"></p></li><li><p><code>expire key seconds</code><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917112041294.png" alt="image-20210917112041294"></p></li></ul><p><img src="C:%5CUsers%5C17102%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210917112538311.png" alt="image-20210917112538311"></p><p>​<img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917112705593.png" alt="image-20210917112705593"></p><ul><li><p><code>type key</code> –返回key的类型<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917112930085.png" alt="image-20210917112930085"></p><p><strong>时间复杂度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917113117249.png" alt="image-20210917113117249"></p></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917113352592.png" alt="image-20210917113352592"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917113848458.png"></p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><h6 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917141954286.png" alt="image-20210917141954286"></p><h6 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h6><p><code>get key</code> —获取对应的value</p><p><code>set key value </code> —设置key-value</p><p><code>del key </code> —删除key-value</p><p><code>incr </code>、<code>decr</code>、<code>incrby</code>、<code>decrby</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917142509696.png" alt="image-20210917142509696"><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917142621235.png" alt="image-20210917142621235"></p><p><code>set</code> 、<code>setnx</code> 、<code>setxx</code> </p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917143743654.png" alt="image-20210917143743654"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917143857324.png" alt="image-20210917143857324"></p><p><code>getset</code> <code>append</code> <code>strlen</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144407686.png" alt="image-20210917144407686"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144448747.png" alt="image-20210917144448747"></p><p><code>incrbyfloat</code> <code>getrange</code> <code>setrange</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144640080.png" alt="image-20210917144640080"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144720485.png" alt="image-20210917144720485"></p><p><strong>批量操作</strong></p><p><code>mget</code> 、<code>mset</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144058858.png" alt="image-20210917144058858"></p><p><strong>字符串的时间复杂度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144810938.png" alt="image-20210917144810938"></p><h5 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h5><h6 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h6><p><strong>K-F-V</strong> :类似于在一个map的kv结构中v中存储的是一个map,即嵌套存储。</p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145122371.png" alt="image-20210917145122371"></p><h6 id="重要API-1"><a href="#重要API-1" class="headerlink" title="重要API"></a>重要API</h6><p><strong>PS：所有哈希的命令都是以’h’开头</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145435630.png" alt="image-20210917145435630"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145501710.png"></p><p><code>hexists</code> <code>hlen</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145743942.png" alt="image-20210917145743942"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145824058.png" alt="image-20210917145824058"></p><p><code>hmest</code> <code>hmset</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145921123.png" alt="image-20210917145921123"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917150011723.png" alt="image-20210917150011723"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917150113175.png" alt="image-20210917150113175"></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p><strong>哈希主要命令的时间复杂度</strong><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917151702749.png" alt="image-20210917151702749"></p><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><h6 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152349868.png" alt="image-20210917152349868"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152602670.png" alt="image-20210917152602670"></p><p>有序的、可以重复的，可以左右两边插入弹出</p><h6 id="重要API-2"><a href="#重要API-2" class="headerlink" title="重要API"></a>重要API</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152842988.png" alt="image-20210917152842988"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152955218.png" alt="image-20210917152955218"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917154211473.png" alt="image-20210917154211473"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917154530492.png" alt="image-20210917154530492"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155012745.png" alt="image-20210917155012745"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155227402.png" alt=" "></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155622451.png" alt="image-20210917155622451"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155851704.png" alt="image-20210917155851704"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917161129251.png" alt="image-20210917161129251"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917161524836.png" alt="image-20210917161524836"></p><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><h6 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917161659499.png" alt="image-20210917161659499"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917162536443.png" alt="image-20210917162536443"></p><p>集合是无序的、无重复的。支持集合间的操作。</p><h6 id="重要API-3"><a href="#重要API-3" class="headerlink" title="重要API"></a>重要API</h6><p>**所有的API都是以是S开头 **</p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917162820222.png" alt="image-20210917162820222"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917162940254.png" alt="image-20210917162940254"></p><p><strong>srandmember和spop的区别</strong></p><p><code>spop</code>是直接从集合里弹出</p><p><code>srandmember</code>并不会破坏集合的结构</p><p><strong>示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917163552620.png" alt="image-20210917163552620"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917163809999.png" alt="image-20210917163809999"></p><h5 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h5><h6 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917164900596.png" alt="image-20210917164900596"></p><p>可以根据数值作筛选等有序操作</p><h6 id="与其他结构进行对比"><a href="#与其他结构进行对比" class="headerlink" title="与其他结构进行对比"></a>与其他结构进行对比</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165038922.png" alt="image-20210917165038922"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165314748.png" alt="image-20210917165314748"></p><h6 id="重要API-4"><a href="#重要API-4" class="headerlink" title="重要API"></a>重要API</h6><p><strong>PS：有序集合都是以Z开头的命令</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165547094.png" alt="image-20210917165547094"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165921077.png" alt="image-20210917165921077"></p><p> <img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917170026404.png" alt="image-20210917170026404"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917170300211.png" alt="image-20210917170300211"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917170334858.png" alt="image-20210917170334858"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917171125461.png" alt="image-20210917171125461"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917171353523.png" alt="image-20210917171353523"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917172517628.png" alt="image-20210917172517628"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917172643001.png" alt="image-20210917172643001"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917172913994.png" alt="image-20210917172913994"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917173040148.png" alt="image-20210917173040148"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917175157232.png" alt="image-20210917175157232"> </p><hr><h4 id="Redis单线程的特点"><a href="#Redis单线程的特点" class="headerlink" title="Redis单线程的特点"></a>Redis单线程的特点</h4><p>命令执行时是类似队列、串行的</p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917114427993.png" alt="image-20210917114427993"></p><p>Redis使用单线程依靠纯内存、非阻塞IO、避免线程切换和竞态消耗的方式实现快速存取。</p><ul><li>一次只执行一条命令</li><li>拒绝长（慢）命令</li></ul><h1 id="Redis的客户端"><a href="#Redis的客户端" class="headerlink" title="Redis的客户端"></a>Redis的客户端</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h2><h3 id="Jdeis"><a href="#Jdeis" class="headerlink" title="Jdeis"></a>Jdeis</h3><p>根据Redis的规则用Java开发的客户端</p><p><strong>Maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Jedis直连</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个Jedis对象，该对象负责和指定Redis节点进行通信</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//Jedis执行set操作</span></span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>,world);</span><br><span class="line"><span class="comment">//Jedis执行get操作，value=&quot;world&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Jedis的有参构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jedis(String host,<span class="type">int</span> port,<span class="type">int</span> connectionTimeout,<span class="type">int</span> soTimeout)</span><br></pre></td></tr></table></figure><p><strong>PS：参数并非只有此4种</strong></p><ul><li>host:Redis节点的所在机器的IP</li><li>port：Redis节点的端口</li><li>connectionTimeout:客户端连接超时</li><li>soTimeout：客户端读写超时</li></ul><h3 id="Jedis连接池的使用"><a href="#Jedis连接池的使用" class="headerlink" title="Jedis连接池的使用"></a>Jedis连接池的使用</h3><h4 id="Jedis直连"><a href="#Jedis直连" class="headerlink" title="Jedis直连"></a>Jedis直连</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918100033846.png" alt="image-20210918100033846"></p><h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p><img src="http://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918100605012.png" alt="image-20210918100605012"></p><h5 id="Jedis-Pool的使用"><a href="#Jedis-Pool的使用" class="headerlink" title="Jedis Pool的使用"></a>Jedis Pool的使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化Jedis连接池，通常来讲JedisPool是单例的。</span></span><br><span class="line"><span class="type">GenericObjectPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericObjecPoolConfig</span>();</span><br><span class="line"><span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">jedisPool</span>(poolConfig,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1从连接池获取jedis对象</span></span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">//2执行操作</span></span><br><span class="line">    jedis.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果使用JedisPool,close操作不是关闭连接，代表归还连接池</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Jedis配置优化"><a href="#Jedis配置优化" class="headerlink" title="Jedis配置优化"></a>Jedis配置优化</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918111416016.png" alt="image-20210918111416016"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918111801336.png" alt="image-20210918111801336"></p><p> <img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918112111412.png" alt="image-20210918112111412"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918112225237.png" alt="image-20210918112225237"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918113306422.png" alt="image-20210918113306422"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918114005888.png" alt="image-20210918114005888"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918143103174.png" alt="image-20210918143103174"></p><h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918145254658.png" alt="image-20210918145254658"></p><p><strong>两点说明</strong></p><ol><li>慢查询发生在第3阶段</li><li>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</li></ol><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918150648685.png" alt="image-20210918150648685"></p><h4 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h4><p><code>slowlog get[n]</code> :获取慢查询队列</p><p><code>slowlog len</code> :获取慢查询队列长度</p><p><code>slowlog reset</code> :清空慢查询队列</p><h4 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h4><ul><li><p><code>slowlog-max-len </code> 不要设置过大，默认10ms，通常设置1ms</p></li><li><p><code>slowlog-log-slower-than</code>不要设置过小，通常设置1000左右</p></li><li><p>理解命令的生命周期</p></li><li><p>定期持久化慢查询</p></li></ul><h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918154330612.png" alt="image-20210918154330612"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918154400470.png" alt="image-20210918154400470"></p><p><strong>pipeline在Java上的实现</strong></p><ol><li><p>引用Jeids Jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用pipeline</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i*<span class="number">100</span>;j&lt;(i+<span class="number">1</span>)*<span class="number">100</span>;j++)&#123;</span><br><span class="line">    pipeline.hset(<span class="string">&quot;hashkey:&quot;</span> + j,<span class="string">&quot;field&quot;</span> + j,<span class="string">&quot;value&quot;</span> + j);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.syncAndReturnAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p><strong>类似发布-订阅模式</strong></p><ul><li>发布者</li><li>订阅者</li><li>频道</li></ul><p><strong>模型</strong><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918160436858.png" alt="image-20210918160436858"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161109745.png" alt="image-20210918161109745"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h5 id="publish-–-发布命令"><a href="#publish-–-发布命令" class="headerlink" title="publish – 发布命令"></a><strong>publish</strong> – 发布命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161635627.png" alt="image-20210918161635627"></p><h5 id="subcribe-–订阅命令"><a href="#subcribe-–订阅命令" class="headerlink" title="subcribe –订阅命令"></a><strong>subcribe</strong> –订阅命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe [channel] #一个或多个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161759698.png" alt="image-20210918161759698"></p><h5 id="unsubcribe–取消订阅命令"><a href="#unsubcribe–取消订阅命令" class="headerlink" title="unsubcribe–取消订阅命令"></a><code>unsubcribe</code>–取消订阅命令</h5><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161907362.png" alt="image-20210918161907362"></p><h5 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h5><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161958482.png" alt="image-20210918161958482"></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918162045388.png" alt="image-20210918162045388"></p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><ul><li><p>位图<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918162633926.png" alt="image-20210918162633926"></p><p><code>setbit</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918162832945.png" alt="image-20210918162832945"></p><p><code>getbit</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163042020.png" alt="image-20210918163042020"></p><p><code>bitcount</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163409217.png" alt="image-20210918163409217"></p><p><code>bitop</code><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163500888.png" alt="image-20210918163500888"></p><p><code>bitpos</code><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163736164.png" alt="image-20210918163736164"></p></li></ul><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><ul><li><p>基于HyperLogLog算法 — 极小空间完成独立数量统计</p></li><li><p>本质还是字符串</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><table><thead><tr><th>api</th><th>解释</th></tr></thead><tbody><tr><td><code>pfadd key element[element…]</code></td><td>向hyperloglog添加元素</td></tr><tr><td><code>pfcount key [key ...]</code></td><td>计算hyperloglog的独立总数</td></tr><tr><td><code>pfmerge destkey sourcekey [sourcekey...]</code></td><td>合并多个hyperloglog</td></tr></tbody></table></li></ul><p>​<img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165003646.png" alt="image-20210918165003646"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165141911.png" alt="image-20210918165141911"></p><h1 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>GEO(地理位置定位)：存储经纬度，计算两地距离，范围计算等。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>​<img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165421773.png" alt="image-20210918165421773"></p><h2 id="重要API-5"><a href="#重要API-5" class="headerlink" title="重要API"></a>重要API</h2><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165449507.png" alt="image-20210918165449507"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165515902.png" alt="image-20210918165515902"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165537502.png" alt="image-20210918165537502"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165548785.png" alt="image-20210918165548785"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165610315.png" alt="image-20210918165610315"></p><h1 id="PS：第4章看完"><a href="#PS：第4章看完" class="headerlink" title="PS：第4章看完"></a>PS：第4章看完</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis是什么&quot;&gt;&lt;a href=&quot;#Redis是什么&quot; class=&quot;headerlink&quot; title=&quot;Redis是什么&quot;&gt;&lt;/a&gt;Redis是什么&lt;/h1&gt;&lt;p&gt;它是一个用C写的单线程的非关系型的内存数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/stro</summary>
      
    
    
    
    <category term="技术" scheme="https://lyotoc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端" scheme="https://lyotoc.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="SQL" scheme="https://lyotoc.github.io/tags/SQL/"/>
    
    <category term="Redis" scheme="https://lyotoc.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
