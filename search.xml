<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2022/06/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2022/06/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是<a href="https://so.csdn.net/so/search?q=Lambda&spm=1001.2101.3001.7020">Lambda</a>表达式</h2><blockquote><p>Lambda是一个匿名函数，可以把<code>lambda表达式</code>理解为一段可以传递的代码</p></blockquote><h2 id="初见Lambda表达式"><a href="#初见Lambda表达式" class="headerlink" title="初见Lambda表达式"></a>初见Lambda表达式</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001163917413.png" alt="img"></p><p>r1是一个Runnable接口的匿名实现类的对象，r2是使用Lambda表达式来创建对象，两个对象的效果一样，但是r2的代码明显更加简洁。这就是Lambda表达式。</p><p>化简为Lambda表达式的原则：能省就省。上图中Runnable接口只有一个需要实现的方法（即run方法），所以我们不需要写方法名就可以确定方法名（这其实就是函数式接口），由于r2是Runnable接口的对象，所以我们也可以确定类名。所以就化简为了( )→System.out.print(“xxx”);</p><p>再看个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001163952338.png" alt="img"></p><p>我们如何把上面的代码化简为Lambda表达式呢？可以看到这里仅仅多了两个参数，所以我们把两个参数加上即可：</p><p>  <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164011376.png" alt="img"></p><p>我们还有一个更加简洁的版本：方法引用</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164029882.png" alt="img"></p><p>方法引用我们后面会讲，先介绍Lambda表达式：</p><h3 id="Lambda表达式写法"><a href="#Lambda表达式写法" class="headerlink" title="Lambda表达式写法"></a>Lambda表达式写法</h3><p>( xx,xx ) - &gt; 方法体</p><p>左边：接口中抽象方法的形参列表</p><p>右边：重写接口中抽象方法的方法体</p><p>Lambda表达式的本质：作为接口的一个实例（对象）</p><p>表达式共有六种使用情况</p><h4 id="1-无参，无返回值"><a href="#1-无参，无返回值" class="headerlink" title="1. 无参，无返回值"></a>1. 无参，无返回值</h4><p>这是我们前面的Runnable接口的例子。</p><h4 id="2-一个参数，无返回值"><a href="#2-一个参数，无返回值" class="headerlink" title="2. 一个参数，无返回值"></a>2. 一个参数，无返回值</h4><p>不使用Lambda表达式：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164050287.png" alt="img"></p><p>使用Lambda表达式：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116410432.png" alt="img"></p><p>Lambda表达式的方法体中，如果只有一条语句，那么大括号写不写都行。</p><h4 id="3-数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”"><a href="#3-数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”" class="headerlink" title="3. 数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”"></a>3. 数据类型可以省略，因为可由编译器推断得出，这称为“类型判断”</h4><p>还是上面Consumer的例子，由于Consumer中的泛型为<String>，编译器可以推断出参数类型为String，所以我们不需要在Lambda表达式的形参列表中声明String，</p><p>类型推断的另一个例子：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164137508.png" alt="img"></p><p>由于泛型中已经声明了String，我们就不需要在后面的&lt;&gt;中声明String了。</p><h4 id="4-Lambda表达式如果只有一个参数，那么参数的小括号可以省略"><a href="#4-Lambda表达式如果只有一个参数，那么参数的小括号可以省略" class="headerlink" title="4. Lambda表达式如果只有一个参数，那么参数的小括号可以省略"></a>4. Lambda表达式如果只有一个参数，那么参数的小括号可以省略</h4><p>还是Cosnumer的例子，省略小括号后：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164220606.png" alt="img"></p><h4 id="5-Lambda有多个参数，有返回值"><a href="#5-Lambda有多个参数，有返回值" class="headerlink" title="5. Lambda有多个参数，有返回值"></a>5. Lambda有多个参数，有返回值</h4><p><strong>不使用Lambda表达式：</strong><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116422960.png" alt="img"></p><p><strong>使用Lambda表达式：</strong><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164238120.png" alt="img"></p><p>由于类型推断，我们可以把o1和o2的类型省略。</p><p>如果实现的compare方法中有多个语句，那么我们不能省略方法体的大括号和return关键字：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164253242.png" alt="img"></p><h4 id="6-当Lambda方法体只有一条语句，那么return和大括号都可以省略"><a href="#6-当Lambda方法体只有一条语句，那么return和大括号都可以省略" class="headerlink" title="6. 当Lambda方法体只有一条语句，那么return和大括号都可以省略"></a>6. 当Lambda方法体只有一条语句，那么return和大括号都可以省略</h4><p>这就是上面的comparator例子：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164305622.png" alt="img"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Lambda表达式：(形参列表) - &gt; { 方法体 }</p><p>本质：接口的实例对象。</p><p><strong>对于接口的要求：要求此接口必须只声明了一个抽象方法（这就是函数式接口）。</strong>上面的例子中的接口，我们看源码的话会发现接口上都有一个注解*@FunctionalInterface*，表明这是一个函数式接口。这个注解仅仅是为了检验此接口是否为函数式接口，不加也行。</p><p>形参列表：参数类型可以省略；如果参数列表只有一个参数，那么小括号也可以省略，没有参数或者有一个以上的参数就不能省略小括号。</p><p>方法体：如果方法体只有一条执行语句，则可以省略大括号和return关键字。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>只声明了一个抽象方法的接口。java不仅支持面向对象编程（OOP）也可以面向函数编程（OOF）</p><p>Lambda表达式就是一个函数式接口的对象。</p><p>以前用匿名实现类表示的现在都可以用Lambda表达式来写。</p><h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><p>四大函数式接口指的是<code>Consumer</code>、<code>Function</code>、<code>Predicate</code>、<code>Supplier</code>，位于<code>java.util.function</code>包下</p><p>第一种：<strong>Consumer&lt;T&gt;</strong>:消费型接口      void accept(T t);</p><p>第二种：<strong>Supplier&lt;T&gt;</strong>:供给型接口      T get();</p><p>第三种：<strong>Function&lt;T,R&gt;</strong>:函数型接口 ，T为自变量，R为因变量     R apply(T t);</p><p>第四种：<strong>Predicate&lt;T&gt;</strong>:断言型接口 boolean test(T t)</p><p>消费型接口示例：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164346440.png" alt="img"></p><p>断言型接口示例：</p><p>定义一个方法，第二个参数为断言型接口，想要实现的功能为：基于某种规则pre，来筛选list中符合规则的字符串。<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164354200.png" alt="img"></p><p>筛选规则我们可以通过Lambda表达式来实现：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164400502.png" alt="img"></p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="使用情形"><a href="#使用情形" class="headerlink" title="使用情形"></a>使用情形</h3><p>当要传递给Lambda表达式方法体的操作，已经有实现的方法了，此时可以使用方法引用。</p><p>方法引用本质上就是Lambda表达式，即方法引用也是函数式接口的实例。</p><h3 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h3><p>类(或对象) : : 方法名</p><p>参数列表都不用写了</p><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><p>对于下面的情况1和情况2：<strong>要求接口中的抽象方法的形参列表和返回值，与方法引用的方法的形参列表和返回值都相同。而且本来我们Lambda表达式的方法体代码中正好用到了方法引用的方法，我们就可以使用方法引用来替换Lambda表达式。</strong></p><p>对于情况3，可以不满足上面的描述，具体往下看。</p><p>方法引用一共分为如下三种情况</p><h4 id="1-对象-非静态方法"><a href="#1-对象-非静态方法" class="headerlink" title="1. 对象 : : 非静态方法"></a>1. 对象 : : 非静态方法</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164411857.png" alt="img"></p><p>分析：Lambda表达式中的方法体为System.out.println(str)，然后调用con1的accept方法。我们发现PrintStream类中的println方法和accept方法参数列表和返回值都一样，我们可以理解为println方法已经实现了accept方法（传递给Lambda表达式方法体的操作，已经有实现的方法了），所以我们可以使用方法引用</p><p>再来看一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164417289.png" alt="img"></p><p>觉得难以理解没关系，这只是一种新的语法，逻辑上确实难以理解，用多了就懂了。</p><h4 id="2-类-静态方法"><a href="#2-类-静态方法" class="headerlink" title="2. 类 : : 静态方法"></a>2. 类 : : 静态方法</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164424105.png" alt="img"></p><p>再来一个示例：<img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164428981.png" alt="img"></p><h4 id="3-类-非静态方法（有难度）"><a href="#3-类-非静态方法（有难度）" class="headerlink" title="3. 类 : : 非静态方法（有难度）"></a>3. 类 : : 非静态方法（有难度）</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164437918.png" alt="img"></p><p>我们发现compare的两个参数，第一个参数可以当做调用者调用String类的compareTo方法，第二个参数仍然作为参数。这时就可以使用类：：非静态方法的形式。注意我们仍然不写compareTo的参数列表。</p><p>再看个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164443372.png" alt="img"></p><p>只有一个参数的时候，也可以用类：：非静态方法，apply方法唯一的一个参数当做getName方法的调用者。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><h3 id="1-无参构造器"><a href="#1-无参构造器" class="headerlink" title="1. 无参构造器"></a>1. 无参构造器</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164448820.png" alt="img"></p><p>可以看到Employee类的无参构造方法，和get方法一样没有参数，当new 无参构造方法( )的时候会返回一个Employee对象。当我们Lambda表达式的方法体中调用了new Employee( )的时候，就可以使用方法引用Employee : : new 。</p><h3 id="2-有参构造器"><a href="#2-有参构造器" class="headerlink" title="2. 有参构造器"></a>2. 有参构造器</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164454488.png" alt="img"></p><p>我们同样不能在方法引用上加参数，因为参数可以通过apply传递。</p><p>再来看一个两个参数的构造器：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20211001164501688.png" alt="img"></p><h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2021100116450739.png" alt="img"></p><p>返回值为一个数组对象，其他的和构造器引用类似。</p><p>把数组看做一个特殊的类，则写法与构造器引用一致。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>可以不会写，但是要能看懂，因为很多源码使用了Lambda表达式或者方法引用。</p><h1 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h1><h2 id="创建Stream的方式"><a href="#创建Stream的方式" class="headerlink" title="创建Stream的方式"></a>创建Stream的方式</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; stream();  返回一个顺序流</span></span><br><span class="line">Stream&lt;Employee&gt; stream0 = employees.stream();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; parallelStream(); 返回一个并行流</span></span><br><span class="line">Stream&lt;Employee&gt; stream1 = employees.parallelStream();</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java8中的Arrays的静态方法stream()可以获取数组流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Arrays.stream(arr);</span><br></pre></td></tr></table></figure><h3 id="Stream本身的of"><a href="#Stream本身的of" class="headerlink" title="Stream本身的of()"></a>Stream本身的of()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; intStream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="comment">//  public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line"><span class="comment">//遍历前10个偶数</span></span><br><span class="line"></span><br><span class="line">Stream.iterate(<span class="number">0</span>,t -&gt; t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成</span></span><br><span class="line"><span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h2><p>多个中间操作可以连接起来形成一个<strong>流水线</strong>，除非流水线线上触发终止操作，否则<strong>中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</strong></p><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filter()</td><td>接受Lambda，从流中排除某些元素</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成的hashCode()和equals()去除重复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前N个元素的流，若流中元素不足N个，则返回一个空流，与limit(n)互补</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line">list.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//distinct 去除重复元素</span></span><br><span class="line">list.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//limit 取集合中的前10个元素</span></span><br><span class="line">list.stream().limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//skip 跳过前10个元素并打印集合剩下的其它的元素</span></span><br><span class="line">list.stream().skip(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>map(Function f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td>mapToDouble(ToDoubleFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的DouleStream</td></tr><tr><td>mapToInt(ToIntFuction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的IntStream</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生新的LongStream</td></tr><tr><td>flatMap(Function f)</td><td>接收一个函数作为参数，将流中的每一个值都换成另一个流，然后把所有流都连接成一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map</span></span><br><span class="line">List&lt;String&gt; strs = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">strs.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"><span class="comment">//flatMap</span></span><br><span class="line"><span class="comment">//此时得到的是多个Stream组成的Stream</span></span><br><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream().map(API::formStringToStream);</span><br><span class="line">stream.forEach(item -&gt; item.forEach(System.out::println));</span><br><span class="line"><span class="comment">//若使用flatMap则会自动拆箱，对元素进行操作，得到的是一个内含元素的stream</span></span><br><span class="line">Stream&lt;Character&gt; stream1 = list.stream().flatMap(API::formStringToStream);</span><br><span class="line">stream1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">formStirngToStream</span><span class="params">(Stirng str)</span>&#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">for</span>(Character c : str.toCharArray())&#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sorted() 自然排序</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">10</span>,<span class="number">43</span>,<span class="number">65</span>,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">list.stream().sorted().froEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于未实现Comparable接口的类使用sorted会抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sorted(Comparator com) 定制排序</span></span><br><span class="line">List&lt;Employee&gt; employees = Employee.getEmployees();</span><br><span class="line">employees.stream.sorted((e1,e2) -&gt; Integer.compare(e1.getAge,e2.getAge)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="Stream的终止操作"><a href="#Stream的终止操作" class="headerlink" title="Stream的终止操作"></a>Stream的终止操作</h2><blockquote><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List,Integer,甚至是void。</p><p>流进行了终止操作后，不能再次使用。</p></blockquote><h3 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中的元素的总个数</td></tr><tr><td>max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>min(Comparator c)</td><td>返回流中的最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allMatch(Predicate p) 检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">// 是否所有的员工的年龄都大于18岁</span></span><br><span class="line"><span class="type">blooean</span> <span class="variable">allMatch</span> <span class="operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//anyMatch(Predicate p)  检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">//是否存在员工的工资大于 10000</span></span><br><span class="line"><span class="type">blooean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> employees.stream().anyMatch(e-&gt;e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//noneMatch(Predicate p)检查是否没有匹配所有元素</span></span><br><span class="line"><span class="comment">//是否存在员工姓“雷”</span></span><br><span class="line"><span class="type">boolean</span> employees.stream().noneMatch(e -&gt; e.getName().startWith(“雷”));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//findFirst()返回第一个元素</span></span><br><span class="line">Optional&lt;Employee&gt; employee = employees.stream().findFrist();</span><br><span class="line"><span class="comment">//findAny()返回当前流中的任意一个元素</span></span><br><span class="line">Optional&lt;Employee&gt; employee = employees.parallelStream().findAny();</span><br><span class="line"><span class="comment">//count()返回流中的元素的总个数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line"><span class="comment">//max(Comparator c)返回流中最大值</span></span><br><span class="line"><span class="comment">//返回最高的工资</span></span><br><span class="line">Optional&lt;Double&gt; maxSalary = employees.stream().map(Employee::getSalary).max(Double::compare);</span><br><span class="line"><span class="comment">//min(Comparator c)返回流中的最小值</span></span><br><span class="line"><span class="comment">//返回最低工资员工</span></span><br><span class="line">Optional&lt;Double&gt; minSalaryEmp = employees.stream().min((e1,e2) -&gt;Double.compare(e1.getSalary(),e2.getSalary()));</span><br><span class="line"><span class="comment">//forEach(Consumer c) 内部迭代</span></span><br><span class="line">employees.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">//使用集合的遍历操作</span></span><br><span class="line">employees.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduce(T iden, BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回T</span></span><br><span class="line"><span class="comment">//计算自然数的和</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>,Integer::sum);</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce(BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span></span><br><span class="line">Optional&lt;Double&gt; sumMoney = employees.stream().map(Employee::getSalary).reduce(Double::sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220622144546304.png" alt="image-20220622144546304"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20220622144706835.png" alt="image-20220622144706835"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">List&lt;Employee&gt; emps = employees.stream().filter(e-&gt;e.getSalary()&gt;<span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><blockquote><p>到目前为止，臭名昭著的空指针异常是导致Jva应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式米防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java8类库的一部分。Optional&lt;T&gt;类(Gava.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null,表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</p><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true,调用get()方法会返回该对象。</p></blockquote><p>● Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><ul><li><p><strong>创建Optional类对象的方法</strong></p><ul><li>Optional.of(Tt):创建一个Optional实例，t必须非空；</li><li>Optional.empty):创建一个空的Optional实例</li><li>Optional.ofNullable(T t):t可以为null</li></ul></li><li><p><strong>判断Optional容器中是否包含对象：</strong></p><ul><li>boolean isPresent():判断是否包含对象</li><li>void ifPresent(Consumer&lt;?super T&gt;consumer):如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ul></li><li><p><strong>获取Optional容器的对象：</strong></p><ul><li><p>Tget():如果调用对象包含值，返回该值，否则抛异常</p></li><li><p>T orElse(T other):如果有值则将其返回，否则返回指定的other对象。</p></li><li><p>T orElseGet( Supplier&lt;?extends T下other)：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</p></li><li><p>T orElseThrow(Supplier&lt;?extends X&gt;exceptionSupplier):如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s使用及理解</title>
      <link href="/2022/06/15/k8s%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%90%86%E8%A7%A3/"/>
      <url>/2022/06/15/k8s%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PART1-概念"><a href="#PART1-概念" class="headerlink" title="PART1 概念"></a>PART1 概念</h1><h2 id="K8S概述和特性"><a href="#K8S概述和特性" class="headerlink" title="K8S概述和特性"></a>K8S概述和特性</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>容器化集群管理系统</p></li><li><p>部署应用容器化</p></li><li><p>利于应用扩展</p></li><li><p>让部署容器化应用更加简洁和高效</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>自动装箱</p><ul><li>基于容器对应用运行环境的资源配置要求自动部署应用容器</li></ul></li><li><p>自我修复<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928101336750.png" alt="image-20200928101336750"></p><ul><li>容器失败时，会重启该容器</li><li>运行Node节点出现问题时，会重新调度、部署<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122112241092.png" alt="image-20201122112241092"></li><li>当容器未通过监控检查时，会关闭该容器直到正常运行，才会对外提供服务</li></ul></li><li><p>水平扩展</p><ul><li>通过简单的命令、用户UI界面或基于CPU等资源的使用情况，对应用容器扩容或剪裁<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122112301750.png" alt="image-20201122112301750"></li></ul></li><li><p>服务发现</p><ul><li>用户不需使用额外的服务发现机制，就能够基于Kubernetes自身能力实现服务发现和负载均衡<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928101711968.png" alt="image-20200928101711968"></li></ul></li><li><p>滚动更新</p><ul><li><p>可以根据应用的变化，对应用容器运行的应用进行一次或批量式更新</p><blockquote><p>添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用</p></blockquote></li></ul></li><li><p>版本回退</p><ul><li>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li></ul></li><li><p>密钥和配置管理</p><ul><li>在不需要重新构建镜像的情况下，可以部署和更新密钥及应用配置，类似热部署</li></ul></li><li><p>存储编排</p><ul><li>提供一次性任务、定时任务，满足批量数据处理和分析的场景</li></ul></li></ul><h2 id="K8S架构组件"><a href="#K8S架构组件" class="headerlink" title="K8S架构组件"></a>K8S架构组件</h2><h3 id="完整架构图"><a href="#完整架构图" class="headerlink" title="完整架构图"></a><strong>完整架构图</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928103059652.png" alt="完整的架构图"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110124821.png" alt="image-20200928110124821"></p><h3 id="架构细节"><a href="#架构细节" class="headerlink" title="架构细节"></a>架构细节</h3><p>K8S架构主要包含两部分：<code>Master</code>（<strong>主控节点</strong>）和 <code>node</code>（<strong>工作节点</strong>）</p><p><strong>master节点架构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122113057343.png" alt="master节点架构图"></p><p><strong>Node节点架构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122155629990.png" alt="image-20201122155629990"></p><p>k8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；</p><ul><li><strong>master</strong>：主控节点<ul><li>API Server：集群统一入口，以restful风格进行操作，同时交给etcd存储<ul><li>提供认证、授权、访问控制、API注册和发现等机制</li></ul></li><li>scheduler：节点的调度，选择node节点应用部署</li><li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li><li>etcd：存储系统，用于保存集群中的相关数据</li></ul></li><li><strong>Work node</strong>：工作节点<ul><li>Kubelet：master派到node节点代表，管理本机容器<ul><li>一个集群中每个节点上运行的代理，它保证容器都运行在Pod中</li><li>负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理</li></ul></li><li>kube-proxy：提供网络代理，负载均衡等操作</li></ul></li><li>容器运行环境【<strong>Container Runtime</strong>】<ul><li>容器运行环境是负责运行容器的软件</li><li>Kubernetes支持多个容器运行环境：Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。</li></ul></li><li>fluentd：是一个守护进程，它有助于提升 集群层面日志</li></ul><h2 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul><li><p>Pod是K8s中最小的单元</p></li><li><p>一组容器的集合</p></li><li><p>共享网络【一个Pod中的所有容器共享同一网络】</p></li><li><p>生命周期是短暂的（服务器重启后，就找不到了）</p></li></ul><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><ul><li>声明在Pod容器中可访问的文件目录</li><li>可以被挂载到Pod中一个或多个容器指定路径下</li><li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>确保预期的pod副本数量【ReplicaSet】</li><li>无状态应用部署【Deployment】<ul><li>无状态就是指，不需要依赖于网络或者ip</li></ul></li><li>有状态应用部署【StatefulSet】<ul><li>有状态需要特定的条件</li></ul></li><li>确保所有的node运行同一个pod 【DaemonSet】</li><li>一次性任务和定时任务【Job和CronJob】</li></ul><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><ul><li>定义一组Pod副本数目，版本等</li><li>通过控制器【Controller】维持Pod数目【自动回复失败的Pod】</li><li>通过控制器以指定的策略控制版本【滚动升级、回滚等】<br><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161601349.png" alt="image-20201122161601349"></li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul><li>定义一组pod的访问规则</li><li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li><li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161132055.png" alt="image-20201122161132055"></p><p>可以用来组合pod，同时对外提供服务</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>label：标签，用于对象资源查询，筛选</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122161713638.png" alt="image-20201122161713638"></p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制【鉴权、资源】</li><li>每个资源都属于一个namespace</li><li>同一个namespace所有资源不能重复</li><li>不同namespace可以资源名重复</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>我们通过Kubernetes的API来操作整个集群</p><p>同时我们可以通过 kubectl 、ui、curl 最终发送 http + json&#x2F;yaml 方式的请求给API Server，然后控制整个K8S集群，K8S中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述</p><p>如下：使用yaml部署一个nginx的pod</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122162612448.png" alt="image-20201122162612448"></p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201122163512535.png" alt="image-20201122163512535"></p><ul><li>通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APlserver写入etcd</li><li>此时Controller Manager通过API Server的监听资源变化的接口监听到此RC事件</li><li>分析之后，发现当前集群中还没有它所对应的Pod实例</li><li>于是根据RC里的Pod模板定义一个生成Pod对象，通过APIServer写入etcd</li><li>此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，然后通过API Server讲这一结果写入etcd中</li><li>目标Node上运行的Kubelet进程通过APiserver监测到这个”新生的Pod.并按照它的定义，启动该Pod并任劳任怨地负责它的下半生，直到Pod的生命结束</li><li>随后，我们通过Kubectl提交一个新的映射到该Pod的Service的创建请求</li><li>ControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的Endpoints信息，并通过APIServer写入到etod中，</li><li>接下来，所有Node上运行的Proxy进程通过APIServer查询并监听Service对象与其对应的Endponts信息，建立一个软件方式的负载均衡器来实现Service访问到后端Pod的流量转发功能</li></ul><h1 id="PART2-搭建K8S集群"><a href="#PART2-搭建K8S集群" class="headerlink" title="PART2  搭建K8S集群"></a>PART2  搭建K8S集群</h1><h2 id="搭建k8s环境平台规划"><a href="#搭建k8s环境平台规划" class="headerlink" title="搭建k8s环境平台规划"></a>搭建k8s环境平台规划</h2><h3 id="单master集群"><a href="#单master集群" class="headerlink" title="单master集群"></a>单master集群</h3><p>单个<code>master</code>节点，然后管理多个<code>node</code>节点</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110456495.png" alt="image-20200928110456495"></p><p><strong>该模型下存在较为明显且致命的缺点</strong></p><ul><li>由于是只有一个master节点做node节点的集群管理，在此模型下如果master节点发生故障宕机时，则无法对node节点做管理</li></ul><h3 id="多master集群"><a href="#多master集群" class="headerlink" title="多master集群"></a>多master集群</h3><p>多个master节点，管理多个node节点，同时中间多了一个负载均衡的过程</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200928110543829.png" alt="image-20200928110543829"></p><h3 id="服务器硬件配置要求"><a href="#服务器硬件配置要求" class="headerlink" title="服务器硬件配置要求"></a>服务器硬件配置要求</h3><h4 id="最低要求"><a href="#最低要求" class="headerlink" title="最低要求"></a>最低要求</h4><table><thead><tr><th>节点</th><th>要求</th></tr></thead><tbody><tr><td>master</td><td>2核 4G 20G</td></tr><tr><td>node</td><td>4核 8G 40G</td></tr></tbody></table><h3 id="部署Kubernetes集群主要的两种方式"><a href="#部署Kubernetes集群主要的两种方式" class="headerlink" title="部署Kubernetes集群主要的两种方式"></a>部署Kubernetes集群主要的两种方式</h3><h4 id="Kubeadm"><a href="#Kubeadm" class="headerlink" title="Kubeadm"></a>Kubeadm</h4><ol><li><p>介绍kubeadm是一个K8S部署工具，提供kubeadm init 和 kubeadm join，用于快速部署Kubernetes集群</p><p>官网地址：<a href="https://gitee.com/link?target=https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">点我传送</a></p></li></ol><h4 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h4><p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p><p>Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p><h3 id="Kubeadm部署集群"><a href="#Kubeadm部署集群" class="headerlink" title="Kubeadm部署集群"></a>Kubeadm部署集群</h3><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p><ul><li>创建一个Master 节点kubeadm init</li><li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li></ul><h3 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h3><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p><ul><li>一台或多台机器，操作系统为Centos7.X</li><li>硬件配置：2GB或更多GAM，2个CPU或更多CPU，硬盘30G</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>192.168.177.130</td></tr><tr><td>node1</td><td>192.168.177.131</td></tr><tr><td>node2</td><td>192.168.177.132</td></tr></tbody></table><p>然后开始在每台机器上执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭selinux</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久关闭</span></span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭swap</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时</span></span><br><span class="line">swapoff -a </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久关闭</span></span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据规划设置主机名【master节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8smaster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据规划设置主机名【node1节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8snode1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据规划设置主机名【node2节点操作】</span></span><br><span class="line">hostnamectl set-hostname k8snode2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在master添加hosts</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.177.130 k8smaster</span><br><span class="line">192.168.177.131 k8snode1</span><br><span class="line">192.168.177.132 k8snode2</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将桥接的IPv4流量传递到iptables的链</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效</span></span><br><span class="line">sysctl --system  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间同步</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装Docker-x2F-kubeadm-x2F-kubelet"><a href="#安装Docker-x2F-kubeadm-x2F-kubelet" class="headerlink" title="安装Docker&#x2F;kubeadm&#x2F;kubelet"></a>安装Docker&#x2F;kubeadm&#x2F;kubelet</h3><p>所有节点安装Docker&#x2F;kubeadm&#x2F;kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>首先配置一下Docker的阿里yum源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name=Docker CE Edge - \$basearch</span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后yum方式安装docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># yum安装</span><br><span class="line">yum -y install docker-ce</span><br><span class="line"></span><br><span class="line"># 查看docker版本</span><br><span class="line">docker --version  </span><br><span class="line"></span><br><span class="line"># 启动docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>配置docker的镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后重启docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="添加kubernetes软件源"><a href="#添加kubernetes软件源" class="headerlink" title="添加kubernetes软件源"></a>添加kubernetes软件源</h3><p>然后我们还需要配置一下yum的k8s软件源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="安装kubeadm，kubelet和kubectl"><a href="#安装kubeadm，kubelet和kubectl" class="headerlink" title="安装kubeadm，kubelet和kubectl"></a>安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装kubelet、kubeadm、kubectl，同时指定版本</span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"># 设置开机启动</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><h3 id="部署Kubernetes-Master【master节点】"><a href="#部署Kubernetes-Master【master节点】" class="headerlink" title="部署Kubernetes Master【master节点】"></a>部署Kubernetes Master【master节点】</h3><p>在 192.168.177.130 执行，也就是master节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094302491.png" alt="image-20200929094302491"></p><p>当我们出现下面的情况时，表示kubernetes的镜像已经安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094620145.png" alt="image-20200929094620145"></p><p>使用kubectl工具 【master节点操作】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>执行完成后，我们使用下面命令，查看我们正在运行的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20200929094933142.png" alt="2"></p><p>能够看到，目前有一个master节点已经运行了，但是还处于未准备状态</p><p>下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上</p><h3 id="加入Kubernetes-Node【Slave节点】"><a href="#加入Kubernetes-Node【Slave节点】" class="headerlink" title="加入Kubernetes Node【Slave节点】"></a>加入Kubernetes Node【Slave节点】</h3><p>下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点</p><p>执行在kubeadm init输出的kubeadm join命令：</p><blockquote><p>注意，以下的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</span><br></pre></td></tr></table></figure><p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><p>当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113165358663.png" alt="image-20201113165358663"></p><h3 id="部署CNI网络插件"><a href="#部署CNI网络插件" class="headerlink" title="部署CNI网络插件"></a>部署CNI网络插件</h3><p>上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载网络插件配置</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">##①首先下载v0.13.1-rc2-amd64 镜像</span><br><span class="line">##参考博客：https://www.cnblogs.com/pyxuexi/p/14288591.html</span><br><span class="line">##② 导入镜像，命令，，特别提示，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，重要的事情说3遍。不然抱错。如果没有操作，报错后，需要删除节点，重置，在导入镜像，重新加入才行。本地就是这样操作成功的！</span><br><span class="line">docker load &lt; flanneld-v0.13.1-rc2-amd64.docker</span><br><span class="line">#####下载本地，替换将image: quay.io/coreos/flannel:v0.13.1-rc2 替换为 image: quay.io/coreos/flannel:v0.13.1-rc2-amd64</span><br><span class="line"></span><br><span class="line"># 查看状态 【kube-system是k8s中的最小单元】</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure><p>运行后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113165929510.png" alt="image-20201113165929510"></p><p>运行完成后，我们查看状态可以发现，已经变成了Ready状态了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113194557147.png" alt="image-20201113194557147"></p><p>如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> master节点将该节点删除</span><br><span class="line"></span><br><span class="line">##20210223 yan 查阅资料添加###kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line"></span><br><span class="line">kubectl delete node k8snode1</span><br><span class="line"> </span><br><span class="line"># 然后到k8snode1节点进行重置</span><br><span class="line"> kubeadm reset</span><br><span class="line"># 重置完后在加入</span><br><span class="line">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</span><br></pre></td></tr></table></figure><h3 id="测试kubernetes集群"><a href="#测试kubernetes集群" class="headerlink" title="测试kubernetes集群"></a>测试kubernetes集群</h3><p>我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动</p><p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载nginx 【会联网拉取nginx镜像】</span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"># 查看状态</span><br><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p>如果我们出现Running状态的时候，表示已经成功运行了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113203537028.png" alt="image-20201113203537028"></p><p>下面我们就需要将端口暴露出去，让其它外界能够访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 暴露端口</span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line"># 查看一下对外的端口</span><br><span class="line">kubectl get pod,svc</span><br></pre></td></tr></table></figure><p>能够看到，我们已经成功暴露了 80端口 到 30529上</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113203840915.png" alt="image-20201113203840915"></p><p>我们到我们的宿主机浏览器上，访问如下地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.177.130:30529/</span><br></pre></td></tr></table></figure><p>发现我们的nginx已经成功启动了</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113204056851.png" alt="image-20201113204056851"></p><p>到这里为止，我们就搭建了一个单master的k8s集群</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20201113204158884.png" alt="image-20201113204158884"></p><h3 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h3><h4 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h4><p>在执行Kubernetes init方法的时候，出现这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</span><br></pre></td></tr></table></figure><p>是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可</p><h4 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h4><p>我们在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR Swap]: running with swap on is not supported. Please disable swap</span><br></pre></td></tr></table></figure><p>错误原因是我们需要关闭swap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 关闭swap</span><br><span class="line"># 临时</span><br><span class="line">swapoff -a </span><br><span class="line"># 临时</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h4 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h4><p>在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused</span><br></pre></td></tr></table></figure><p>解决方法，首先需要到 master 节点，创建一个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件夹</span><br><span class="line">mkdir /etc/systemd/system/kubelet.service.d</span><br><span class="line"></span><br><span class="line"># 创建文件</span><br><span class="line">vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line"># 添加如下内容</span><br><span class="line">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;</span><br><span class="line"></span><br><span class="line"># 重置</span><br><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><p>然后删除刚刚创建的配置目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.kube</span><br></pre></td></tr></table></figure><p>然后 在master重新初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5</span><br></pre></td></tr></table></figure><p>添加完成后，我们使用下面命令，查看节点是否成功添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h4 id="错误四"><a href="#错误四" class="headerlink" title="错误四"></a>错误四</h4><p>我们再执行查看节点的时候， kubectl get nodes 会出现问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;)</span><br></pre></td></tr></table></figure><p>这是因为我们之前创建的配置文件还存在，也就是这些配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>我们需要做的就是把配置文件删除，然后重新执行一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.kube</span><br></pre></td></tr></table></figure><p>然后再次创建一下即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME&#x2F;.kube 给移除掉，再次创建时就会出现问题了</p><h4 id="错误五"><a href="#错误五" class="headerlink" title="错误五"></a>错误五</h4><p>安装的时候，出现以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Another app is currently holding the yum lock; waiting for it to exit...</span><br></pre></td></tr></table></figure><p>是因为yum上锁占用，解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><h4 id="错误六"><a href="#错误六" class="headerlink" title="错误六"></a>错误六</h4><p>在使用下面命令，添加node节点到集群上的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb  --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span><br></pre></td></tr></table></figure><p>然后出现了这个错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8smaster ~]# kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb     --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span><br><span class="line">W1117 06:55:11.220907   11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p>出于安全考虑，Linux系统<strong>默认是禁止数据包转发</strong>的。所谓<strong>转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包</strong>。这通常就是路由器所要实现的功能。也就是说 <strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</strong> 文件的值不支持转发</p><ul><li>0：禁止</li><li>1：转发</li></ul><p>所以我们需要将值修改成1即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>修改完成后，重新执行命令即可</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM原理</title>
      <link href="/2022/06/14/JVM%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/14/JVM%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM原理"><a href="#JVM原理" class="headerlink" title="JVM原理"></a>JVM原理</h2><h3 id="Java内存区域的分配"><a href="#Java内存区域的分配" class="headerlink" title="Java内存区域的分配"></a>Java内存区域的分配</h3><p>JVM虚拟机内存模型实现规范：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/JVM1.8.png"></p><p>按线程是否共享分为以下区域：</p><p>所有线程共享的数据区：</p><ul><li><p>方法区（JVM规范中的一部分，不是实际的实现）: 存储每一个类的结构信息（运行时常量池、静态变量、方法数据、构造函数和普通方法的字节码、JIT编译后的代码)，没有要求使用垃圾回收因为回收效率太低。（运行时常量池：存放编译器生成的各种字面量和符号引用，在类加载后放到运行时常量池中）</p></li><li><p>堆区: 最大的一块区域，是大部分类实例、对象、数组分配内存的区域，没有限制只能将对象分配在堆，所以出现逃逸分析的技术</p></li></ul><p>每个线程都会有一块私有的数据区： </p><ul><li><p>虚拟机栈: 虚拟机栈与线程同时创建，每个方法在执行时在其中创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法返回地址。正常调用完成后恢复调用者的局部变量表、操作数栈、递增程序计数器来跳过刚才执行的指令，或抛出异常不将返回值返回给调用者</p></li><li><p>本地方法栈: 功能与虚拟机栈相同，为native方法服务</p></li><li><p>pc寄存器: 任意时刻线程只会执行一个方法的代码，如果不是native的，就存放当前正在执行的字节码指令的地址，如果是native，则是undefined</p></li></ul><p>以HotSpot虚拟机实现为例，Java8中内存区域如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655346980098.jpg"></p><p>与规范中的区别：</p><ul><li><p>直接内存：非Java标准，是JVM以外的本地内存，在Java4出现的NIO中，为了防止Java堆和Native堆之间往复的数据复制带来的性能损耗，此后NIO可以使用Native的方式直接在Native堆分配内存。JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。</p></li><li><p>元数据区（方法区的实现）：Java7以及之前是使用的永久代来实现方法区，大小是在启动时固定的。Java8中用元空间替代了永久代，元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性。元空间存储JIT即时编译后的native代码，可能还存在短指针数据区CCS</p></li><li><p>堆区: Java7之后运行时常量池从方法区移到这里，为Java8移除永久带的做好准备</p></li></ul><h3 id="Java对象不都是分配在堆上"><a href="#Java对象不都是分配在堆上" class="headerlink" title="Java对象不都是分配在堆上"></a>Java对象不都是分配在堆上</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸是指在某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收。由于其被其它变量引用，由于无法回收，即称为逃逸。</p><p>逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁。</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><ul><li><p>加载（获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象）</p></li><li><p>验证（验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全）</p></li><li><p>准备（为类变量分配内存并设置初始值）</p></li><li><p>解析（将常量池的符号引用替换为直接引用，符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针）</p></li><li><p>初始化（执行类构造器、类变量赋值、静态语句块）</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>启动类加载器：用C++语言实现，是虚拟机自身的一部分，它负责将 <JAVA_HOME>&#x2F;lib路径下的核心类库，无法被Java程序直接引用<br>扩展类加载器：用Java语言实现，它负责加载<JAVA_HOME>&#x2F;lib&#x2F;ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用<br>系统类加载器：用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用</p><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>定义：如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是<strong>双亲委派模式</strong>。</p><p>优点：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次防止恶意覆盖Java核心API。</p><p>三次大型破坏双亲委派模式的事件：</p><ul><li><p>在双亲委派模式出来之前，用户继承ClassLoader就是为了重写loadClass方法，但双亲委派模式需要这个方法，所以1.2之后添加了findClass供以后的用户重写</p></li><li><p>如果基础类要调回用户的代码，如JNDI&#x2F;JDBC需要调用ClassPath下的自己的代码来进行资源管理，Java团队添加了一个线程上下文加载器，如果该加载器没有被设置过，那么就默认是应用程序类加载器</p></li><li><p>为了实现代码热替换，OSGi是为了实现自己的类加载逻辑，用平级查找的逻辑替换掉了向下传递的逻辑。但其实可以不破坏双亲委派逻辑而是自定义类加载器来达到代码热替换。比如<a href="https://www.cnblogs.com/pfxiong/p/4070462.html">这篇文章</a></p></li></ul><h3 id="内存分配（堆上的内存分配）"><a href="#内存分配（堆上的内存分配）" class="headerlink" title="内存分配（堆上的内存分配）"></a>内存分配（堆上的内存分配）</h3><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/1655346667997.jpg"></p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><h5 id="进入条件"><a href="#进入条件" class="headerlink" title="进入条件"></a>进入条件</h5><p>优先选择在新生代的Eden区被分配。</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h5 id="进入条件-1"><a href="#进入条件-1" class="headerlink" title="进入条件"></a>进入条件</h5><ul><li><p>大对象，-XX:PretenureSizeThreshold 大于这个参数的对象直接在老年代分配，来避免新生代GC以及分配担保机制和Eden与Survivor之间的复制</p></li><li><p>经过第一次Minor GC仍然存在，能被Survivor容纳，就会被移动到Survivor中，此时年龄为1，当年龄大于预设值就进入老年代  </p></li><li><p>如果Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象进入老年代  </p></li><li><p>如果Survivor空间无法容纳新生代中Minor GC之后还存活的对象</p></li></ul><h3 id="GC回收机制"><a href="#GC回收机制" class="headerlink" title="GC回收机制"></a>GC回收机制</h3><h4 id="回收对象"><a href="#回收对象" class="headerlink" title="回收对象"></a>回收对象</h4><p>不可达对象：通过一系列的GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时则此对象是不可用的。<br>GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。</p><p>彻底死亡条件：<br>条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。<br>条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。</p><h4 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h4><p>新生代因为每次GC都有大批对象死去，只需要付出少量存活对象的复制成本且无碎片所以使用“复制算法”<br>老年代因为存活率高、没有分配担保空间，所以使用“标记-清理”或者“标记-整理”算法</p><p>复制算法：将可用内存按容量划分为Eden、from survivor、to survivor，分配的时候使用Eden和一个survivor，Minor GC后将存活的对象复制到另一个survivor，然后将原来已使用的内存一次清理掉。这样没有内存碎片。<br>标记-清除：首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象。会产生大量碎片，导致无法分配大对象从而导致频繁GC。<br>标记-整理：首先标记出所有需要回收的对象，让所有存活的对象向一端移动。</p><h4 id="Minor-GC条件"><a href="#Minor-GC条件" class="headerlink" title="Minor GC条件"></a>Minor GC条件</h4><p>当Eden区空间不足以继续分配对象，发起Minor GC。</p><h4 id="Full-GC条件"><a href="#Full-GC条件" class="headerlink" title="Full GC条件"></a>Full GC条件</h4><ul><li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行</p></li><li><p>老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）</p></li><li><p>方法区空间不足</p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>串行收集器Serial是最古老的收集器，只使用一个线程去回收，可能会产生较长的停顿</p><p>新生代使用Serial收集器<code>复制</code>算法、老年代使用Serial Old<code>标记-整理</code>算法</p><p>参数：<code>-XX:+UseSerialGC</code>，默认开启<code>-XX:+UseSerialOldGC</code></p><h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><p>并行收集器Parallel关注<strong>可控的吞吐量</strong>，能精确地控制吞吐量与最大停顿时间是该收集器最大的特点，也是1.8的Server模式的默认收集器，使用多线程收集。ParNew垃圾收集器是Serial收集器的多线程版本。</p><p>新生代<code>复制</code>算法、老年代<code>标记-整理</code>算法</p><p>参数：<code>-XX:+UseParallelGC</code>，默认开启<code>-XX:+UseParallelOldGC</code></p><h3 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h3><p>并发收集器CMS是以<strong>最短停顿时间</strong>为目标的收集器。G1关注能在大内存的前提下精确控制<strong>停顿时间</strong>且垃圾回收效率高。</p><p>CMS针对老年代，有初始标记、并发标记、重新标记、并发清除四个过程，标记阶段会Stop The World，使用<code>标记-清除</code>算法，所以会产生内存碎片。</p><p>参数：<code>-XX:+UseConcMarkSweepGC</code>，默认开启<code>-XX:+UseParNewGC</code></p><p>G1将堆划分为多个大小固定的独立区域，根据每次允许的收集时间优先回收垃圾最多的区域，使用<code>标记-整理</code>算法，是1.9的Server模式的默认收集器</p><p>参数：<code>-XX:+UseG1GC</code></p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互</p><p>STW总会发生，不管是新生代还是老年代，比如CMS在初始标记和重复标记阶段会停顿，G1在初始标记阶段也会停顿，所以并不是选择了一款停顿时间低的垃圾收集器就可以避免STW的，我们只能尽量去减少STW的时间。</p><p>那么为什么一定要STW？因为在定位堆中的对象时JVM会记录下对所有对象的引用，如果在定位对象过程中，有新的对象被分配或者刚记录下的对象突然变得无法访问，就会导致一些问题，比如部分对象无法被回收，更严重的是如果GC期间分配的一个GC Root对象引用了准备被回收的对象，那么该对象就会被错误地回收。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a><a href="https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ">Java内存模型</a></h2><p>定义：JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性</p><p>实现：volatile、synchronized、final、concurrent包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字</p><p>主内存：所有变量都保存在主内存中<br>工作内存：每个线程的独立内存，保存了该线程使用到的变量的主内存副本拷贝，线程对变量的操作必须在工作内存中进行</p><p>每个线程都有自己的本地内存共享副本，如果A线程要更新主内存还要让B线程获取更新后的变量，那么需要：</p><ul><li><p>将本地内存A中更新共享变量</p></li><li><p>将更新的共享变量刷新到主内存中</p></li><li><p>线程B从主内存更新最新的共享变量</p></li></ul><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a><a href="https://www.cnblogs.com/chenssy/p/6393321.html">happens-before</a></h2><p>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before。特别关注在多线程之间的内存可见性。</p><p>它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。</p><ul><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p></li><li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</p></li><li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p></li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>前提：在进行GC优化之前，需要确认项目的架构和代码等已经没有优化空间</p><p>目的：优化JVM垃圾收集性能从而增大吞吐量或减少停顿时间，让应用在某个业务场景上发挥最大的价值。吞吐量是指应用程序线程用时占程序总用时的比例。暂停时间是应用程序线程让与GC线程执行而完全暂停的时间段</p><p>对于交互性web应用来说，一般都是减少停顿时间，所以有以下方法：</p><ul><li><p>如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大</p></li><li><p>让大对象进入年老代。可以使用参数-XX:PetenureSizeThreshold 设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配</p></li><li><p>设置对象进入年老代的年龄。如果对象每经过一次 GC 依然存活，则年龄再加 1。当对象年龄达到阈值时，就移入年老代，成为老年对象</p></li><li><p>使用关注系统停顿的 CMS 回收器</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer</title>
      <link href="/2022/06/07/%E5%89%91%E6%8C%87Offer/"/>
      <url>/2022/06/07/%E5%89%91%E6%8C%87Offer/</url>
      
        <content type="html"><![CDATA[<h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h3><p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/"><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></a></p><blockquote><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><p>方法一：新建一个数组并利用index记录每个元素出现的次数，大于1则返回该数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">     <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">         arr[num]++;</span><br><span class="line">         <span class="keyword">if</span>(arr[num] &gt; <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用散列表的特征，hashset.add()元素重复时返回fasle,此时返回该元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></p><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。</p><p>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p></blockquote><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] nums : matrix) &#123;</span><br><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(nums, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：获得当前下标位置的元素 num<br>如果 num 和 target 相等，返回 true<br>如果 num 大于 target，列下标减 1<br>如果 num 小于 target，行下标加 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, column = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> matrix[row][column];</span><br><span class="line">            <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                column--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h3><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p><blockquote><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> a : s.toCharArray())&#123;</span><br><span class="line">           <span class="keyword">if</span>(a == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">               sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               sb.append(a);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></p><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"> 输入：head = [1,3,2]</span><br><span class="line"> 输出：[2,3,1]</span><br></pre></td></tr></table></figure></blockquote><p>方法一：递归回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[--size];</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="type">int</span>[] nums = reversePrint(head.next);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - size--;</span><br><span class="line">        nums[index] = head.val;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用栈的特性输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line"><span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h3><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></p><p><strong>方法一</strong></p><script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script> <video id="video" controls loop="false" width="100%"></video> <script>   var video = document.getElementById('video');   if(Hls.isSupported()) {   var hls = new Hls();   hls.loadSource('https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/2022_06_0812_37_16/index.m3u8');   hls.attachMedia(video);   hls.on(Hls.Events.MANIFEST_PARSED,function() {   video.play(); }); } else if (video.canPlayType('application/vnd.apple.mpegurl')) {   video.src = 'https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/2022_06_0812_37_16/index.m3u8';   video.addEventListener('loadedmetadata',function() {   video.play(); }); } </script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; inOrderindexMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        inOrderindexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            inOrderindexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, </span></span><br><span class="line"><span class="params">                                    <span class="type">int</span>[] inorder, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preorder[preLeft];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> inOrderindexMap.get(rootValue);</span><br><span class="line"></span><br><span class="line">        root.left = buildTree(preorder, preLeft + <span class="number">1</span>, preLeft + pIndex - inLeft, inorder, inLeft, pIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, preLeft + pIndex - inLeft + <span class="number">1</span>, preRight, inorder, pIndex + <span class="number">1</span>, inRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>这道题是一道典型的递归解法的算法题，我们可以：</p><blockquote><p>先按照前序遍历和中序遍历的特点，来模拟重建二叉树<br>在模拟的过程中，看看是否符合递归的三个特点：</p><ol><li>这个问题能不能拆分成若干个子问题，子问题解决了，那么这个问题就解决了</li><li>所有子问题的求解方法是不是和大问题的求解方法是一样的</li><li>是不是存在知道结果的最小子问题</li></ol><p>在符合上面的递归特点后，我们就专门看一个子问题的解法，根据一个子问题的解法 来实现递归的代码</p></blockquote><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h3><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></p><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inStack ;</span><br><span class="line">    Stack&lt;Integer&gt; outStack ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="built_in">this</span>.outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">     inStack.push(value);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">if</span>(inStack.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          in2Out();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in2Out</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用两个栈实现入列及出列，分别对两个栈做不同分工。</p></blockquote><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h3><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></p><blockquote><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一 动态规划</strong></p><blockquote><p>斐波那契数的边界条件是 F(0)&#x3D;0F(0)&#x3D;0F(0)&#x3D;0 和 F(1)&#x3D;1F(1)&#x3D;1F(1)&#x3D;1。当 n&gt;1n&gt;1n&gt;1 时，每一项的和都等于前两项的和，因此有如下递推关系：</p><p>F(n)&#x3D;F(n−1)+F(n−2)F(n)&#x3D;F(n-1)+F(n-2) F(n)&#x3D;F(n−1)+F(n−2)</p><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0)F(0)F(0) 和 F(1)F(1)F(1)。</p><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)O(n)O(n) 的实现。由于 F(n)F(n)F(n) 只和 F(n−1)F(n-1)F(n−1) 与 F(n−2)F(n-2)F(n−2) 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 O(1)O(1)O(1)。如下的代码中给出的就是这种实现。</p><p>计算过程中，答案需要取模 1e9+7。</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/10_I_fig1.gif" alt="实现思想"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = (p + q) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：矩阵快速幂</strong></p><p>方法一的时间复杂度是 O(n)O(n)O(n)。使用矩阵快速幂的方法可以降低时间复杂度。</p><p>首先我们可以构建这样一个递推关系：<br>$$<br>\begin{bmatrix}1&amp;1\\1&amp;0 \end{bmatrix}​\begin{bmatrix}F(n)\\F(n−1) \end{bmatrix}​&#x3D;\begin{bmatrix}F(n)+F(n−1)\\F(n)\end{bmatrix}&#x3D;\begin{bmatrix}F(n+1)\\F(n)\end{bmatrix}​<br>$$<br>因此：<br>$$<br>\begin{bmatrix}F(n+1)\\F(n)\end{bmatrix} &#x3D; \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^n &#x3D; \begin{bmatrix} F(1)\\F(0)\end{bmatrix}<br>$$<br>令：<br>$$<br>M&#x3D;\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}<br>$$<br>因此只要我们能快速计算矩阵 M 的 n 次幂，就可以得到 F(n) 的值。如果直接求取<code>M^n</code>，时间复杂度是 O(n)，可以定义矩阵乘法，然后用快速幂算法来加速这里 <code>M^n</code> 的求取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span>[][] res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] pow(<span class="type">int</span>[][] a, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] multiply(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = (<span class="type">int</span>) (((<span class="type">long</span>) a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + (<span class="type">long</span>) a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]) % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h3><p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p><code>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><p><strong>方法一 动态规划</strong></p><blockquote><p>该题和上题一致，属于是斐波那契数列的变种。不过起始值是从1开始的</p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/108249e4d62d429f9cd6cab5bbd6afca581ee61c7d762a4c8ea0c62e08e10762-Picture13.png" alt="青蛙跳台阶"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % mod;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的用法</title>
      <link href="/2022/06/02/git%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2022/06/02/git%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Git的用法"><a href="#Git的用法" class="headerlink" title="Git的用法"></a>Git的用法</h2><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><h4 id="仓库创建"><a href="#仓库创建" class="headerlink" title="仓库创建"></a>仓库创建</h4><p>​      打开需创路径，<code>mkdir &lt;file name&gt;</code>创建文件夹<br>​      <code>pwd</code> 查看目前所在路径<br>​      <code>git init </code>使用当前路径作为仓库的master</p><h4 id="提交-amp-查看"><a href="#提交-amp-查看" class="headerlink" title="提交&amp;查看"></a>提交&amp;查看</h4><p>​      <code>git add &lt;file name&gt;</code> 添加至暂存区<br>​      <code>git commit -m &quot;描述&quot;</code> 提交至版本库<br>​      <code>git status</code>查看暂存区状态<br>​     <code> git diff</code> 比对工作区与暂存区的文件修改处在哪<br>​      <code>git log</code> 查看版本库修改日志</p><h4 id="版本回退-amp-退回"><a href="#版本回退-amp-退回" class="headerlink" title="版本回退&amp;退回"></a>版本回退&amp;退回</h4><p>​      <code>git reset --hard ^HEAD</code> 退回上一版本<br>​      <code>git reset --hard ~num</code> 退回前num版本（num&#x3D;前~版本）<br>​      <code>git reset --hard &lt;版本号&gt;</code>回退到该版本<br>​      <code>git rflog</code> 提交版本库的日志</p><h4 id="工作区-amp-暂存区修改撤销及删除"><a href="#工作区-amp-暂存区修改撤销及删除" class="headerlink" title="工作区&amp;暂存区修改撤销及删除"></a>工作区&amp;暂存区修改撤销及删除</h4><p>​      <code>git checkout --&lt;file name&gt; </code>撤回工作区修改<br>​      <code>git reset HEAD&lt;file name &gt; </code>撤销暂存区修改，退回至工作区<br>​     <code> git restore &lt;file name &gt;</code> 撤销修改<br>​      <code>rm &lt;file name&gt;</code>删除文件 记得提交</p><h3 id="远程版本库的创建-amp-克隆"><a href="#远程版本库的创建-amp-克隆" class="headerlink" title="远程版本库的创建&amp;克隆"></a>远程版本库的创建&amp;克隆</h3><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><h5 id="首次连接远程库准备"><a href="#首次连接远程库准备" class="headerlink" title="首次连接远程库准备"></a>首次连接远程库准备</h5><p>​        创建 SSH key<br>​          <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><br>​        <code>add sshkey</code><br>​          用户主目录里找到.ssh目录，在Github SSHkey页面粘贴id_rsa.pub内容<br>​        该过程在github中进行</p><h5 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h5><p>​        在<code>github</code>新建一个仓库<br>​        本地<code>bash</code>使用<code>command：git remote add origin https://github.com/username/repositories.git </code></p><blockquote><p>username为用户的github用户名，repositories为新建的仓库名称 </p></blockquote><h5 id="本地库推送至远程库"><a href="#本地库推送至远程库" class="headerlink" title="本地库推送至远程库"></a>本地库推送至远程库</h5><p>​        首次推送：<code>git push -u origin master</code>(master会把本地库的master分支与远程库中的master分支关联在一起)<br>​        以后推送：<code>git push origin</code></p><h5 id="远程库的克隆"><a href="#远程库的克隆" class="headerlink" title="远程库的克隆"></a>远程库的克隆</h5><h6 id="克隆远端库"><a href="#克隆远端库" class="headerlink" title="克隆远端库"></a>克隆远端库</h6><p>​          <code>git clone git@httpadress.git  </code><em>使用http协议多</em><br>​          <strong>有几种git的clone方式，ssh最快</strong></p><p>​ <strong>远程仓库的版本回退</strong></p><p><code>git checkout &lt;commitID&gt;</code></p><h5 id="私人服务器远程仓库"><a href="#私人服务器远程仓库" class="headerlink" title="私人服务器远程仓库"></a>私人服务器远程仓库</h5>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="/2022/06/02/SSM%E6%95%B4%E5%90%88/"/>
      <url>/2022/06/02/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="spring中各个jar包的用途和他们之间的关系"><a href="#spring中各个jar包的用途和他们之间的关系" class="headerlink" title="spring中各个jar包的用途和他们之间的关系"></a>spring中各个jar包的用途和他们之间的关系</h1><p> 除了spring.jar文件，Spring还包括有其它13个独立的jar包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar包，而不必引入整个spring.jar的所有类文件。</p><p>(1) spring-core.jar</p><p>这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。</p><p>(2) spring-beans.jar</p><p>这个jar文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control &#x2F; Dependency Injection（IoC&#x2F;DI）操作相关的所有类。如果应用只需基本的IoC&#x2F;DI支持，引入spring-core.jar及spring-beans.jar文件就可以了。</p><p>(3) spring-aop.jar</p><p>这个jar文件包含在应用中使用Spring的AOP特性时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。</p><p>(4) spring-context.jar</p><p>　　这个jar文件为Spring核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如Velocity、FreeMarker、JasperReports集成的类，以及校验Validation方面的相关类。</p><p>(5) spring-dao.jar</p><p>　　这个jar文件包含Spring DAO、Spring Transaction进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。</p><p>(6) spring-hibernate.jar</p><p>　　这个jar文件包含Spring对Hibernate 2及Hibernate 3进行封装的所有类。</p><p>(7) spring-jdbc.jar</p><p>　　这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。</p><p>(8) spring-orm.jar</p><p>　　这个jar文件包含Spring对DAO特性集进行了扩展，使其支持 iBATIS、JDO、OJB、TopLink，因为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包。</p><p>(9) spring-remoting.jar</p><p>　　这个jar文件包含支持EJB、JMS、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。</p><p>(10) spring-support.jar</p><p>　　这个jar文件包含支持缓存Cache（ehcache）、JCA、JMX、邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类。</p><p>(11) spring-web.jar</p><p>　　这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。</p><p>(12) spring-webmvc.jar</p><p>　　这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。</p><p>(13) spring-mock.jar</p><p>　　这个jar文件包含Spring一整套mock类来辅助应用的测试。Spring测试套件使用了其中大量mock类，这样测试就更加简单。模拟HttpServletRequest和HttpServletResponse类在Web应用单元测试是很方便的。</p><p>如何选择这些发布包，决定选用哪些发布包其实相当简单。</p><p> 如果你正在构建Web应用并将全程使用Spring，那么最好就使用单个全部的spring.jar文件；</p><p> 如果你的应用仅仅用到简单的Inversion of Control &#x2F; Dependency Injection（IoC&#x2F;DI）容器，那么只需spring-core.jar与spring-beans.jar即可；</p><p> 如果你对发布的大小要求很高，那么就得精挑细选了，只取包含自己所需特性的jar文件了。</p><p>采用独立的发布包你可以避免包含自己的应用不需要的全部类。当然你可以采用其它的一些工具来设法令整个应用包变小，节省空间的重点在于准确地找出自己所需的Spring依赖类，然后合并所需的类与包就可以了。</p><p> Eclispe有个插件叫ClassPath Helper可以帮你找找所依赖的类。</p><p>Spring包依赖说明:</p><ol><li><p>spring-core.jar需commons-collections.jar，spring-core.jar是以下其它各个的基本。</p></li><li><p>spring-beans.jar需spring-core.jar，cglib-nodep-2.1_3.jar</p></li><li><p>spring-aop.jar需spring-core.jar，spring-beans.jar，cglib-nodep-2.1_3.jar，aopalliance.jar</p></li><li><p>spring-context.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，commons-collections.jar，aopalliance.jar</p></li><li><p>spring-dao.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-context.jar</p></li><li><p>spring-jdbc.jar需spring-core.jar，spring-beans.jar，spring-dao.jar</p></li><li><p>spring-web.jar需spring-core.jar，spring-beans.jar，spring-context.jar</p></li><li><p>spring-webmvc.jar需spring-core.jar&#x2F;spring-beans.jar&#x2F;spring-context.jar&#x2F;spring-web.jar</p></li><li><p>spring-hibernate.jar需spring-core.jar，spring- beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring- orm.jar，spring-web.jar，spring-webmvc.jar</p></li><li><p>spring-orm.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring-web.jar，spring-webmvc.jar</p></li><li><p>spring-remoting.jar需spring-core.jar，spring-beans.jar，spring- aop.jar，spring-dao.jar，spring-context.jar，spring-web.jar，spring- webmvc.jar</p></li><li><p>spring-support.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar</p></li><li><p>spring-mock.jar需spring-core.jar，spring-beans.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar</p></li></ol><h4 id="主流连接池"><a href="#主流连接池" class="headerlink" title="主流连接池"></a>主流连接池</h4><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20210221090446427.png" alt="image-20210221090446427"></p><p><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/image-20210221090510773.png" alt="image-20210221090510773"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC注解及其它</title>
      <link href="/2022/06/02/SpringMVC%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%AE%83/"/>
      <url>/2022/06/02/SpringMVC%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC注解及其他"><a href="#SpringMVC注解及其他" class="headerlink" title="SpringMVC注解及其他"></a>SpringMVC注解及其他</h2><h5 id="Controller注解的实现"><a href="#Controller注解的实现" class="headerlink" title="@Controller注解的实现"></a><code>@Controller</code>注解的实现</h5><blockquote><p> Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现该接口的类获得控制器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">   <span class="comment">//处理请求且返回一个模型与视图对象</span></span><br><span class="line">   ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h4><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><h4 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h4><p><strong>概念</strong></p><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>功能</strong></p><p>资源：互联网所有的事物都可以被抽象为资源</p><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p><p>分别对应 添加、 删除、修改、查询。</p><p><strong>传统方式操作资源</strong>  ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p><p>​<a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p><p>​<a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p><p>​<a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p><p>​<a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p><p><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p><p>​<a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p><p>​<a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p><p>​<a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p><p>​<a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestFulController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//映射访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> p1, <span class="meta">@PathVariable</span> <span class="type">int</span> p2, Model model)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> p1+p2;</span><br><span class="line">        <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果：&quot;</span>+result);</span><br><span class="line">        <span class="comment">//返回视图位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用method属性指定请求类型</strong></p><p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p><p><a href="https://mp.weixin.qq.com/s/1d_PAk2IIp-WWX2eBbU3a">数据处理及跳转 </a></p><h4 id="post提交数据再返回乱码问题"><a href="#post提交数据再返回乱码问题" class="headerlink" title="post提交数据再返回乱码问题"></a>post提交数据再返回乱码问题</h4><p><strong>可以自定义编码过滤器</strong></p><p>编写Filter类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter</span> <span class="keyword">implements</span> <span class="title class_">javax</span>.servlet.Filter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        servletResponse.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);<span class="comment">//继续传递数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在web.xml文件中注册并配置映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.coder.Filter.Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SpringMVC提供的编码过滤器</strong></p><p>在web.xml中配置即可（修改了xml文件需要重启服务器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p><p>处理方法 :</p><p>1、修改tomcat配置文件 ：设置编码！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">           connectionTimeout=&quot;20000&quot;</span><br><span class="line">           redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>2、自定义过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//处理response的字符编码</span></span><br><span class="line">        HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">        myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 对request包装增强</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">myrequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequest</span>(httpServletRequest);</span><br><span class="line">        chain.doFilter(myrequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="comment">//是否编码的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> hasEncode;</span><br><span class="line">    <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">getParameterMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先获得请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// post请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理post乱码</span></span><br><span class="line">                request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// get请求</span></span><br><span class="line">            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">                <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                    String[] values = parameterMap.get(parameterName);</span><br><span class="line">                    <span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 处理get乱码</span></span><br><span class="line">                                values[i] = <span class="keyword">new</span> <span class="title class_">String</span>(values[i]</span><br><span class="line">                                        .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hasEncode = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取一个值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取所有值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展：小黄鸭调试法"><a href="#扩展：小黄鸭调试法" class="headerlink" title="扩展：小黄鸭调试法"></a>扩展：小黄鸭调试法</h3><p>场景一：<em>我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。</em></p><p>场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。</p><p>其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JOmNdhqNbrRK9XaseXIDsu4MibRVpZicicSVRRjb0lAblXjlHHppY3gSBn8iaTsa2oLEMO9S3bPCDHoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC原理</title>
      <link href="/2022/06/02/SpringMVC%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/02/SpringMVC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring-MVC"></a>Spring-MVC</h1><blockquote><p><code>MVC</code>即是**模型(Model)<strong>、</strong>视图(View)<strong>、</strong>控制器(Controller)**的简写，是一种软件设计规范。</p></blockquote><p>之前最典型的就是JSP+servlet+javabean的模式</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIXW7Wmm9KVEV1FXUfJMD0KzuYZ7ic5UHggsZDAzyYyrd4pLvnBIVM5zA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="MVC闭环"></p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>用pom项目依赖导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Springmvc json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>建立一个Moudle</strong></p><p>​PS：Project中创建modle项目可以删除<strong>scr</strong>并重建<code>moudle</code>，选择可以原生的Maven项目生成取消勾选<code>Create from archetype</code>,创建一个原生的Java普通项目，创建后看架构有无问题，再右键该<code>moudle</code>选择<code>add framwork support  </code> 选择 web工程即可，之后再右键该<code>moudle</code>–&gt;<code>open moudle setting</code> –&gt;<code>artifacts</code>在<code>WEB-INF</code>下创建<code>lib</code>目录并将依赖的jar包全部导入。</p><p><strong>编写一个Servlet类，用来处理用户的请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Controller;</span><br><span class="line"><span class="comment">//实现Servlet接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//取得参数</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (method.equals(<span class="string">&quot;add&quot;</span>))&#123;</span><br><span class="line">           req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了add方法&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">if</span> (method.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">           req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了delete方法&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//业务逻辑</span></span><br><span class="line">       <span class="comment">//视图跳转</span></span><br><span class="line">       req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/hello.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       doGet(req,resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>在web.xml中注册Servlet</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.coder.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置Tomcat，并启动</strong></p><p>在IDEA中，点击<code>run</code>选择<code>Edit configurations</code>添加Tomcat并添加项目部署包</p><ul><li>localhost:8080&#x2F;user?method&#x3D;add</li><li>localhost:8080&#x2F;user?method&#x3D;delete</li></ul><p><strong>MVC框架要做哪些事情</strong></p><ol><li>将url映射到java类或java类的方法 .</li><li>封装用户提交的数据 .</li><li>处理请求–调用相关的业务处理–封装响应数据 .</li><li>将响应的数据进行渲染 . jsp &#x2F; html 等表示层数据 .</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIRQkoR3WJaVZzicPAx3NumuY40RXSQOPzIbEicYsT0ySCPQ8cvQc2ic1Aw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><ul><li><p>它减轻了开发人员的工作负担，使得开发人员可以专注于业务逻辑层。</p><p><a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web">官方文档</a></p></li></ul><p><strong>Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。</strong></p><p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p><p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjI7ENu0jNibPiaiaiaBhyx6o9UUyU82Mddg4DjwzniaczmTLRbAtI9pKJq1tQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><p><strong>SpringMVC的原理如下图所示：</strong></p><p>​当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIaosVziclWLEJQkzobxHrpHcmtu2yTeVWPmEI4Yq5PaicS52VaJt8dYfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><h3 id="SpringMVC执行原理"><a href="#SpringMVC执行原理" class="headerlink" title="SpringMVC执行原理"></a>SpringMVC执行原理</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KwPOPWq00pMJiaK86lF6BjIbmPOkY8TxF6qvGAGXxC7dArYcr8uJlWoVC4aF4bfxgCGCD8sHg8mgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p><p><strong>简要分析执行流程</strong></p><ol><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p><p>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p><p><strong>如上url拆分成三部分：</strong></p><p><a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></p><p>SpringMVC部署在服务器上的web站点</p><p>hello表示控制器</p><p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p></li><li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p></li><li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p></li><li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p></li><li><p>Handler让具体的Controller执行。</p></li><li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p></li><li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p></li><li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p></li><li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p></li><li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p></li><li><p>最终视图呈现给用户。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC的配置</title>
      <link href="/2022/06/02/SpringMVC%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/06/02/SpringMVC%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC的配置"><a href="#SpringMVC的配置" class="headerlink" title="SpringMVC的配置"></a>SpringMVC的配置</h2><p>在web.xml中注册<code>DispactherServlet</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--DispactherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">Servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Servlet-class</span>&gt;</span>org.springframework.web.servlet.DispachterServlet<span class="tag">&lt;/<span class="name">Servlet-class</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--关联一个springmvc的配置文件:servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数字越低启动级别越高--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--匹配映射路径（/为匹配所有路径）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">web-app</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&#x2F; 和 &#x2F;* 的区别：</strong>&lt; url-pattern &gt; &#x2F; &lt;&#x2F; url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp  不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; &#x2F;* &lt;&#x2F;  url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet  类，导致找不到对应的controller所以报404错。</p><ul><li><p>注意web.xml版本问题，要最新版！</p></li><li><p>注册DispatcherServlet</p></li><li><p>关联SpringMVC的配置文件</p></li><li><p>启动级别为1</p></li><li><p>映射路径为 &#x2F; 【不要用&#x2F;*，会404】</p></li></ul><p>**编写SpringMVC 的 配置文件！名称：servlet.xml **</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加处理映射器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加处理适配器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span>,<span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span>,<span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        return new ModelAndView(&quot;hello&quot;).addObject(&quot;msg&quot;,&quot;helloSpringMVC!&quot;);</span></span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">            mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello!Spring-MVC&quot;</span>);</span><br><span class="line">            mv.setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> mv;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在springmvc的配置文件中将自己的类交给SpringIOC容器，注册bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.coder.Controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>编写前端界面，显示ModelAndView中存放的数据</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: MR.L</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">2</span>/<span class="number">13</span></span><br><span class="line">  Time: <span class="number">20</span>:<span class="number">19</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;SpirngMVC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;&lt;--这是配置版&lt;br/&gt;</span><br><span class="line">$&#123;id&#125;&lt;--这是注解版</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p><ol><li>查看控制台输出，看一下是不是缺少了什么jar包。</li><li>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！</li><li>重启Tomcat 即可解决！</li></ol><p><strong>开发中用的方法—-注解版</strong></p><h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><p><strong>Spring MVC配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描bean给SpringIOC容器处理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.coder.Controller&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   支持mvc注解驱动</span></span><br><span class="line"><span class="comment">       在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">       要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">       必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">       和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">       这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">       而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    视图解析器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</p><ul><li>让IOC的注解生效</li><li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..</li><li>MVC的注解驱动</li><li>配置视图解析器</li></ul><p><strong>创建Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.coder.Dao.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/Atest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jsp/helo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ModelAttribute(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">userTs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Login</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jsp/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login/&#123;id&#125;&quot;,method = &#123;RequestMethod.POST&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Logined</span> <span class="params">(<span class="meta">@PathVariable</span> String id, User user,Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jsp/userLogin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建视图层</strong></p><p>在WEB-INF&#x2F; jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；</p><p>可以通过EL表示取出Model中存放的值，或者对象；</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: MR.L</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">2</span>/<span class="number">19</span></span><br><span class="line">  Time: <span class="number">13</span>:<span class="number">28</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录！！&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span>document.getElementById(name);</span><br><span class="line">    consloe.log(name.innerText);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/Atest/login/1&quot;</span>&gt;</span><br><span class="line">    &lt;table &gt;&lt;thead&gt;注册&lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;名字&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> name=<span class="string">&quot;username&quot;</span> placeholder=<span class="string">&quot;请输入名字&quot;</span>/&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;label <span class="keyword">for</span>=<span class="string">&quot;pwd&quot;</span>&gt;密码&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;pwd&quot;</span> name=<span class="string">&quot;password&quot;</span> placeholder=<span class="string">&quot;请输入密码&quot;</span>/&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;&lt;td colspan=<span class="string">&quot;2&quot;</span>&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">        &lt;/tbody&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实现步骤其实非常的简单：</p><ol><li>新建一个web项目</li><li>导入相关jar包</li><li>编写web.xml , 注册DispatcherServlet</li><li>编写springmvc配置文件</li><li>接下来就是去创建对应的控制类 , controller</li><li>最后完善前端视图和controller之间的对应</li><li>测试运行调试.</li></ol><p>使用springMVC必须配置的三大件：</p><p><strong>处理器映射器、处理器适配器、视图解析器</strong></p><p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springCloud</title>
      <link href="/2022/06/02/springCloud/"/>
      <url>/2022/06/02/springCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-SOA与微服务的关系"><a href="#1-1-SOA与微服务的关系" class="headerlink" title="1.1 SOA与微服务的关系"></a>1.1 SOA与微服务的关系</h1><p><strong>SOA</strong>面向服务架构，他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。各个服务之间通过网络调用。</p><p><strong>微服务架构</strong>:其实和SOA类似，微服务是在SOA上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。</p><table><thead><tr><th>功能</th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>组件大小</td><td>大块业务逻辑</td><td>单独任务或小块业务逻辑</td></tr><tr><td>耦合</td><td>通常松耦合</td><td>总是松耦合</td></tr><tr><td>公司架构</td><td>任何类型</td><td>小型、专注于功能交叉团队</td></tr><tr><td>管理</td><td>着重中央管理</td><td>着重分散管理</td></tr><tr><td>目标</td><td>确保应用能够交互操作</td><td>执行新功能、快速拓展开发团队</td></tr></tbody></table><h1 id="1-2-远程调用技术"><a href="#1-2-远程调用技术" class="headerlink" title="1.2 远程调用技术"></a>1.2 远程调用技术</h1><p><strong>RPC:</strong></p><p>PC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务，直接使用TCP或UDP协议进行服务间的通信</p><p><strong>http</strong></p><p>RESTful</p><table><thead><tr><th>比较</th><th>RESTful</th><th>RPC</th></tr></thead><tbody><tr><td>通讯协议</td><td>HTTP</td><td>一般使用TCP</td></tr><tr><td>性能</td><td>略低</td><td>较高</td></tr><tr><td>灵活度</td><td>高</td><td>低</td></tr><tr><td>应用</td><td>微服务架构</td><td>SOA架构</td></tr></tbody></table><h1 id="1-3-Spring-Cloud"><a href="#1-3-Spring-Cloud" class="headerlink" title="1.3 Spring Cloud"></a>1.3 Spring Cloud</h1><p><strong>Spring Cloud Netflix组件</strong></p><table><thead><tr><th>组件名称</th><th>作用</th></tr></thead><tbody><tr><td>Eureka</td><td>服务注册中心</td></tr><tr><td>Ribbon</td><td>客户端负载均衡</td></tr><tr><td>Feign</td><td>声明式服务调用</td></tr><tr><td>Hystrix</td><td>客户端容错保护</td></tr><tr><td>Zuul</td><td>API服务网关</td></tr></tbody></table><h1 id="2-服务注册Eureka"><a href="#2-服务注册Eureka" class="headerlink" title="2 服务注册Eureka"></a>2 服务注册Eureka</h1><h2 id="2-1-微服务的注册中心"><a href="#2-1-微服务的注册中心" class="headerlink" title="2.1 微服务的注册中心"></a>2.1 微服务的注册中心</h2><p>注册中心可以说是微服务架构中的“通讯录”，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就在这里找到服务地址，进行调用。</p><h2 id="2-1-1-注册中心的主要作用"><a href="#2-1-1-注册中心的主要作用" class="headerlink" title="2.1.1 注册中心的主要作用"></a>2.1.1 注册中心的主要作用</h2><p>注册中心在微服务架构中主要起到了协调者的一个作用。注册中心一般包含如下几个功能：</p><ol><li><p>服务发现：服务注册&#x2F;反注册 服务订阅&#x2F;取消订阅 服务路由</p></li><li><p>服务配置：配置订阅 配置下发</p></li><li><p>服务健康检测</p></li></ol><h2 id="2-1-2-常见的注册中心"><a href="#2-1-2-常见的注册中心" class="headerlink" title="2.1.2 常见的注册中心"></a>2.1.2 常见的注册中心</h2><ul><li><p>zookeeper</p></li><li><p>eureka</p></li><li><p>consul</p></li><li><p>nacos</p></li></ul><h3 id="使用Eureka"><a href="#使用Eureka" class="headerlink" title="使用Eureka"></a>使用Eureka</h3><ol><li><p>搭建eureka server</p><ol><li><p>创建工程</p><p>在项目的project下新建module子模块</p></li><li><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册中心坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置<code>application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">instance:</span></span><br><span class="line">   <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">registerWithEureka:</span> <span class="literal">false</span>  </span><br><span class="line">   <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">   <span class="attr">serviceUrl:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>registerWithEureka: 是否将自己注册到Eureka服务中，本身就是所以无需注册 </p><p>fetchRegistry : 是否从Eureka中获取注册信息 </p><p>serviceUrlEureka: 客户端与Eureka服务端进行交互的地址</p></blockquote></li><li><p>配置启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//激活eureka服务</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>将服务提供者注册到eureka server上</p><ol><li><p>引入eureka相应的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入rureka客户端坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>application.yml</code>添加eureka server的信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">serviceUrl:</span> <span class="comment"># eureka server的路径</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">   <span class="comment">#非必要  </span></span><br><span class="line"> <span class="attr">instance:</span></span><br><span class="line">   <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#使用ip注册</span></span><br></pre></td></tr></table></figure></li><li><p>修改启动类 添加服务发现的支持</p></li></ol></li><li><p>服务消费者通过注册中心获取服务列表，并调用</p></li></ol><p>​eureka中的元数据：服务的主机名，IP地址等信息，可以通过eureka server进行获取，用于服务之间调用</p><h3 id="eureka集群、高可用的引入"><a href="#eureka集群、高可用的引入" class="headerlink" title="eureka集群、高可用的引入"></a>eureka集群、高可用的引入</h3><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210817165148.png"></p><p>1、准备2个eureka server，需要相互注册</p><p>​1 号server：9000</p><p>​2 号server：8000</p><p>2、需要将微服务注册到两个eureka server上</p><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><h4 id="在控制台显示服务IP"><a href="#在控制台显示服务IP" class="headerlink" title="在控制台显示服务IP"></a>在控制台显示服务IP</h4><p>在服务提供者，通过eureka.instance.instance-id配置控制台显示服务IP</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9000/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 使用ip地址注册</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span> <span class="comment">#想注册中心中注册服务id</span></span><br></pre></td></tr></table></figure><h4 id="eureka的服务剔除问题"><a href="#eureka的服务剔除问题" class="headerlink" title="eureka的服务剔除问题"></a>eureka的服务剔除问题</h4><p>默认每隔30s发送心跳，如果90s内没有发送心跳代表宕机</p><p>在服务的提供者，设置心跳间隔，设置续约到期时间</p><h4 id="eureka的自我保护机制"><a href="#eureka的自我保护机制" class="headerlink" title="eureka的自我保护机制"></a>eureka的自我保护机制</h4><p>在eureka中配置关闭自我保护和剔除服务间隔</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将自己注册到注册中心</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#是否要从eureka中获取注册信息</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment">#配置暴露给Eureka Client的请求地址</span></span><br><span class="line">      <span class="attr">defalutZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护机制</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">4000</span> <span class="comment"># 设置剔除服务间隔</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="2-2-eureka源码解析"><a href="#2-2-eureka源码解析" class="headerlink" title="2.2 eureka源码解析"></a>2.2 eureka源码解析</h2><h3 id="2-2-1-SpringBoot中的自动装载"><a href="#2-2-1-SpringBoot中的自动装载" class="headerlink" title="2.2.1 SpringBoot中的自动装载"></a>2.2.1 SpringBoot中的自动装载</h3><h4 id="1-ImportSelector"><a href="#1-ImportSelector" class="headerlink" title="(1) ImportSelector"></a>(1) ImportSelector</h4><p>ImportSelector接口是Spring导入外部配置的核心接口，在SpringBoot的自动化配置和@EnableXXX(功能性注解)中起到了决定性作用。当在@Configuration标注的Class上使用@Import引入了一个ImportSelector实现类后，会把实现类中返回的Class名称都定义为Bean。</p><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210820162313.png" alt="企业微信20210820162313"></p><h4 id="2-EnableEurekaServer"><a href="#2-EnableEurekaServer" class="headerlink" title="(2) EnableEurekaServer"></a>(2) EnableEurekaServer</h4><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210823094837.png" alt="企业微信20210823094837"></p><h1 id="3-服务调用Ribbon"><a href="#3-服务调用Ribbon" class="headerlink" title="3. 服务调用Ribbon"></a>3. 服务调用Ribbon</h1><p>经过以上的学习，已经实现了服务的注册和服务发现，当启动某个服务时，可以通过HTTP的形式将信息注册到注册中心，并且可以通过SpringCloud提供的工具获取注册中心的服务列表。但是服务之间的调用还存在很多的问题，如何更加方便的调用微服务，多个微服务的提供者如何选择，如何均衡负载等。</p><h2 id="3-1-Ribbon概述"><a href="#3-1-Ribbon概述" class="headerlink" title="3.1 Ribbon概述"></a>3.1 Ribbon概述</h2><h3 id="3-1-1-什么是Ribbon"><a href="#3-1-1-什么是Ribbon" class="headerlink" title="3.1.1 什么是Ribbon"></a>3.1.1 什么是Ribbon</h3><p>是netflix发布的一个负载均衡器，有助于控制HTTP和TCP客户端行为。在SpringCloud中，Eureka一般配合Ribbon进行使用，Ribbon提供了客户端负载均衡的功能，Ribbon利用从Eureka中读取到的服务信息，在调用服务节点提供的服务时，会合理的进行负载。</p><p>在SpringCloud中可以将注册中心和Ribbon配合使用，Ribbon自动的从注册中心获取服务提供者的列表信息，并基于内置的负载均衡算法，请求服务。</p><h3 id="3-1-2-Ribbon的主要作用"><a href="#3-1-2-Ribbon的主要作用" class="headerlink" title="3.1.2 Ribbon的主要作用"></a>3.1.2 Ribbon的主要作用</h3><h4 id="1-服务调用"><a href="#1-服务调用" class="headerlink" title="(1) 服务调用"></a>(1) 服务调用</h4><p>基于Ribbon实现服务调用，是通过拉取到的所用服务列表组成(服务名-请求路径的)映射关系。借助RestTemplate最终进行调用。</p><h4 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="(2) 负载均衡"></a>(2) 负载均衡</h4><p>当有多个服务提供者时，Ribbon可以根据负载均衡的算法自动的选择需要调用的服务地址。</p><p>Ribbon是一个典型的客户端负载均衡器。Ribbon会获取服务的所有地址，根据内部的负载均衡算法，获取本次请求的有效地址。</p><p>准备两个商品微服务(9001),(9011)</p><p>在订单系统中远程以负载均衡的形式调用商品服务</p><h4 id="3-负载均衡策略"><a href="#3-负载均衡策略" class="headerlink" title="(3) 负载均衡策略"></a>(3) 负载均衡策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.loadbalancer.RoudRobinRule  <span class="comment">//以轮询的方式进行负载均衡</span></span><br><span class="line">com.netflix.loadbalancer.RandomRule <span class="comment">//随机策略</span></span><br><span class="line">com.netflix.loadbalancer.RetryRule <span class="comment">//重试策略</span></span><br><span class="line">com.netflix.loadbalancer.weightedResponseTimeRule <span class="comment">//权重策略，会计算每个服务的权重，越高的调用的可能性越大</span></span><br><span class="line">com.netflix.loadbalancer.BestAvailableRule <span class="comment">//最佳策略，遍历所有的服务实例，过滤掉故障实例，并返回请求数最小的实例返回</span></span><br><span class="line">com.netflix.loadbalancer.AvailabilityFilteringRule <span class="comment">//可用过滤策略。过滤掉故障和请求数超过阈值的服务实例，再从剩下的实例中轮询调用</span></span><br></pre></td></tr></table></figure><p>在服务消费者的application.yml配置文件中修改负载均衡策略</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改ribbon的负载均衡策略  服务名 - ribbon - NFLoadBalancerRuleClassName : 策略</span></span><br><span class="line"><span class="attr">product-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><h4 id="4-重试机制"><a href="#4-重试机制" class="headerlink" title="(4) 重试机制"></a>(4) 重试机制</h4><p>引入spring的重试组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对ribbon进行重试配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">product-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># Ribbon的连接超时时间</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">1000</span> <span class="comment"># Ribbon的数据读取超时时间</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperation:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作都进行重试</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment"># 切换实例的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 对当前实例的重试次数</span></span><br></pre></td></tr></table></figure><h4 id="5-Ribbon源码解析"><a href="#5-Ribbon源码解析" class="headerlink" title="(5) Ribbon源码解析"></a>(5) Ribbon源码解析</h4><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210826114004.png" alt="企业微信20210826114004"></p><h1 id="4-Consul"><a href="#4-Consul" class="headerlink" title="4.Consul"></a>4.Consul</h1><p>特性：</p><p>服务发现</p><p>健康检查</p><p>K&#x2F;V存储</p><p>多数据中心</p><h3 id="4-1-1-consul和eureka区别"><a href="#4-1-1-consul和eureka区别" class="headerlink" title="4.1.1 consul和eureka区别"></a>4.1.1 consul和eureka区别</h3><h4 id="1-一致性"><a href="#1-一致性" class="headerlink" title="(1) 一致性"></a>(1) 一致性</h4><p>consul强一致性(CP)</p><p>​服务注册相比eureka会稍慢一些。因为consul的raft协议要求必须过半数的结点都写入成功才认为注册成功</p><p>​leader挂掉时，重选期间整个consul不可用，保证了强一致性但牺牲了可用性</p><p>eureka保证高可用和最终一致性(AP)</p><p>​服务注册相对较快</p><p>​当数据出现不一致时，虽然A,B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到，保证了可用性但牺牲了一致性</p><h4 id="2-开发语言和使用"><a href="#2-开发语言和使用" class="headerlink" title="(2) 开发语言和使用"></a>(2) 开发语言和使用</h4><p>eureka就是个servlet程序，跑在servlet容器中</p><p>consul则是go编写而成，安装启动即可</p><h1 id="5-服务调用Feign"><a href="#5-服务调用Feign" class="headerlink" title="5.服务调用Feign"></a>5.服务调用Feign</h1><h2 id="5-1-Feign简介"><a href="#5-1-Feign简介" class="headerlink" title="5.1 Feign简介"></a>5.1 Feign简介</h2><p>Feign是netfilx开发的声明式，模板化的HTTP客户端，其灵感来自Retrofit, JAXR-2.0以及WebSocket</p><p>​Feign可以帮助我们更加便捷，优雅的调用HTTP</p><p>​在SpringCloud中，使用Feign非常简单–创建一个接口，并在接口上添加一些注解，代码就完成了。</p><p>​Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等</p><p>​SpringCloud对Feign进行了增强，使Feign支持了SprimgMVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便</p><p>​Feign是在Ribbon的基础上进行了一次改进，是一个使用起来更加方便的HTTP客户端。采用接口的方式，只需要创建一个接口，在上面添加注解即可，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建HTTP请求，然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写客户端变得非常容易</p><h2 id="5-2-基于Feign的服务调用"><a href="#5-2-基于Feign的服务调用" class="headerlink" title="5.2 基于Feign的服务调用"></a>5.2 基于Feign的服务调用</h2><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="(1) 引入依赖"></a>(1) 引入依赖</h4><p>在服务消费者shop_order-service添加Feign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-配置调用接口"><a href="#2-配置调用接口" class="headerlink" title="(2) 配置调用接口"></a>(2) 配置调用接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明需要调用的微服务名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FeignClient</span></span></span><br><span class="line"><span class="comment"> *      * name: 服务提供者的名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;product-sercvice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductFeignClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置需要调用的微服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/product/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在启动类激活Feign"><a href="#3-在启动类激活Feign" class="headerlink" title="(3) 在启动类激活Feign"></a>(3) 在启动类激活Feign</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EntityScan(&quot;cn.itcast.order.entity&quot;)</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//激活feign</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span></span><br></pre></td></tr></table></figure><h4 id="4-通过自动的接口调用远程服务"><a href="#4-通过自动的接口调用远程服务" class="headerlink" title="(4) 通过自动的接口调用远程服务"></a>(4) 通过自动的接口调用远程服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductFeignClient productFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/buy/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    product = productFeignClient.findById(id);</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-负载均衡"><a href="#5-3-负载均衡" class="headerlink" title="5.3 负载均衡"></a>5.3 负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。</p><h1 id="6-服务调用Feign高级"><a href="#6-服务调用Feign高级" class="headerlink" title="6 服务调用Feign高级"></a>6 服务调用Feign高级</h1><h2 id="6-1-Feign的配置"><a href="#6-1-Feign的配置" class="headerlink" title="6.1 Feign的配置"></a>6.1 Feign的配置</h2><p>从SpringCloud Edgware开始，Feign支持使用属性自定义Feign。对于一个指定名称的FeignClient，Feign支持如下配置</p><p>​feignName: FeignClient的名称</p><p>​connectTimeout：建立链接的超时时长</p><p>​readTimeout：读取超时时长</p><p>​loggerLevel：Feign的日志级别</p><p>​errorDecoder：Feign的错误解码器</p><p>​retryer: 配置重试</p><p>​requestInterceptors：添加请求拦截器</p><p>​decoder404：配置熔断不处理404异常</p><h2 id="6-2-请求压缩"><a href="#6-2-请求压缩" class="headerlink" title="6.2 请求压缩"></a>6.2 请求压缩</h2><p>SpringCloud Feign支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗，通过下面的参数即可开启请求与响应的压缩功能：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">compression:</span></span><br><span class="line"><span class="attr">request:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启请求压缩</span></span><br><span class="line"><span class="attr">response:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启响应压缩</span></span><br></pre></td></tr></table></figure><h2 id="6-3-日志级别"><a href="#6-3-日志级别" class="headerlink" title="6.3 日志级别"></a>6.3 日志级别</h2><p>在开发或者运行阶段往往希望看到Feign请求过程的日志记录，默认情况下Feign的日志是没有开启的。要想用属性配置方式来达到日志效果，只需在application.yml中添加如下内容即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">shop-product-service:</span></span><br><span class="line"><span class="attr">loggerLevel:</span> <span class="string">FULL</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">level:</span></span><br><span class="line"><span class="attr">cn.itcast.order.feign.ProductFeignClient:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h2 id="6-4-Feign和Ribbon的区别"><a href="#6-4-Feign和Ribbon的区别" class="headerlink" title="6.4 Feign和Ribbon的区别"></a>6.4 Feign和Ribbon的区别</h2><p>Ribbon是一个客户端的负载均衡器</p><p>Feign是在Ribbon的基础上进行了封装</p><h2 id="6-5-组件的使用方式"><a href="#6-5-组件的使用方式" class="headerlink" title="6.5 组件的使用方式"></a>6.5 组件的使用方式</h2><h3 id="6-5-1-注册中心"><a href="#6-5-1-注册中心" class="headerlink" title="6.5.1 注册中心"></a>6.5.1 注册中心</h3><h4 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="(1) Eureka"></a>(1) Eureka</h4><p>​搭建注册中心</p><p>​引入依赖 spring-cloud-starter-netflix-eureka-server</p><p>​配置EurekaServer</p><p>​通过@EnableEurekaServer激活Eureka Server端配置</p><p>​服务注册</p><p>​服务提供者引入 spring-cloud-starter-netflix-eureka-client依赖</p><p>​通过eureka.client.serviceUrl.defaultZone 配置注册中心地址</p><h4 id="2-consul"><a href="#2-consul" class="headerlink" title="(2) consul"></a>(2) consul</h4><p>​搭建注册中心</p><p>​下载安装consul</p><p>​启动consul consul agent -dev</p><p>​服务注册</p><p>​服务提供者引入spring-cloud-starter-consul-discovery</p><p>​通过spring.cloud.consul.host和spring.cloud.consul.port指定Consul Server的请求地址</p><h3 id="6-5-2-服务调用"><a href="#6-5-2-服务调用" class="headerlink" title="6.5.2 服务调用"></a>6.5.2 服务调用</h3><h4 id="1-Ribbon"><a href="#1-Ribbon" class="headerlink" title="(1) Ribbon"></a>(1) Ribbon</h4><p>​通过Ribbon结合RestTemplate方式进行服务调用只需要在声明RestTemplate的方法上添加注解@LoadBalanced 即可</p><p>​可以通过{服务名称}.ribbon.NFLoadBalancerRuleClassName配置负载均衡策略</p><h4 id="2-Feign"><a href="#2-Feign" class="headerlink" title="(2) Feign"></a>(2) Feign</h4><p>​服务消费者引入spring-cloud-starter-openfeign依赖</p><p>​通过@FeignClient声明一个调用远程微服务接口</p><p>​启动类上通过@EnableFeignClient激活Feign</p><h2 id="6-1-微服务架构的高并发问题"><a href="#6-1-微服务架构的高并发问题" class="headerlink" title="6.1 微服务架构的高并发问题"></a>6.1 微服务架构的高并发问题</h2><p>通过注册中心已经实现了微服务的服务注册和服务发现,并且通过Ribbon实现了负载均衡，已经借助Feign可以优雅的进行微服务调用。那么我们编写的微服务的性能怎么样呢？是否存在问题？</p><h3 id="6-1-1-性能测试工具Jmeter"><a href="#6-1-1-性能测试工具Jmeter" class="headerlink" title="6.1.1 性能测试工具Jmeter"></a>6.1.1 性能测试工具Jmeter</h3><p>用来进行压力测试</p><h2 id="6-2-系统负载过高存在的问题"><a href="#6-2-系统负载过高存在的问题" class="headerlink" title="6.2 系统负载过高存在的问题"></a>6.2 系统负载过高存在的问题</h2><h3 id="6-2-1-问题分析"><a href="#6-2-1-问题分析" class="headerlink" title="6.2.1 问题分析"></a>6.2.1 问题分析</h3><p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪。</p><p>在SpringBoot程序中，默认使用内置tomcat作为web服务器。单tomcat支持最大的并发请求是有限的，如果某一接口阻塞，待执行的任务积压越来越多，那么势必会影响其他接口的调用。</p><h3 id="6-2-2-线程池的形式实现服务隔离"><a href="#6-2-2-线程池的形式实现服务隔离" class="headerlink" title="6.2.2 线程池的形式实现服务隔离"></a>6.2.2 线程池的形式实现服务隔离</h3><p><img src="/Users/apple/Desktop/%25E4%25BC%2581%25E4%25B8%259A%25E5%25BE%25AE%25E4%25BF%25A120210830111824.png" alt="企业微信20210830111824"></p><h1 id="7-服务熔断Hystrix入门"><a href="#7-服务熔断Hystrix入门" class="headerlink" title="7.服务熔断Hystrix入门"></a>7.服务熔断Hystrix入门</h1><h2 id="7-1-服务容错的核心知识"><a href="#7-1-服务容错的核心知识" class="headerlink" title="7.1 服务容错的核心知识"></a>7.1 服务容错的核心知识</h2><h3 id="7-1-1-雪崩效应"><a href="#7-1-1-雪崩效应" class="headerlink" title="7.1.1 雪崩效应"></a>7.1.1 雪崩效应</h3><p>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问A服务，而A服务需要调用B服务，B服务需要调用C服务，由于网络原因或者自身的原因，如果B服务或者C服务不能及时响应，A服务将处于阻塞状态，直到B服务C服务响应。此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务于服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><p>雪崩是系统中的蝴蝶效应导致其发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="zuul网关"><a href="#zuul网关" class="headerlink" title="zuul网关"></a>zuul网关</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>ZUUL是Netﬂix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用，Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：</p></blockquote><ul><li><strong>动态路由</strong>：动态将请求路由到不同后端集群</li><li><strong>压力测试</strong>：逐渐增加指向集群的流量，以了解性能 </li><li><strong>负载分配</strong>：为每一种负载类型分配对应容量，并弃用超出限定值的请求 </li><li><strong>静态响应处理</strong>：边缘位置进行响应，避免转发到内部集群 </li><li><strong>身份认证和安全</strong>: 识别每一个资源的验证要求，并拒绝那些不符的请求。Spring Cloud对Zuul进行了整合和增强。</li></ul><h3 id="搭建zuul网关服务器"><a href="#搭建zuul网关服务器" class="headerlink" title="搭建zuul网关服务器"></a>搭建zuul网关服务器</h3><ol><li>创建工程导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>配置启动类，开启网关服务器功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootAplication</span></span><br><span class="line"><span class="comment">//开启zuul网关功能</span></span><br><span class="line"><span class="meta">@EnableZuulproxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulServerApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="string">port:8080</span> <span class="comment">#端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="string">name:api-zuul-server</span> <span class="comment">#服务名称</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由：根据请求的URL，将请求分配到对应的微服务中进行处理</p><ol><li><h4 id="基础路由配置"><a href="#基础路由配置" class="headerlink" title="基础路由配置"></a>基础路由配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#路由配置</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="comment">#商品微服务</span></span><br><span class="line"><span class="attr">product-service:</span> <span class="comment">#路由id，随便写</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/product-service/**</span>    <span class="comment"># 输入的映射路径 localhost:8080/product-service/xxxx</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://127.0.0.1:9001</span>  <span class="comment">#映射路径对应的微服务的url地址</span></span><br></pre></td></tr></table></figure></li><li><h4 id="面向服务的路由"><a href="#面向服务的路由" class="headerlink" title="面向服务的路由"></a>面向服务的路由</h4><blockquote><p>微服务一般是由几十、上百个服务组成，对于一个URL请求，最终会确认一个服务实例进行处理。如果对每个服务实例手动指定一个唯一访问地址，然后根据URL去手动实现请求匹配，这样做显然就不合理。 Zuul支持与Eureka整合开发，根据ServiceID自动的从注册中心中获取服务地址并转发请求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而且在添加或移除服务实例的时候不用修改Zuul的路由配置。</p></blockquote><ol><li><p>添加eureka-client依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启eureka的客户端服务发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能 @EnableDiscoveryClient public class ZuulServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulServerApplication.class, args); &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在zuul网关服务中心配置eureka的注册中心相关信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka: client: serviceUrl: defaultZone: http://127.0.0.1:8761/eureka/ registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s instance: preferIpAddress: true ip-address: 127.0.0.1</span></span><br></pre></td></tr></table></figure></li><li><p>修改路由中的映射配置</p><blockquote><p>通过服务名称获取，因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而</p><p>是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置路由规则 </span></span><br><span class="line"><span class="attr">zuul: routes: product-service:</span> <span class="comment"># 这里是路由id，随意写 </span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/product-service/**</span> <span class="comment"># 这里是映射路径 </span></span><br><span class="line"><span class="attr">serviceId:</span> <span class="string">shop-service-product</span> <span class="comment">#配置转发的微服务名称</span></span><br></pre></td></tr></table></figure><ul><li><strong>serviceId</strong>: 指定需要转发的微服务实例名称</li></ul></li></ol></li><li><p><strong>简化的路由配置</strong></p><p>在刚才的配置中，我们的规则是这样的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zuul.routes.&lt;route&gt;.path=/xxx/**</span> <span class="string">：</span> <span class="string">来指定映射路径。</span> <span class="string">&lt;route&gt;</span> <span class="string">是自定义的路由名</span></span><br><span class="line"></span><br><span class="line"><span class="string">zuul.routes.&lt;route&gt;.serviceId=/product-service</span> <span class="string">：来指定服务名。</span></span><br></pre></td></tr></table></figure><p>而大多数情况下，我们的 <code>&lt;route&gt;</code> 路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul routes.&lt;serviceId&gt;=&lt;path&gt;</code></p><p>上面的配置可以简化为一条：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul: routes: shop-service-product:</span> <span class="string">/product-service/**</span></span><br></pre></td></tr></table></figure></li><li><p><strong>默认的路由规则</strong></p><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁</p><p>琐的。</p><p>因此Zuul就指定了默认的路由规则：</p><p>默认情况下，一切服务的<strong>映射路径</strong>就是服务名<strong>本身</strong>。</p><p>例如服务名为： shop-service-product ，则默认的映射路径就是： &#x2F;shop-service- </p><p>product&#x2F;**</p></li></ol><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="ZuulFilter"><a href="#ZuulFilter" class="headerlink" title="ZuulFilter"></a>ZuulFilter</h4><ul><li><p><strong>简介</strong></p><p>Zuul 中的过滤器跟我们之前使用的 <code>javax.servlet.Filter</code> 不一样，<code>javax.servlet.Filter</code> 只有一种类型，可</p><p>以通过配置 <code>urlPatterns </code>来拦截对应的请求。而 Zuul 中的过滤器总共有 4 种类型，且每种类型都有对</p><p>应的使用场景。 </p><ol><li><strong>PRE</strong>：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请</li></ol><p>求的微服务、记录调试信息等。</p><ol start="2"><li><strong>ROUTING</strong>：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用</li></ol><p><code>Apache HttpClient</code>或<code>Netfifilx Ribbon</code>请求微服务。</p><ol start="3"><li><strong>POST</strong>：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP</li></ol><p>Header、收集统计信息和指标、将响应从微服务发送给客户端等。</p><ol start="4"><li><strong>ERROR</strong>：在其他阶段发生错误时执行该过滤器。</li></ol></li></ul><p>Zuul提供了自定义过滤器的功能实现起来也十分简单，只需要编写一个类去实现zuul提供的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ZuulFilter <span class="keyword">implements</span> <span class="title class_">IZuulFilter</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span>;<span class="comment">// 来自IZuulFilter </span></span><br><span class="line">    Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException;<span class="comment">// IZuulFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.niupic.com/images/2021/09/06/9uyQ.jpg"></p><h5 id="内部源码"><a href="#内部源码" class="headerlink" title="内部源码"></a>内部源码</h5><p><strong>自定义过滤器</strong></p><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 登录校验，肯定是在前置拦截 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 顺序设置为1 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 返回true，代表过滤器生效。 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123; </span><br><span class="line">        <span class="comment">// 登录校验逻辑。</span></span><br><span class="line">        <span class="comment">// 1）获取Zuul提供的请求上下文对象</span></span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">ctx</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">    <span class="comment">// 2) 从上下文中获取request对象 </span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> ctx.getRequest(); </span><br><span class="line">   <span class="comment">// 3) 从请求中获取</span></span><br><span class="line">        token <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;access-token&quot;</span>); </span><br><span class="line">        <span class="comment">// 4) 判断 </span></span><br><span class="line">        <span class="keyword">if</span>(token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token.trim()))&#123;</span><br><span class="line">            <span class="comment">// 没有token，登录校验失败，拦截 </span></span><br><span class="line">            ctx.setSendZuulResponse(<span class="literal">false</span>); </span><br><span class="line">            <span class="comment">// 返回401状态码。也可以考虑重定向到登录页。</span></span><br><span class="line">            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); &#125;<span class="comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>RequestContext</code>：用于在过滤器之间传递消息。它的数据保存在每个请求的<code>ThreadLocal</code>中。它</p><p>用于存储请求路由到哪里、错误、<code>HttpServletRequest</code>、<code>HttpServletResponse</code>都存储在</p><p><code>RequestContext</code>中。<code>RequestContext</code>扩展了<code>ConcurrentHashMap</code>，所以，任何数据都可以存储</p><p>在上下文中</p></li></ul><h2 id="springcloud-gateway网关"><a href="#springcloud-gateway网关" class="headerlink" title="springcloud gateway网关"></a>springcloud gateway网关</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker命令详解（run篇）</title>
      <link href="/2022/06/02/Docker%E4%B8%ADrun%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/02/Docker%E4%B8%ADrun%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker命令详解（run篇）"><a href="#Docker命令详解（run篇）" class="headerlink" title="Docker命令详解（run篇）"></a><a href="https://www.cnblogs.com/yfalcon/p/9044246.html">Docker命令详解（run篇）</a></h1><p>命令格式：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><br>Usage: Run a command in a new container<br>中文意思为：通过run命令创建一个新的容器（container）</p><ul><li><p>常用选项说明</p><ul><li><p><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</p></li><li><p><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</p></li><li><p><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</p></li><li><p><code>-u, --user=&quot;&quot;</code>， 指定容器的用户</p></li><li><p><code>-a, --attach=[]</code>， 登录容器（必须是以docker run -d启动的容器）</p></li><li><p><code>-w, --workdir=&quot;&quot;</code>， 指定容器的工作目录</p></li><li><p><code>-c, --cpu-shares=0</code>， 设置容器CPU权重，在CPU共享场景使用</p></li><li><p><code>-e, --env=[]</code>， 指定环境变量，容器中可以使用该环境变量</p></li><li><p><code>-m, --memory=&quot;&quot;</code>， 指定容器的内存上限</p></li><li><p><code>-P, --publish-all=false</code>， 指定容器暴露的端口</p></li><li><p><code>-p, --publish=[]</code>， 指定容器暴露的端口</p></li><li><p><code>-h, --hostname=&quot;&quot;</code>， 指定容器的主机名</p></li><li><p><code>-v, --volume=[]</code>， 给容器挂载存储卷，挂载到容器的某个目录</p></li><li><p><code>--volumes-from=[]</code>， 给容器挂载其他容器上的卷，挂载到容器的某个目录</p></li><li><p><code>--cap-add=[]</code>， 添加权限，<a href="http://linux.die.net/man/7/capabilities">权限清单详见</a></p></li><li><p><code>--cap-drop=[]</code>， 删除权限，<a href="http://linux.die.net/man/7/capabilities">权限清单详见</a></p></li><li><p><code>--cidfile=&quot;&quot;</code>， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</p></li><li><p><code>--cpuset=&quot;&quot;</code>， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</p></li><li><p><code>--device=[]</code>， 添加主机设备给容器，相当于设备直通</p></li><li><p><code>--dns=[]</code>， 指定容器的dns服务器</p></li><li><p><code>--dns-search=[]</code>， 指定容器的dns搜索域名，写入到容器的&#x2F;etc&#x2F;resolv.conf文件</p></li><li><p><code>--entrypoint=&quot;&quot;</code>， 覆盖image的入口点</p></li><li><p><code>--env-file=[]</code>， 指定环境变量文件，文件格式为每行一个环境变量</p></li><li><p><code>--expose=[]</code>， 指定容器暴露的端口，即修改镜像的暴露端口</p></li><li><p><code>--link=[]</code>， 指定容器间的关联，使用其他容器的IP、env等信息</p></li><li><p><code>--lxc-conf=[]</code>， 指定容器的配置文件，只有在指定–exec-driver&#x3D;lxc时使用</p></li><li><p><code>--name=&quot;&quot;</code>， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</p></li><li><pre><code>--net=&quot;bridge&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ， 容器网络设置:</span><br><span class="line"></span><br><span class="line">  - bridge 使用docker daemon指定的网桥</span><br><span class="line">  - host //容器使用主机的网络</span><br><span class="line">  - container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源</span><br><span class="line">  - none 容器使用自己的网络（类似--net=bridge），但是不进行配置</span><br><span class="line"></span><br><span class="line">- `--privileged=false`， 指定容器是否为特权容器，特权容器拥有所有的capabilities</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  --restart=&quot;no&quot;</span><br></pre></td></tr></table></figure>， 指定容器停止后的重启策略:- no：容器退出时不重启- on-failure：容器故障退出（返回值非零）时重启- always：容器退出时总是重启</code></pre></li><li><p><code>--rm=false</code>， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</p></li><li><p><code>--sig-proxy=true</code>， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</p></li></ul></li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul><li>运行一个在后台执行的容器，同时，还能用控制台管理：<code>docker run -i -t -d ubuntu:latest</code></li><li>运行一个带命令在后台不断执行的容器，不直接展示容器内部信息：<code>docker run -d ubuntu:latest ping www.docker.com</code></li><li>运行一个在后台不断执行的容器，同时带有命令，程序被终止后还能重启继续跑，还能用控制台管理，<code>docker run -d --restart=always ubuntu:latest ping www.docker.com</code></li><li>为容器指定一个名字，<code>docker run -d --name=ubuntu_server ubuntu:latest</code></li><li>容器暴露80端口，并指定宿主机80端口与其通信(<strong>:</strong> 之前是宿主机端口，之后是容器需暴露的端口)，<code>docker run -d --name=ubuntu_server -p 80:80 ubuntu:latest</code></li><li>指定容器内目录与宿主机目录共享(<strong>:</strong> 之前是宿主机文件夹，之后是容器需共享的文件夹)，<code>docker run -d --name=ubuntu_server -v /etc/www:/var/www ubuntu:latest</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql的使用</title>
      <link href="/2022/06/02/MySql%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/02/MySql%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql及SQL语句的使用"><a href="#Mysql及SQL语句的使用" class="headerlink" title="Mysql及SQL语句的使用"></a>Mysql及SQL语句的使用</h2><h3 id="mysql登录相关"><a href="#mysql登录相关" class="headerlink" title="mysql登录相关"></a>mysql登录相关</h3><ul><li><p><strong>命令登录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hyourip -uusername -ppassword -Pport (本地连接可以不许需要 -h与-P)</span><br></pre></td></tr></table></figure></li><li><p><strong>用户添加及授权</strong></p><blockquote><p><strong>以root用户登录Mysql</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure><blockquote><p><strong>切换到mysql数据库</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure><blockquote><p><strong>添加用户</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>只允许指定ip连接</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许所有ip连接（用通配符<span class="operator">%</span>表示）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为新用户授权</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//基本格式如下</span><br><span class="line">grant all privileges on 数据库名.表名 to &#x27;新用户名&#x27;@&#x27;指定ip&#x27; identified by &#x27;新用户密码&#x27; ;</span><br><span class="line">//示例</span><br><span class="line">//允许访问所有数据库下的所有表</span><br><span class="line">grant all privileges on *.* to &#x27;新用户名&#x27;@&#x27;指定ip&#x27; identified by &#x27;新用户密码&#x27; ;</span><br><span class="line">//指定数据库下的指定表</span><br><span class="line">grant all privileges on test.test to &#x27;新用户名&#x27;@&#x27;指定ip&#x27; identified by &#x27;新用户密码&#x27; ;</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置用户操作权限</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>设置用户拥有所有权限也就是管理员</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>拥有查询权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>其它操作权限说明,<span class="keyword">select</span>查询 <span class="keyword">insert</span>插入 <span class="keyword">delete</span>删除 <span class="keyword">update</span>修改</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置用户拥有查询插入的权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>取消用户查询的查询权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">select</span> <span class="keyword">ON</span> what <span class="keyword">FROM</span> <span class="string">&#x27;新用户名&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改用户</strong></p></blockquote><ul><li><p><strong>方法1： 用SET PASSWORD命令</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：mysql<span class="operator">&gt;</span> <span class="keyword">set</span> password <span class="keyword">for</span> 用户名<span class="variable">@localhost</span> <span class="operator">=</span> password(<span class="string">&#x27;新密码&#x27;</span>); </span><br><span class="line">例子：mysql<span class="operator">&gt;</span> <span class="keyword">set</span> password <span class="keyword">for</span> root<span class="variable">@localhost</span> <span class="operator">=</span> password(<span class="string">&#x27;123&#x27;</span>); </span><br></pre></td></tr></table></figure></li><li><p><strong>方法2：用mysqladmin</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：mysqladmin <span class="operator">-</span>u用户名 <span class="operator">-</span>p旧密码 password 新密码 </span><br><span class="line">例子：mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 password <span class="number">123</span> </span><br></pre></td></tr></table></figure></li><li><p><strong>方法3：用UPDATE直接编辑user表</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use mysql; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;123&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges; </span><br></pre></td></tr></table></figure></li><li><p><strong>方法4：在忘记root密码的时候，可以这样</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">以windows为例： </span><br><span class="line"><span class="number">1.</span> 关闭正在运行的MySQL服务。 </span><br><span class="line"><span class="number">2.</span> 打开DOS窗口，转到mysql\bin目录。 </span><br><span class="line"><span class="number">3.</span> 输入mysqld <span class="comment">--skip-grant-tables 回车。--skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。 </span></span><br><span class="line"><span class="number">4.</span> 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\bin目录。 </span><br><span class="line"><span class="number">5.</span> 输入mysql回车，如果成功，将出现MySQL提示符 <span class="operator">&gt;</span>。 </span><br><span class="line"><span class="number">6.</span> 连接权限数据库： use mysql; 。 </span><br><span class="line"><span class="number">6.</span> 改密码：<span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(&quot;123&quot;) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span>&quot;root&quot;;（别忘了最后加分号） 。 </span><br><span class="line"><span class="number">7.</span> 刷新权限（必须步骤）：flush privileges;　。 </span><br><span class="line"><span class="number">8.</span> 退出 quit。 </span><br><span class="line"><span class="number">9.</span> 注销系统，再进入，使用用户名root和刚才设置的新密码<span class="number">123</span>登录。</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>删除用户</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> username<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改后刷新权限</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><blockquote></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习redis总结</title>
      <link href="/2022/06/01/%E5%AD%A6%E4%B9%A0redis%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/01/%E5%AD%A6%E4%B9%A0redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><p>它是一个用C写的单线程的非关系型的内存数据库</p><p><strong>特点</strong>：</p><ol><li><strong>速度快</strong> </li><li>持久化</li><li>多种数据结构</li><li>支持多种编程语言</li><li>功能丰富</li><li>简单</li><li>高可用、分布式</li><li>主从复制</li></ol><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/9BJE.jpg"></p><h3 id="Redis可执行文件的说明"><a href="#Redis可执行文件的说明" class="headerlink" title="Redis可执行文件的说明"></a>Redis可执行文件的说明</h3><table><thead><tr><th>redis-server</th><th>Redis服务器</th></tr></thead><tbody><tr><td>redis-cli</td><td>Redis命令行客户端</td></tr><tr><td>redis-benchmark</td><td>Redis性能测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF文件修复</td></tr><tr><td>redis-check-dump</td><td>RDB文件检查</td></tr><tr><td>redis-Sentinel</td><td>Sentinel服务器（2.8以后）</td></tr></tbody></table><h3 id="Redis的启动方法"><a href="#Redis的启动方法" class="headerlink" title="Redis的启动方法"></a><strong>Redis的启动方法</strong></h3><p><strong>Linux下载redis</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install redis</span><br></pre></td></tr></table></figure><ul><li><p>最简启动</p><p><code>redis-server</code></p><ul><li>验证Redis是否启动的方法<ul><li><code>ps -ef|grep redis</code>   –进程是否启动</li><li><code>netstat -antpl|grep redis</code> –端口是否被监听</li><li><code>redis-cli -h ip -p port ping</code></li></ul></li></ul></li><li><p>动态参数启动</p><ul><li><p>端口配置更改</p><p>redis默认使用6379端口提供服务，使用<code>redis-server --port &lt;port&gt;</code>自定义端口。<code>&lt;prot&gt;</code> 为自定义的端口号。</p></li></ul></li><li><p>配置文件启动</p><p><code>redis-server configPath</code> 将需配置的参数在配置文件中定义好，让后使用该命令启动Redis。<code>configPath</code> 是配置文件所在路径。</p></li></ul><h3 id="Redis客户端连接"><a href="#Redis客户端连接" class="headerlink" title="Redis客户端连接"></a>Redis客户端连接</h3><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210236935.png" alt="image-20210916210236935"></p><p><strong>Redis客户端返回值</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210537206.png"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210635450.png" alt="image-20210916210635450"></p><p><strong>Redis常用配置</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210916210959948.png" alt="image-20210916210959948"></p><h3 id="Redis的通用命令和数据结构"><a href="#Redis的通用命令和数据结构" class="headerlink" title="Redis的通用命令和数据结构"></a>Redis的通用命令和数据结构</h3><h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><ul><li><p><code>keys</code><br><strong>拿出匹配的键</strong></p><p><strong>PS：一般不在生产环境中使用</strong></p><p><strong>示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111045353.png" alt="image-20210917111045353"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111153218.png" alt="image-20210917111153218"></p></li><li><p><code>dbsize</code> –计算KEY的总数<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111613093.png" alt="image-20210917111613093"></p></li><li><p><code>exists key</code> –检查key是否存在<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917111747874.png" alt="image-20210917111747874"></p></li><li><p><code>del key [key ...]</code> – 删除指定的k-v<br><img src="C:%5CUsers%5C17102%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210917111926818.png" alt="image-20210917111926818"></p></li><li><p><code>expire key seconds</code><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917112041294.png" alt="image-20210917112041294"></p></li></ul><p><img src="C:%5CUsers%5C17102%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210917112538311.png" alt="image-20210917112538311"></p><p>​<img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917112705593.png" alt="image-20210917112705593"></p><ul><li><p><code>type key</code> –返回key的类型<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917112930085.png" alt="image-20210917112930085"></p><p><strong>时间复杂度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917113117249.png" alt="image-20210917113117249"></p></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917113352592.png" alt="image-20210917113352592"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917113848458.png"></p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><h6 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917141954286.png" alt="image-20210917141954286"></p><h6 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h6><p><code>get key</code> —获取对应的value</p><p><code>set key value </code> —设置key-value</p><p><code>del key </code> —删除key-value</p><p><code>incr </code>、<code>decr</code>、<code>incrby</code>、<code>decrby</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917142509696.png" alt="image-20210917142509696"><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917142621235.png" alt="image-20210917142621235"></p><p><code>set</code> 、<code>setnx</code> 、<code>setxx</code> </p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917143743654.png" alt="image-20210917143743654"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917143857324.png" alt="image-20210917143857324"></p><p><code>getset</code> <code>append</code> <code>strlen</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144407686.png" alt="image-20210917144407686"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144448747.png" alt="image-20210917144448747"></p><p><code>incrbyfloat</code> <code>getrange</code> <code>setrange</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144640080.png" alt="image-20210917144640080"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144720485.png" alt="image-20210917144720485"></p><p><strong>批量操作</strong></p><p><code>mget</code> 、<code>mset</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144058858.png" alt="image-20210917144058858"></p><p><strong>字符串的时间复杂度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917144810938.png" alt="image-20210917144810938"></p><h5 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h5><h6 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h6><p><strong>K-F-V</strong> :类似于在一个map的kv结构中v中存储的是一个map,即嵌套存储。</p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145122371.png" alt="image-20210917145122371"></p><h6 id="重要API-1"><a href="#重要API-1" class="headerlink" title="重要API"></a>重要API</h6><p><strong>PS：所有哈希的命令都是以’h’开头</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145435630.png" alt="image-20210917145435630"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145501710.png"></p><p><code>hexists</code> <code>hlen</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145743942.png" alt="image-20210917145743942"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145824058.png" alt="image-20210917145824058"></p><p><code>hmest</code> <code>hmset</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917145921123.png" alt="image-20210917145921123"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917150011723.png" alt="image-20210917150011723"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917150113175.png" alt="image-20210917150113175"></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p><strong>哈希主要命令的时间复杂度</strong><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917151702749.png" alt="image-20210917151702749"></p><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><h6 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152349868.png" alt="image-20210917152349868"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152602670.png" alt="image-20210917152602670"></p><p>有序的、可以重复的，可以左右两边插入弹出</p><h6 id="重要API-2"><a href="#重要API-2" class="headerlink" title="重要API"></a>重要API</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152842988.png" alt="image-20210917152842988"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917152955218.png" alt="image-20210917152955218"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917154211473.png" alt="image-20210917154211473"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917154530492.png" alt="image-20210917154530492"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155012745.png" alt="image-20210917155012745"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155227402.png" alt=" "></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155622451.png" alt="image-20210917155622451"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917155851704.png" alt="image-20210917155851704"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917161129251.png" alt="image-20210917161129251"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917161524836.png" alt="image-20210917161524836"></p><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><h6 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917161659499.png" alt="image-20210917161659499"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917162536443.png" alt="image-20210917162536443"></p><p>集合是无序的、无重复的。支持集合间的操作。</p><h6 id="重要API-3"><a href="#重要API-3" class="headerlink" title="重要API"></a>重要API</h6><p>**所有的API都是以是S开头 **</p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917162820222.png" alt="image-20210917162820222"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917162940254.png" alt="image-20210917162940254"></p><p><strong>srandmember和spop的区别</strong></p><p><code>spop</code>是直接从集合里弹出</p><p><code>srandmember</code>并不会破坏集合的结构</p><p><strong>示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917163552620.png" alt="image-20210917163552620"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917163809999.png" alt="image-20210917163809999"></p><h5 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h5><h6 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917164900596.png" alt="image-20210917164900596"></p><p>可以根据数值作筛选等有序操作</p><h6 id="与其他结构进行对比"><a href="#与其他结构进行对比" class="headerlink" title="与其他结构进行对比"></a>与其他结构进行对比</h6><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165038922.png" alt="image-20210917165038922"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165314748.png" alt="image-20210917165314748"></p><h6 id="重要API-4"><a href="#重要API-4" class="headerlink" title="重要API"></a>重要API</h6><p><strong>PS：有序集合都是以Z开头的命令</strong></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165547094.png" alt="image-20210917165547094"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917165921077.png" alt="image-20210917165921077"></p><p> <img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917170026404.png" alt="image-20210917170026404"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917170300211.png" alt="image-20210917170300211"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917170334858.png" alt="image-20210917170334858"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917171125461.png" alt="image-20210917171125461"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917171353523.png" alt="image-20210917171353523"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917172517628.png" alt="image-20210917172517628"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917172643001.png" alt="image-20210917172643001"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917172913994.png" alt="image-20210917172913994"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917173040148.png" alt="image-20210917173040148"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917175157232.png" alt="image-20210917175157232"> </p><hr><h4 id="Redis单线程的特点"><a href="#Redis单线程的特点" class="headerlink" title="Redis单线程的特点"></a>Redis单线程的特点</h4><p>命令执行时是类似队列、串行的</p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210917114427993.png" alt="image-20210917114427993"></p><p>Redis使用单线程依靠纯内存、非阻塞IO、避免线程切换和竞态消耗的方式实现快速存取。</p><ul><li>一次只执行一条命令</li><li>拒绝长（慢）命令</li></ul><h1 id="Redis的客户端"><a href="#Redis的客户端" class="headerlink" title="Redis的客户端"></a>Redis的客户端</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h2><h3 id="Jdeis"><a href="#Jdeis" class="headerlink" title="Jdeis"></a>Jdeis</h3><p>根据Redis的规则用Java开发的客户端</p><p><strong>Maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Jedis直连</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个Jedis对象，该对象负责和指定Redis节点进行通信</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//Jedis执行set操作</span></span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>,world);</span><br><span class="line"><span class="comment">//Jedis执行get操作，value=&quot;world&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Jedis的有参构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jedis(String host,<span class="type">int</span> port,<span class="type">int</span> connectionTimeout,<span class="type">int</span> soTimeout)</span><br></pre></td></tr></table></figure><p><strong>PS：参数并非只有此4种</strong></p><ul><li>host:Redis节点的所在机器的IP</li><li>port：Redis节点的端口</li><li>connectionTimeout:客户端连接超时</li><li>soTimeout：客户端读写超时</li></ul><h3 id="Jedis连接池的使用"><a href="#Jedis连接池的使用" class="headerlink" title="Jedis连接池的使用"></a>Jedis连接池的使用</h3><h4 id="Jedis直连"><a href="#Jedis直连" class="headerlink" title="Jedis直连"></a>Jedis直连</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918100033846.png" alt="image-20210918100033846"></p><h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p><img src="http://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918100605012.png" alt="image-20210918100605012"></p><h5 id="Jedis-Pool的使用"><a href="#Jedis-Pool的使用" class="headerlink" title="Jedis Pool的使用"></a>Jedis Pool的使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化Jedis连接池，通常来讲JedisPool是单例的。</span></span><br><span class="line"><span class="type">GenericObjectPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericObjecPoolConfig</span>();</span><br><span class="line"><span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">jedisPool</span>(poolConfig,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1从连接池获取jedis对象</span></span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">//2执行操作</span></span><br><span class="line">    jedis.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果使用JedisPool,close操作不是关闭连接，代表归还连接池</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Jedis配置优化"><a href="#Jedis配置优化" class="headerlink" title="Jedis配置优化"></a>Jedis配置优化</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918111416016.png" alt="image-20210918111416016"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918111801336.png" alt="image-20210918111801336"></p><p> <img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918112111412.png" alt="image-20210918112111412"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918112225237.png" alt="image-20210918112225237"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918113306422.png" alt="image-20210918113306422"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918114005888.png" alt="image-20210918114005888"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918143103174.png" alt="image-20210918143103174"></p><h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918145254658.png" alt="image-20210918145254658"></p><p><strong>两点说明</strong></p><ol><li>慢查询发生在第3阶段</li><li>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</li></ol><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918150648685.png" alt="image-20210918150648685"></p><h4 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h4><p><code>slowlog get[n]</code> :获取慢查询队列</p><p><code>slowlog len</code> :获取慢查询队列长度</p><p><code>slowlog reset</code> :清空慢查询队列</p><h4 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h4><ul><li><p><code>slowlog-max-len </code> 不要设置过大，默认10ms，通常设置1ms</p></li><li><p><code>slowlog-log-slower-than</code>不要设置过小，通常设置1000左右</p></li><li><p>理解命令的生命周期</p></li><li><p>定期持久化慢查询</p></li></ul><h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918154330612.png" alt="image-20210918154330612"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918154400470.png" alt="image-20210918154400470"></p><p><strong>pipeline在Java上的实现</strong></p><ol><li><p>引用Jeids Jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用pipeline</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i*<span class="number">100</span>;j&lt;(i+<span class="number">1</span>)*<span class="number">100</span>;j++)&#123;</span><br><span class="line">    pipeline.hset(<span class="string">&quot;hashkey:&quot;</span> + j,<span class="string">&quot;field&quot;</span> + j,<span class="string">&quot;value&quot;</span> + j);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.syncAndReturnAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p><strong>类似发布-订阅模式</strong></p><ul><li>发布者</li><li>订阅者</li><li>频道</li></ul><p><strong>模型</strong><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918160436858.png" alt="image-20210918160436858"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161109745.png" alt="image-20210918161109745"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h5 id="publish-–-发布命令"><a href="#publish-–-发布命令" class="headerlink" title="publish – 发布命令"></a><strong>publish</strong> – 发布命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161635627.png" alt="image-20210918161635627"></p><h5 id="subcribe-–订阅命令"><a href="#subcribe-–订阅命令" class="headerlink" title="subcribe –订阅命令"></a><strong>subcribe</strong> –订阅命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe [channel] #一个或多个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161759698.png" alt="image-20210918161759698"></p><h5 id="unsubcribe–取消订阅命令"><a href="#unsubcribe–取消订阅命令" class="headerlink" title="unsubcribe–取消订阅命令"></a><code>unsubcribe</code>–取消订阅命令</h5><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161907362.png" alt="image-20210918161907362"></p><h5 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h5><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918161958482.png" alt="image-20210918161958482"></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918162045388.png" alt="image-20210918162045388"></p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><ul><li><p>位图<br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918162633926.png" alt="image-20210918162633926"></p><p><code>setbit</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918162832945.png" alt="image-20210918162832945"></p><p><code>getbit</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163042020.png" alt="image-20210918163042020"></p><p><code>bitcount</code></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163409217.png" alt="image-20210918163409217"></p><p><code>bitop</code><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163500888.png" alt="image-20210918163500888"></p><p><code>bitpos</code><br><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918163736164.png" alt="image-20210918163736164"></p></li></ul><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><ul><li><p>基于HyperLogLog算法 — 极小空间完成独立数量统计</p></li><li><p>本质还是字符串</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><table><thead><tr><th>api</th><th>解释</th></tr></thead><tbody><tr><td><code>pfadd key element[element…]</code></td><td>向hyperloglog添加元素</td></tr><tr><td><code>pfcount key [key ...]</code></td><td>计算hyperloglog的独立总数</td></tr><tr><td><code>pfmerge destkey sourcekey [sourcekey...]</code></td><td>合并多个hyperloglog</td></tr></tbody></table></li></ul><p>​<img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165003646.png" alt="image-20210918165003646"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165141911.png" alt="image-20210918165141911"></p><h1 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>GEO(地理位置定位)：存储经纬度，计算两地距离，范围计算等。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>​<img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165421773.png" alt="image-20210918165421773"></p><h2 id="重要API-5"><a href="#重要API-5" class="headerlink" title="重要API"></a>重要API</h2><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165449507.png" alt="image-20210918165449507"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165515902.png" alt="image-20210918165515902"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165537502.png" alt="image-20210918165537502"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165548785.png" alt="image-20210918165548785"></p><p><img src="https://cdn.jsdelivr.net/gh/coder-0001/Picphoto@main/img/image-20210918165610315.png" alt="image-20210918165610315"></p><h1 id="PS：第4章看完"><a href="#PS：第4章看完" class="headerlink" title="PS：第4章看完"></a>PS：第4章看完</h1>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
