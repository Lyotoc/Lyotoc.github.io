<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>史上最全HashMap面试题汇总 | Lyoto's Blog</title><meta name="keywords" content="技术,HashMap"><meta name="author" content="Lyoto"><meta name="copyright" content="Lyoto"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="目录 1.HashMap的数据结构? 2.HashMap的工作原理? 3.当两个对象的hashCode相同会发生什么? 4.你知道hash的实现吗?为什么要这样实现? 5.为什么要用异或运算符? 6.HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题? 7.HashMap中put方法的过程? 8.数组扩容的过程? 9.拉链法导致的链表过深问">
<meta property="og:type" content="article">
<meta property="og:title" content="史上最全HashMap面试题汇总">
<meta property="og:url" content="https://lyotoc.github.io/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Lyoto&#39;s Blog">
<meta property="og:description" content="目录 1.HashMap的数据结构? 2.HashMap的工作原理? 3.当两个对象的hashCode相同会发生什么? 4.你知道hash的实现吗?为什么要这样实现? 5.为什么要用异或运算符? 6.HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题? 7.HashMap中put方法的过程? 8.数组扩容的过程? 9.拉链法导致的链表过深问">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/pexels-photo-11142231.jpeg">
<meta property="article:published_time" content="2022-09-01T10:34:17.000Z">
<meta property="article:modified_time" content="2022-09-02T09:25:04.805Z">
<meta property="article:author" content="Lyoto">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/pexels-photo-11142231.jpeg"><link rel="shortcut icon" href="/img/laptop.ico"><link rel="canonical" href="https://lyotoc.github.io/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '史上最全HashMap面试题汇总',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-02 17:25:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Lyoto's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/-479e804eaf8f8540.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分组</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/pexels-photo-11142231.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lyoto's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分组</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">史上最全HashMap面试题汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-01T10:34:17.000Z" title="发表于 2022-09-01 18:34:17">2022-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-02T09:25:04.805Z" title="更新于 2022-09-02 17:25:04">2022-09-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="史上最全HashMap面试题汇总"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>目录</strong> <a href="about:blank#1.HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%3F">1.HashMap的数据结构?</a> <a href="about:blank#2.HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%3F">2.HashMap的工作原理?</a> <a href="about:blank#3.%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode%E7%9B%B8%E5%90%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%3F">3.当两个对象的hashCode相同会发生什么?</a> <a href="about:blank#4.%E4%BD%A0%E7%9F%A5%E9%81%93hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97%3F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%3F">4.你知道hash的实现吗?为什么要这样实现?</a> <a href="about:blank#5.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%3F">5.为什么要用异或运算符?</a> <a href="about:blank#6.HashMap%E7%9A%84table%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%3FloadFactor%E6%98%AF%E4%BB%80%E4%B9%88%3F%E8%AF%A5%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%3F%E8%BF%99%E7%A7%8D%E5%8F%98%E5%8C%96%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%3F">6.HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题?</a> <a href="about:blank#7.HashMap%E4%B8%ADput%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B%3F">7.HashMap中put方法的过程?</a> <a href="about:blank#8.%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%E7%9A%84%E8%BF%87%E7%A8%8B%3F">8.数组扩容的过程?</a> <a href="about:blank#9.%E6%8B%89%E9%93%BE%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E9%93%BE%E8%A1%A8%E8%BF%87%E6%B7%B1%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%BB%A3%E6%9B%BF%2C%E8%80%8C%E9%80%89%E6%8B%A9%E7%BA%A2%E9%BB%91%E6%A0%91%3F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%B8%80%E7%9B%B4%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%3F">9.拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?为什么不一直使用红黑树?</a> <a href="about:blank#10.%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%A7%81%E8%A7%A3%3F">10.说说你对红黑树的见解?</a> <a href="about:blank#11.jdk8%E4%B8%AD%E5%AF%B9HashMap%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E5%8F%98%3F">11.jdk8中对HashMap做了哪些改变?</a> <a href="about:blank#12.HashMap%2CLinkedHashMap%2CTreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">12.HashMap,LinkedHashMap,TreeMap有什么区别?</a> <a href="about:blank#13.HashMap%26TreeMap%26LinkedHashMap%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%3F">13.HashMap&amp;TreeMap&amp;LinkedHashMap使用场景?</a> <a href="about:blank#14.HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">14.HashMap和HashTable有什么区别?</a> <a href="about:blank#15.Java%E4%B8%AD%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%8EHashMap%E6%9E%81%E5%85%B6%E7%B1%BB%E4%BC%BC%E7%9A%84%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%3F%E5%90%8C%E6%A0%B7%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2C%E5%AE%83%E4%B8%8EHashTable%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%3F">15.Java中的另一个线程安全的与HashMap极其类似的类是什么?同样是线程安全,它与HashTable在线程同步上有什么不同?</a> <a href="about:blank#16.HashMap%26ConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%3F">16.HashMap&amp;ConcurrentHashMap的区别?</a> <a href="about:blank#17.%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E6%AF%94HashTable%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98%3F">17.为什么ConcurrentHashMap比HashTable效率要高?</a> <a href="about:blank#18.%E9%92%88%E5%AF%B9ConcurrentHashMap%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90%28JDK1.7VSJDK1.8%29%3F">18.针对ConcurrentHashMap锁机制具体分析(JDK1.7VSJDK1.8)?</a> <a href="about:blank#19.ConcurrentHashMap%E5%9C%A8JDK1.8%E4%B8%AD%2C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E9%94%81synchronized%E6%9D%A5%E4%BB%A3%E6%9B%BF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%3F">19.ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?</a> <a href="about:blank#20.ConcurrentHashMap%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%3F">20.ConcurrentHashMap简单介绍?</a> <a href="about:blank#21.ConcurrentHashMap%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88%3F">21.ConcurrentHashMap的并发度是什么?</a> </p>
<h2 id="1-HashMap的数据结构"><a href="#1-HashMap的数据结构" class="headerlink" title="1.HashMap的数据结构?"></a>1.HashMap的数据结构?</h2><p> 哈希表结构(链表散列:数组+链表)实现,结合数组和链表的优点。当链表长度超过<code>8</code>时,链表转换为红黑树。 </p>
<h2 id="2-HashMap的工作原理"><a href="#2-HashMap的工作原理" class="headerlink" title="2.HashMap的工作原理?"></a>2.HashMap的工作原理?</h2><p> <code>HashMap</code>底层是hash数组和单向链表实现,数组中的每个元素都是链表,由Node内部类(实现<code>Map.Entry&lt;K,V&gt;</code>接口)实现,<code>HashMap</code>通过<code>put&amp;get</code>方法存储和获取。 <strong>存储对象时,将<code>K/V</code>键值传给<code>put()</code>方法:</strong> </p>
<p>①、调用hash(K)方法计算K的hash值,然后结合数组长度,计算得数组下标;     </p>
<p>②、调整数组大小(当容器中的元素个数大于capacity*loadfactor时,容器会进行扩容resize为2n);    </p>
<p> ③   i.如果K的<code>hash</code>值在<code>HashMap</code>中不存在,则执行插入,若存在,则发生碰撞;</p>
<p>​		ii.如果K的<code>hash</code>值在<code>HashMap</code>中存在,且它们两者<code>equals</code>返回<code>true</code>,则更新键值对;</p>
<p>​		iii.如果K的<code>hash</code>值在<code>HashMap</code>中存在,且它们两者<code>equals</code>返回false,则插入链表的尾部(尾插法)或者红黑树中(树的添加方式)。        </p>
<blockquote>
<p>(<code>JDK1.7</code>之前使用头插法、<code>JDK1.8</code>使用尾插法)  </p>
<p> (注意:当碰撞导致链表大于<code>TREEIFY_THRESHOLD=8</code>时,就把链表转换成红黑树)</p>
</blockquote>
<p><strong>获取对象时,将<code>K</code>传给<code>get()</code>方法:</strong> </p>
<p>①、调用hash(K)方法(计算K的hash值)从而获取该键值所在链表的数组下标;</p>
<p>②、顺序遍历链表,equals()方法查找相同Node链表中K值对应的V值。<code>hashCode</code>是定位的,存储位置;<code>equals</code>是定性的,比较两者是否相等。 </p>
<h2 id="3-当两个对象的hashCode相同会发生什么"><a href="#3-当两个对象的hashCode相同会发生什么" class="headerlink" title="3.当两个对象的hashCode相同会发生什么?"></a>3.当两个对象的hashCode相同会发生什么?</h2><p> 因为<code>hashCode</code>相同,不一定就是相等的(<code>equals</code>方法比较),所以两个对象所在数组的下标相同,”碰撞”就此发生。又因为<code>HashMap</code>使用链表存储对象,这个<code>Node</code>会存储到链表中。 </p>
<h2 id="4-你知道hash的实现吗"><a href="#4-你知道hash的实现吗" class="headerlink" title="4.你知道hash的实现吗?"></a>4.你知道hash的实现吗?</h2><p>为什么要这样实现? <code>JDK1.8</code>中,是通过<code>hashCode()</code>的高16位异或低16位实现的:<code>(h=k.hashCode())^(h&gt;&gt;&gt;16)</code>,主要是从速度,功效和质量来考虑的,减少系统的开销,也不会造成因为高位没有参与下标的计算,从而引起的碰撞。 <img src="https://img-blog.csdnimg.cn/20200727193840237.png"> 计算过程如下所示： </p>
<p>说明：</p>
<ul>
<li><p>key.hashCode()；返回散列值也就是hashcode，假设随便生成的一个值。 *   n表示数组初始化的长度是16。</p>
</li>
<li><p>&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。 </p>
</li>
<li><p>^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。        <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2020072719423689.png"></p>
</li>
</ul>
<p>简单来说就是： <strong>高16bit不变，低16bit和高16bit做了一个异或（得到的hashCode转化为32位二进制，前16位和后16位低16bit和高16bit做了一个异或）</strong> </p>
<p>问题：为什么要这样操作呢？ 如果当n即数组长度很小，假设是16的话，那么n - 1即为1111 ，这样的值和hashCode直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。 <img src="https://img-blog.csdnimg.cn/20200727194307147.png"></p>
<h2 id="5-为什么要用异或运算符"><a href="#5-为什么要用异或运算符" class="headerlink" title="5.为什么要用异或运算符?"></a>5.为什么要用异或运算符?</h2><p>保证了对象的<code>hashCode</code>的32位值只要有一位发生改变,整个<code>hash()</code>返回值就会改变。尽可能的减少碰撞。 </p>
<h2 id="6-HashMap的table的容量如何确定"><a href="#6-HashMap的table的容量如何确定" class="headerlink" title="6.HashMap的table的容量如何确定?"></a>6.HashMap的table的容量如何确定?</h2><p>loadFactor是什么?该容量如何变化?这种变化会带来什么问题? </p>
<ul>
<li>①、<code>table</code>数组大小是由<code>capacity</code>这个参数确定的,默认是16,也可以构造时传入,最大限制是1&lt;&lt;30;     </li>
<li>②、<code>loadFactor</code>是装载因子,主要目的是用来确认<code>table</code>数组是否需要动态扩展,默认值是0.75,比如<code>table</code>数组大小为16,装载因子为0.75时,<code>threshold</code>就是12,当<code>table</code>的实际大小超过12时,<code>table</code>就需要动态扩容;     </li>
<li>③、扩容时,调用<code>resize()</code>方法,将<code>table</code>长度变为原来的两倍(注意是table长度,而不是<code>threshold</code>)     </li>
<li>④、如果数据很大的情况下,扩展时将会带来性能的损失,在性能要求很高的地方,这种损失很可能很致命。</li>
</ul>
<h2 id="7-HashMap中put方法的过程"><a href="#7-HashMap中put方法的过程" class="headerlink" title="7.HashMap中put方法的过程?"></a>7.HashMap中put方法的过程?</h2><ul>
<li><p>调用哈希函数获取<code>Key</code>对应的<code>hash</code>值,再计算其数组下标;     </p>
</li>
<li><p>如果没有出现哈希冲突,则直接放入数组;如果出现哈希冲突,则以链表的方式放在链表后面;     </p>
</li>
<li><p>如果链表长度超过阀值(<code>TREEIFYTHRESHOLD==8</code>),就把链表转成红黑树,链表长度低于6,就把红黑树转回链表;     </p>
</li>
<li><p>如果结点的<code>key</code>已经存在,则替换其<code>value</code>即可;     </p>
</li>
<li><p>如果集合中的键值对大于12,调用<code>resize</code>方法进行数组扩容。</p>
</li>
</ul>
<pre><code>![](https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200618150149962.png)     
</code></pre>
<h2 id="8-数组扩容的过程"><a href="#8-数组扩容的过程" class="headerlink" title="8.数组扩容的过程?"></a>8.数组扩容的过程?</h2><p>创建一个新的数组,其容量为旧数组的两倍,并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种,原下标位置或原下标+旧数组的大小。 </p>
<p>什么时候才需要扩容？</p>
<p>当HashMap中的元素个数超过数组大小(数组长度)</p>
<ul>
<li><p>loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75&#x3D;12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。 </p>
<p>补充： </p>
<p>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，结点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的结点个数低于6，也会再把树转换为链表。 </p>
<p>HashMap的扩容是什么？</p>
</li>
</ul>
<p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以结点要么就在原来的位置，要么就被分配到”原位置+旧容量”这个位置。    <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727194809948.png"> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727194830581.png"> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727194908184.png"> </p>
<h2 id="9-拉链法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树"><a href="#9-拉链法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树" class="headerlink" title="9.拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?"></a>9.拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?</h2><p>为什么不一直使用红黑树? </p>
<p>之所以选择红黑树是为了解决二叉查找树的缺陷,二叉查找树在特殊情况下会变成一条线性结构(这就跟原来使用链表结构一样了,造成很深的问题),遍历查找会非常慢。</p>
<p>而红黑树在插入新数据后可能需要通过左旋,右旋、变色这些操作来保持平衡,引入红黑树就是为了查找数据快,解决链表查询深度的问题,我们知道红黑树属于平衡二叉树,但是为了保持”平衡”是需要付出代价的,但是该代价所损耗的资源要比遍历线性链表要少,所以当长度大于8的时候,会使用红黑树,如果链表长度很短的话,根本不需要引入红黑树,引入反而会慢。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727195342649.png"> </p>
<h2 id="10-说说你对红黑树的见解"><a href="#10-说说你对红黑树的见解" class="headerlink" title="10.说说你对红黑树的见解?"></a>10.说说你对红黑树的见解?</h2><ul>
<li>1、每个节点非红即黑    </li>
<li>2、根节点总是黑色的     </li>
<li>3、如果节点是红色的,则它的子节点必须是黑色的(反之不一定)     </li>
<li>4、每个叶子节点都是黑色的空节点(NIL节点)     </li>
<li>5、从根节点到叶节点或空子节点的每条路径,必须包含相同数目的黑色节点(即相同的黑色高度)</li>
</ul>
<h2 id="11-jdk8中对HashMap做了哪些改变"><a href="#11-jdk8中对HashMap做了哪些改变" class="headerlink" title="11.jdk8中对HashMap做了哪些改变?"></a>11.jdk8中对HashMap做了哪些改变?</h2><ul>
<li>在<code>java1.8</code>中,如果链表的长度超过了8,那么链表将转换为红黑树。(桶的数量必须大于64,小于64的时候只会扩容) </li>
<li>发生<code>hash</code>碰撞时,<code>java1.7</code>会在链表的头部插入,而<code>java1.8</code>会在链表的尾部插入     </li>
<li>在<code>java1.8</code>中,<code>Entry</code>被<code>Node</code>替代(换了一个马甲)。</li>
</ul>
<h2 id="12-HashMap-LinkedHashMap-TreeMap有什么区别"><a href="#12-HashMap-LinkedHashMap-TreeMap有什么区别" class="headerlink" title="12.HashMap,LinkedHashMap,TreeMap有什么区别?"></a>12.HashMap,LinkedHashMap,TreeMap有什么区别?</h2><ul>
<li><code>HashMap</code>参考其他问题;     </li>
<li><pre><code> `LinkedHashMap`保存了记录的插入顺序,在用`Iterator`遍历时,先取到的记录肯定是先插入的;遍历比`HashMap`慢;     
</code></pre>
</li>
<li><pre><code> `TreeMap`实现`SortMap`接口,能够把它保存的记录根据键排序(默认按键值升序排序,也可以指定排序的比较器)
</code></pre>
</li>
</ul>
<h2 id="13-HashMap-amp-TreeMap-amp-LinkedHashMap使用场景"><a href="#13-HashMap-amp-TreeMap-amp-LinkedHashMap使用场景" class="headerlink" title="13.HashMap&amp;TreeMap&amp;LinkedHashMap使用场景?"></a>13.HashMap&amp;TreeMap&amp;LinkedHashMap使用场景?</h2><p>一般情况下,使用最多的是<code>HashMap</code>。  </p>
<p> <strong>HashMap:</strong> 在Map中插入、删除和定位元素时;  </p>
<p> <strong>TreeMap:</strong> 在需要按自然顺序或自定义顺序遍历键的情况下;   </p>
<p><strong>LinkedHashMap:</strong> 在需要输出的顺序和输入的顺序相同的情况下。</p>
<h2 id="14-HashMap和HashTable有什么区别"><a href="#14-HashMap和HashTable有什么区别" class="headerlink" title="14.HashMap和HashTable有什么区别?"></a>14.HashMap和HashTable有什么区别?</h2><ul>
<li>①、<code>HashMap</code>是线程不安全的,<code>HashTable</code>是线程安全的;     </li>
<li>②、由于线程安全,所以<code>HashTable</code>的效率比不上<code>HashMap</code>;     </li>
<li>③、<code>HashMap</code>最多只允许一条记录的键为<code>null</code>,允许多条记录的值为<code>null</code>,而<code>HashTable</code>不允许;     </li>
<li>④、<code>HashMap</code>默认初始化数组的大小为16,<code>HashTable</code>为11,前者扩容时,扩大两倍,后者扩大两倍+1;     </li>
<li>⑤、<code>HashMap</code>需要重新计算hash值,而<code>HashTable</code>直接使用对象的<code>hashCode</code>;</li>
</ul>
<h2 id="15-HashMap-的底层数组长度为何总是2的n次方-？"><a href="#15-HashMap-的底层数组长度为何总是2的n次方-？" class="headerlink" title="15.HashMap 的底层数组长度为何总是2的n次方 ？"></a>15.HashMap 的底层数组长度为何总是2的n次方 ？</h2><p><strong>HashMap</strong>根据用户传入的初始化容量，利用无符号右移和按位或运算等方式计算出第一个大于该数的2的幂。 </p>
<blockquote>
<ul>
<li>使数据分布均匀，减少碰撞</li>
<li>当length为2的n次方时，h&amp;(length - 1) 就相当于对length取模，而且在速度、效率上比直接取模要快得多</li>
</ul>
</blockquote>
<h3 id="jdk1-8中做了哪些优化优化？"><a href="#jdk1-8中做了哪些优化优化？" class="headerlink" title="jdk1.8中做了哪些优化优化？"></a>jdk1.8中做了哪些优化优化？</h3><ol>
<li>数组+链表改成了数组+链表或红黑树 </li>
<li>链表的插入方式从头插法改成了尾插法 </li>
<li>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小； </li>
<li>在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；</li>
</ol>
<h3 id="HashMap线程安全方面会出现什么问题"><a href="#HashMap线程安全方面会出现什么问题" class="headerlink" title="HashMap线程安全方面会出现什么问题 *"></a><strong><code>HashMap线程安全方面会出现什么问题</code></strong> *</h3><p>在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。</p>
<ul>
<li>在jdk1.8中，在多线程环境下，会发生数据覆盖的情况</li>
</ul>
<h3 id="为什么HashMap的底层数组长度为何总是2的n次方"><a href="#为什么HashMap的底层数组长度为何总是2的n次方" class="headerlink" title="为什么HashMap的底层数组长度为何总是2的n次方"></a>为什么HashMap的底层数组长度为何总是2的n次方</h3><p>   这里我觉得可以用逆向思维来解释这个问题，我们计算桶的位置完全可以使用<code>h % length</code>，如果这个length是随便设定值的话当然也可以，但是如果你对它进行研究，设计一个合理的值得话，那么将对HashMap的性能发生翻天覆地的变化。 </p>
<p>没错，JDK源码作者就发现了，那就是当length为2的N次方的时候，那么，为什么这么说呢？ </p>
<p><strong>第一：当length为2的N次方的时候，h &amp; (length-1) &#x3D; h % length</strong>   </p>
<p>为什么&amp;效率更高呢？因为位运算直接对内存数据进行操作，不需要转成十进制，所以位运算要比取模运算的效率更高 </p>
<p><strong>第二：当length为2的N次方的时候，数据分布均匀，减少冲突</strong>    </p>
<h3 id="那么为什么默认是16呢？怎么不是4？不是8？"><a href="#那么为什么默认是16呢？怎么不是4？不是8？" class="headerlink" title="那么为什么默认是16呢？怎么不是4？不是8？"></a>那么为什么默认是16呢？怎么不是4？不是8？</h3><p> 关于这个默认容量的选择，JDK并没有给出官方解释，那么这应该就是个经验值，既然一定要设置一个默认的2^n 作为初始值，那么就需要在效率和内存使用上做一个权衡。这个值既不能太小，也不能太大。 太小了就有可能频繁发生扩容，影响效率。太大了又浪费空间，不划算。 所以，16就作为一个经验值被采用了。 <strong>在JDK1.8的 236 行有1&lt;&lt;4就是16</strong>，为啥用位运算呢？直接写16不好么？ <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBscWZlZzFwajMxNzQwNTRqc2IuanBn"> 我们在创建HashMap的时候，阿里巴巴规范插件会提醒我们最好赋初值，而且最好是2的幂。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBsdW96MTBuajMwcHkwNTJnbWEuanBn"> 这样是为了位运算的方便，<strong>位与运算比算数计算的效率高了很多</strong>，之所以选择16，是为了服务将Key映射到index的算法。 我前面说了所有的key我们都会拿到他的hash，但是我们怎么尽可能的得到一个均匀分布的hash呢？ 是的我们通过Key的HashCode值去做位运算。 我们再看下index的计算公式：index &#x3D; HashCode（Key） &amp; （Length- 1）   15的的二进制是1111，那10111011000010110100 &amp;1111 十进制就是4 之所以用位与运算效果与取模一样，性能也提高了不少！ 那为啥用16不用别的呢？ 因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。 只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了实现均匀分布。 当length为奇数时，length-1为偶数，而偶数二进制的最后一位永远为0，那么与其进行 &amp; 运算，得到的二进制数最后一位永远为0，那么结果一定是偶数，那么就会导致下标为奇数的桶永远不会放置数据，这就不符合我们均匀放置，减少冲突的要求了。 那么可能钻牛角尖的同学还会问，那length是偶数不就行了么，为什么一定要是2的N次方，这不就又回到第一点原因了么？（<strong>当length为2的N次方的时候，h &amp; (length-1) &#x3D; h % length</strong>）</p>
<p>JDK 的工程师把各种位运算运用到了极致，想尽各种办法优化效率。</p>
<h3 id="HashMap的不安全体现在哪里？"><a href="#HashMap的不安全体现在哪里？" class="headerlink" title="HashMap的不安全体现在哪里？"></a>HashMap的不安全体现在哪里？</h3><p>hashMap是<strong>线程不安全</strong>的，其主要体现：</p>
<blockquote>
<p>1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。 </p>
<p> 2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。 现在我们要在容量为2的容器里面<strong>用不同线程</strong>插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。 我们可以看到链表的指向A-&gt;B-&gt;C <strong>Tip：A的下一个指针是指向B的</strong> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBrYXhnZzVpajMwNTAwN29kZnIuanBn"> </p>
<p>因为resize的赋值方式，也就是使用了<strong>单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</strong>，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 就可能出现下面的情况，大家发现问题没有？ B的下一个指针指向了A 一旦几个线程都调整完成，就可能出现环形链表 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnOXBraDhvbWp5ajMwYWwwNnBteDQuanBn"> </p>
<p>如果这个时候去取值，悲剧就出现了——Infinite Loop。 jdk1.8中HashMap中put操作的主函数，如果没有hash碰撞则会直接插入元素。如果线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入第6行代码中。假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给<strong>覆盖</strong>，发生线程不安全。 </p>
<p>更多请参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/developer_chan/p/10450908.html">https://www.cnblogs.com/developer_chan&#x2F;p&#x2F;10450908.html</a> </p>
</blockquote>
<h3 id="为什么JDK1-8使用红黑树？"><a href="#为什么JDK1-8使用红黑树？" class="headerlink" title="为什么JDK1.8使用红黑树？"></a><strong>为什么JDK1.8使用红黑树？</strong></h3><p>   比如某些人通过找到你的hash碰撞值，来让你的HashMap不断地产生碰撞，那么相同key位置的链表就会不断增长，当你需要对这个HashMap的相应位置进行查询的时候，就会去循环遍历这个超级大的链表，性能及其低下。</p>
<p>java8使用红黑树来替代超过8个节点数的链表后，查询方式性能得到了很好的提升，从原来的是O(n)到O(logn)。    </p>
<h3 id="1-8中的扩容为什么逻辑判断更简单"><a href="#1-8中的扩容为什么逻辑判断更简单" class="headerlink" title="1.8中的扩容为什么逻辑判断更简单"></a>1.8中的扩容为什么逻辑判断更简单</h3><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200618150837955.png"> 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200618150847782.png"> 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。 </p>
<h3 id="HashMap中容量的初始化"><a href="#HashMap中容量的初始化" class="headerlink" title="HashMap中容量的初始化"></a><strong>HashMap中容量的初始化</strong></h3><p> 当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？ 关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议： <img src="https://img-blog.csdnimg.cn/20200628232950242.png#pic_center" alt="建议"> 也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 &#x3D; 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727200145905.png"> <img src="https://img-blog.csdnimg.cn/20200727200218332.png"> <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/20200727200354118.png"> 如果我们通过<code>initialCapacity/ 0.75F + 1.0F</code>计算，<code>7/0.75 + 1 = 10</code> ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。 当<code>HashMap</code>内部维护的哈希表的容量达到75%时（默认情况下），会触发<code>rehash</code>，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<code>initialCapacity/0.75 + 1</code>的话，可以有效的减少冲突也可以减小误差。</p>
<p> 所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成initialCapacity&#x2F; 0.75F + 1.0F是一个在性能上相对好的选择，但是，同时也会牺牲些内存。 我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。 但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。 但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成initialCapacity&#x2F; 0.75F + 1.0F。 </p>
<h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p> 当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。 </p>
<h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p> 答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/QGhurt/article/details/107323702?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&utm_relevant_index=1">什么是哈希</a>什么是哈希？</p>
<p> <strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）</strong>；</p>
<p>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。</p>
<p><strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。 所有散列函数都有如下一个基本特性**：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同**。</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/QGhurt/article/details/107323702?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-107323702-blog-89373872.pc_relevant_multi_platform_whitelistv4eslandingctr2&utm_relevant_index=1">什么是哈希冲突？</a> </p>
<p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p>
<p><strong>HashMap的数据结构</strong> </p>
<p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。</p>
<p>**数组的特点是：寻址容易，插入和删除困难；</p>
<p><strong>链表的特点是：寻址困难，但插入和删除容易</strong>；</p>
<p>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n" alt="img"> 这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化 </p>
<p><strong>hash()函数</strong> </p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下： <code>static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或） &#125;</code> 这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>
<p> 通过上面的<strong>链地址法（使用散列表）</strong>和<strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)； </p>
<p>总结 简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的： </p>
<blockquote>
<p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong></p>
<p><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong>   </p>
<p> <strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong> </p>
</blockquote>
<h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置； </p>
<p><strong>那怎么解决呢？</strong> </p>
<ol>
<li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均； </li>
<li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li>
</ol>
<h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><p> 为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。 </p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p> 我们首先可能会想到采用%取余的操作来实现。</p>
<p>但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” </p>
<p>并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p> <strong>那为什么是两次扰动呢？</strong></p>
<p> 答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<p> ConcurrentHashMap篇 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h3 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol>
<li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。） </li>
<li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li>
</ol>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><p><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； </p>
</li>
<li><p><strong>实现线程安全的方式（重要）</strong>：</p>
<p> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 <strong>两者的对比图</strong>： </p>
<p>HashTable: <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY" alt="img"> </p>
<p>JDK1.7的ConcurrentHashMap： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ" alt="img"> JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk" alt="img"> 答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
</li>
</ul>
<h3 id="ConcurrentHashMap-底层具体实现知道吗？"><a href="#ConcurrentHashMap-底层具体实现知道吗？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？"></a>ConcurrentHashMap 底层具体实现知道吗？</h3><p>实现原理是什么？</p>
<p> <strong>JDK1.7</strong> 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。 </p>
<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，</p>
<p>结构如下： </p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTY0NTgzNmU3MjJjMmE5ZjkucG5n" alt="img"> 1.  该类包含两个静态内部类 HashEntry 和 Segment ；</p>
<p>前者用来封装映射表的键值对，后者用来充当锁的角色； </p>
<ol start="2">
<li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>
</ol>
<p> <strong>JDK1.8</strong> 在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。 结构如下： <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWVjODU2MDM5NWUyNTU0N2EucG5n" alt="img"> <strong>附加源码，有需要的可以看看</strong> 插入元素过程（建议去看看源码）： 如果相应位置的Node还没有初始化，则调用CAS插入相应的数据； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))        <span class="keyword">break</span>; <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点； </span></span><br><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    </span><br><span class="line">    binCount = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek; </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||(ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123; </span><br><span class="line">            oldVal = e.val; </span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;       </span><br><span class="line">        &#125;        </span><br><span class="line">        Node&lt;K,V&gt; pred = e;        </span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123; </span><br><span class="line">            pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<ol>
<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值； </li>
<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>
</ol>
<h2 id="15-Java中的另一个线程安全的与HashMap极其类似的类是什么"><a href="#15-Java中的另一个线程安全的与HashMap极其类似的类是什么" class="headerlink" title="15.Java中的另一个线程安全的与HashMap极其类似的类是什么?"></a>15.Java中的另一个线程安全的与HashMap极其类似的类是什么?</h2><h3 id="同样是线程安全-它与HashTable在线程同步上有什么不同"><a href="#同样是线程安全-它与HashTable在线程同步上有什么不同" class="headerlink" title="同样是线程安全,它与HashTable在线程同步上有什么不同?"></a>同样是线程安全,它与HashTable在线程同步上有什么不同?</h3><p> <code>ConcurrentHashMap</code>类(是<code>Java</code>并发包<code>java.util.concurrent</code>中提供的一个线程安全且高效的<code>HashMap</code>实现)。</p>
<p>   <code>HashTable</code>是使用<code>synchronize</code>关键字加锁的原理(就是对对象加锁);  </p>
<p> 而针对<code>ConcurrentHashMap</code>,在<code>JDK1.7</code>中采用分段锁的方式;</p>
<p><code>JDK1.8</code>中直接采用了**<code>CAS</code>(无锁算法)+<code>synchronized</code>**。 </p>
<h2 id="16-HashMap-amp-ConcurrentHashMap的区别"><a href="#16-HashMap-amp-ConcurrentHashMap的区别" class="headerlink" title="16.HashMap&amp;ConcurrentHashMap的区别?"></a>16.HashMap&amp;ConcurrentHashMap的区别?</h2><p>除了加锁,原理上无太大区别。</p>
<p>另外,<code>HashMap</code>的键值对允许有<code>null</code>,但是<code>ConCurrentHashMap</code>都不允许。</p>
<h2 id="17-为什么ConcurrentHashMap比HashTable效率要高"><a href="#17-为什么ConcurrentHashMap比HashTable效率要高" class="headerlink" title="17.为什么ConcurrentHashMap比HashTable效率要高?"></a>17.为什么ConcurrentHashMap比HashTable效率要高?</h2><p> <code>HashTable</code>使用一把锁(锁住整个链表结构)处理并发问题,多个线程竞争一把锁,容易阻塞;   <code>ConcurrentHashMap</code> </p>
<ul>
<li><code>JDK1.7</code>中使用分段锁(<code>ReentrantLock</code>+<code>Segment</code>+<code>HashEntry</code>),相当于把一个<code>HashMap</code>分成多个段,每段分配一把锁,这样支持多线程访问。锁粒度:基于<code>Segment</code>,包含多个<code>HashEntry</code>。    </li>
<li><code>JDK1.8</code>中使用<code>CAS</code>+<code>synchronized</code>+<code>Node</code>+红黑树。锁粒度:<code>Node</code>(首结点)(实现<code>Map.Entry&lt;K,V&gt;</code>)。锁粒度降低了。</li>
</ul>
<h2 id="18-针对ConcurrentHashMap锁机制具体分析-JDK1-7VSJDK1-8"><a href="#18-针对ConcurrentHashMap锁机制具体分析-JDK1-7VSJDK1-8" class="headerlink" title="18.针对ConcurrentHashMap锁机制具体分析(JDK1.7VSJDK1.8)?"></a>18.针对ConcurrentHashMap锁机制具体分析(JDK1.7VSJDK1.8)?</h2><p> <code>JDK1.7</code>中,采用分段锁的机制,实现并发的更新操作,底层采用数组+链表的存储结构,包括两个核心静态内部类<code>Segment</code>和<code>HashEntry</code>。 *   ①、<code>Segment</code>继承<code>ReentrantLock</code>(重入锁)用来充当锁的角色,每个<code>Segment</code>对象守护每个散列映射表的若干个桶;     *   ②、<code>HashEntry</code>用来封装映射表的键-值对;     *   ③、每个桶是由若干个<code>HashEntry</code>对象链接起来的链表;     <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9GYjYwTklvVFl6YTF4UTdpYk5lSnVWR01nR0g5eEJWVkh0UWdNenZzamR1akdXdFo0Y25pYXFyenhxRWoxR1RHbWRnb05VWjhGbDFnQ2x6S2VSM0lGT2ljZy82NDA"> <code>JDK1.8</code>中,采用<code>Node</code>+<code>CAS</code>+<code>Synchronized</code>来保证并发安全。取消类<code>Segment</code>,直接用<code>table</code>数组存储键值对;当<code>HashEntry</code>对象组成的链表长度超过<code>TREEIFY_THRESHOLD</code>时,链表转换为红黑树,提升性能。底层变更为数组+链表+红黑树。 <img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9GYjYwTklvVFl6YTF4UTdpYk5lSnVWR01nR0g5eEJWVkhnY2pWaWNoN2FvQ3FVRGdvb1lLSzVNZG03V3JLOURMZEdPVllNeWo4Zm5GNktiNXI4TVlWR3lRLzY0MA"> </p>
<h3 id="19-ConcurrentHashMap在JDK1-8中-为什么要使用内置锁synchronized来代替重入锁ReentrantLock"><a href="#19-ConcurrentHashMap在JDK1-8中-为什么要使用内置锁synchronized来代替重入锁ReentrantLock" class="headerlink" title="19.ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?"></a>19.ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?</h3><ul>
<li>①、粒度降低了;     </li>
<li><pre><code>②、`JVM`开发团队没有放弃`synchronized`,而且基于`JVM`的`synchronized`优化空间更大,更加自然。     
</code></pre>
</li>
<li>③、在大量的数据操作下,对于<code>JVM</code>的内存压力,基于<code>API</code>的<code>ReentrantLock</code>会开销更多的内存。</li>
</ul>
<h3 id="20-ConcurrentHashMap简单介绍"><a href="#20-ConcurrentHashMap简单介绍" class="headerlink" title="20.ConcurrentHashMap简单介绍?"></a>20.ConcurrentHashMap简单介绍?</h3><ul>
<li><p>①、重要的常量:<br><code>private transient volatile intsizeCtl</code>;<br>当为负数时,-1表示正在初始化,-N表示N-1个线程正在进行扩容;  </p>
<p>当为0时,表示<code>table</code>还没有初始化;            </p>
<p>当为其他正数时,表示初始化或者下一次进行扩容的大小。        </p>
</li>
<li><p>②、数据结构:<br>  <code>Node</code>是存储结构的基本单元,继承<code>HashMap</code>中的<code>Entry</code>,用于存储数据;            <code>TreeNode</code>继承<code>Node</code>,但是数据结构换成了二叉树结构,是红黑树的存储结构,用于红黑树中存储数据;<br><code>TreeBin</code>是封装<code>TreeNode</code>的容器,提供转换红黑树的一些条件和锁的控制。         </p>
</li>
<li><p>③、存储对象时(<code>put()</code>方法):        </p>
<ul>
<li>1.如果没有初始化,就调用<code>initTable()</code>方法来进行初始化;           </li>
<li>2.如果没有<code>hash</code>冲突就直接<code>CAS</code>无锁插入;            </li>
<li>3.如果需要扩容,就先进行扩容;         </li>
<li>4.如果存在<code>hash</code>冲突,就加锁来保证线程安全,两种情况:一种是链表形式就直接遍历到尾端插入,一种是红黑树就按照红黑树结构插入;            </li>
<li>5.如果该链表的数量大于阀值8,就要先转换成红黑树的结构,<code>break</code>再一次进入循环            </li>
<li>6.如果添加成功就调用<code>addCount()</code>方法统计<code>size</code>,并且检查是否需要扩容。</li>
</ul>
</li>
<li><p>④、<strong>扩容方法<code>transfer()</code>:</strong> 默认容量为16,扩容时,容量变为原来的两倍。      <strong><code>helpTransfer()</code>:</strong> 调用多个工作线程一起帮助进行扩容,这样的效率就会更高。     </p>
</li>
<li><p>⑤、获取对象时(<code>get()</code>方法):        </p>
</li>
<li><p>1.计算hash值,定位到该<code>table</code>索引位置,如果是首结点符合就返回;            </p>
</li>
<li><p>2.如果遇到扩容时,会调用标记正在扩容结点<code>ForwardingNode.find()</code>方法,查找该结点,匹配就返回;           </p>
</li>
<li><p>3.以上都不符合的话,就往下遍历结点,匹配就返回,否则最后就返回<code>null</code></p>
</li>
</ul>
<h3 id="21-ConcurrentHashMap的并发度是什么"><a href="#21-ConcurrentHashMap的并发度是什么" class="headerlink" title="21.ConcurrentHashMap的并发度是什么?"></a>21.ConcurrentHashMap的并发度是什么?</h3><p> 程序运行时能够同时更新<code>ConccurentHashMap</code>且不产生锁竞争的最大线程数。</p>
<p>默认为16,且可以在构造函数中设置。当用户设置并发度时,<code>ConcurrentHashMap</code>会使用大于等于该值的最小2幂指数作为实际并发度(假如用户设置并发度为17,实际并发度则为32) </p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lyotoc.github.io">Lyoto</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lyotoc.github.io/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">https://lyotoc.github.io/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lyotoc.github.io" target="_blank">Lyoto's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/HashMap/">HashMap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/pexels-photo-11142231.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/09/01/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%88&amp;%EF%BC%89%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%EF%BC%88%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1%E7%AE%97%E6%B3%95%EF%BC%89/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/footprints_hires.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">位运算之——按位与（&amp;）操作——（快速取模算法）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/29/Spring%E6%9D%82%E7%83%A9/" title="Spring杂烩"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/pexels-photo-11142231.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-29</div><div class="title">Spring杂烩</div></div></a></div><div><a href="/2022/09/01/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%88&%EF%BC%89%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%EF%BC%88%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1%E7%AE%97%E6%B3%95%EF%BC%89/" title="位运算之——按位与（&amp;）操作——（快速取模算法）"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/footprints_hires.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-01</div><div class="title">位运算之——按位与（&amp;）操作——（快速取模算法）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/-479e804eaf8f8540.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lyoto</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lyotoc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lyotoc" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="mailto:supreme00119@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Lyoto's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">1.HashMap的数据结构?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2.HashMap的工作原理?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode%E7%9B%B8%E5%90%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">3.</span> <span class="toc-text">3.当两个对象的hashCode相同会发生什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%A0%E7%9F%A5%E9%81%93hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97"><span class="toc-number">4.</span> <span class="toc-text">4.你知道hash的实现吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">5.为什么要用异或运算符?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-HashMap%E7%9A%84table%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A"><span class="toc-number">6.</span> <span class="toc-text">6.HashMap的table的容量如何确定?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-HashMap%E4%B8%ADput%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">7.HashMap中put方法的过程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">8.数组扩容的过程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%8B%89%E9%93%BE%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E9%93%BE%E8%A1%A8%E8%BF%87%E6%B7%B1%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%BB%A3%E6%9B%BF-%E8%80%8C%E9%80%89%E6%8B%A9%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">9.拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%A7%81%E8%A7%A3"><span class="toc-number">10.</span> <span class="toc-text">10.说说你对红黑树的见解?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-jdk8%E4%B8%AD%E5%AF%B9HashMap%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E5%8F%98"><span class="toc-number">11.</span> <span class="toc-text">11.jdk8中对HashMap做了哪些改变?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-HashMap-LinkedHashMap-TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">12.HashMap,LinkedHashMap,TreeMap有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-HashMap-amp-TreeMap-amp-LinkedHashMap%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.</span> <span class="toc-text">13.HashMap&amp;TreeMap&amp;LinkedHashMap使用场景?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">14.HashMap和HashTable有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BD%95%E6%80%BB%E6%98%AF2%E7%9A%84n%E6%AC%A1%E6%96%B9-%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">15.HashMap 的底层数组长度为何总是2的n次方 ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk1-8%E4%B8%AD%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">15.1.</span> <span class="toc-text">jdk1.8中做了哪些优化优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">15.2.</span> <span class="toc-text">HashMap线程安全方面会出现什么问题 *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BD%95%E6%80%BB%E6%98%AF2%E7%9A%84n%E6%AC%A1%E6%96%B9"><span class="toc-number">15.3.</span> <span class="toc-text">为什么HashMap的底层数组长度为何总是2的n次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AF16%E5%91%A2%EF%BC%9F%E6%80%8E%E4%B9%88%E4%B8%8D%E6%98%AF4%EF%BC%9F%E4%B8%8D%E6%98%AF8%EF%BC%9F"><span class="toc-number">15.4.</span> <span class="toc-text">那么为什么默认是16呢？怎么不是4？不是8？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">15.5.</span> <span class="toc-text">HashMap的不安全体现在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JDK1-8%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">15.6.</span> <span class="toc-text">为什么JDK1.8使用红黑树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8%E4%B8%AD%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E6%9B%B4%E7%AE%80%E5%8D%95"><span class="toc-number">15.7.</span> <span class="toc-text">1.8中的扩容为什么逻辑判断更简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%AD%E5%AE%B9%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">15.8.</span> <span class="toc-text">HashMap中容量的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.9.</span> <span class="toc-text">HashMap的put方法的具体流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%EF%BC%9F"><span class="toc-number">15.10.</span> <span class="toc-text">HashMap是怎么解决哈希冲突的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8hashCode-%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E7%9B%B4%E6%8E%A5%E4%BD%9C%E4%B8%BAtable%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%9F"><span class="toc-number">15.11.</span> <span class="toc-text">HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="toc-number">15.12.</span> <span class="toc-text">HashMap 的长度为什么是2的幂次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.13.</span> <span class="toc-text">HashMap 和 ConcurrentHashMap 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.14.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">15.15.</span> <span class="toc-text">ConcurrentHashMap 底层具体实现知道吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Java%E4%B8%AD%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%8EHashMap%E6%9E%81%E5%85%B6%E7%B1%BB%E4%BC%BC%E7%9A%84%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">16.</span> <span class="toc-text">15.Java中的另一个线程安全的与HashMap极其类似的类是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%A0%B7%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%AE%83%E4%B8%8EHashTable%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">16.1.</span> <span class="toc-text">同样是线程安全,它与HashTable在线程同步上有什么不同?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-HashMap-amp-ConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">16.HashMap&amp;ConcurrentHashMap的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E6%AF%94HashTable%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98"><span class="toc-number">18.</span> <span class="toc-text">17.为什么ConcurrentHashMap比HashTable效率要高?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E9%92%88%E5%AF%B9ConcurrentHashMap%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-JDK1-7VSJDK1-8"><span class="toc-number">19.</span> <span class="toc-text">18.针对ConcurrentHashMap锁机制具体分析(JDK1.7VSJDK1.8)?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-ConcurrentHashMap%E5%9C%A8JDK1-8%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E9%94%81synchronized%E6%9D%A5%E4%BB%A3%E6%9B%BF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock"><span class="toc-number">19.1.</span> <span class="toc-text">19.ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-ConcurrentHashMap%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.2.</span> <span class="toc-text">20.ConcurrentHashMap简单介绍?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-ConcurrentHashMap%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">19.3.</span> <span class="toc-text">21.ConcurrentHashMap的并发度是什么?</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" title="史上最全HashMap面试题汇总"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/pexels-photo-11142231.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="史上最全HashMap面试题汇总"/></a><div class="content"><a class="title" href="/2022/09/01/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" title="史上最全HashMap面试题汇总">史上最全HashMap面试题汇总</a><time datetime="2022-09-01T10:34:17.000Z" title="发表于 2022-09-01 18:34:17">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/01/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%88&amp;%EF%BC%89%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%EF%BC%88%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1%E7%AE%97%E6%B3%95%EF%BC%89/" title="位运算之——按位与（&amp;）操作——（快速取模算法）"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/footprints_hires.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="位运算之——按位与（&amp;）操作——（快速取模算法）"/></a><div class="content"><a class="title" href="/2022/09/01/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%88&amp;%EF%BC%89%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%EF%BC%88%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1%E7%AE%97%E6%B3%95%EF%BC%89/" title="位运算之——按位与（&amp;）操作——（快速取模算法）">位运算之——按位与（&amp;）操作——（快速取模算法）</a><time datetime="2022-09-01T08:09:06.000Z" title="发表于 2022-09-01 16:09:06">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/footprints_hires.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程池"/></a><div class="content"><a class="title" href="/2022/08/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池">线程池</a><time datetime="2022-08-26T10:53:45.000Z" title="发表于 2022-08-26 18:53:45">2022-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/26/AQS/" title="AQS"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/pexels-photo-11142231.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS"/></a><div class="content"><a class="title" href="/2022/08/26/AQS/" title="AQS">AQS</a><time datetime="2022-08-26T10:51:02.000Z" title="发表于 2022-08-26 18:51:02">2022-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/11/shiro%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/" title="shiro权限认证"><img src="https://cdn.jsdelivr.net/gh/Lyotoc/Picphoto@main/img/2001312704_1_d51e812760ca960a68f48e0f9b6f44bc.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shiro权限认证"/></a><div class="content"><a class="title" href="/2022/08/11/shiro%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/" title="shiro权限认证">shiro权限认证</a><time datetime="2022-08-11T07:31:37.000Z" title="发表于 2022-08-11 15:31:37">2022-08-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Lyoto</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>